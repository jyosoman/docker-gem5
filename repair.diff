diff -r 2492d7ccda7e -r 33141d198579 .hgignore
--- a/.hgignore	Fri Jul 19 11:52:07 2013 +0200
+++ b/.hgignore	Wed Aug 05 11:39:08 2015 +0100
@@ -9,3 +9,4 @@
 .*.swp
 m5out
 src/doxygen
+src/python/m5/util/*.pyc
diff -r 2492d7ccda7e -r 33141d198579 build_opts/ARM
--- a/build_opts/ARM	Fri Jul 19 11:52:07 2013 +0200
+++ b/build_opts/ARM	Wed Aug 05 11:39:08 2015 +0100
@@ -1,3 +1,3 @@
 TARGET_ISA = 'arm'
-CPU_MODELS = 'AtomicSimpleCPU,TimingSimpleCPU,O3CPU'
+CPU_MODELS = 'AtomicSimpleCPU,TimingSimpleCPU,O3CPU,TimingHelperCPU,TimingDeadCPU'
 PROTOCOL = 'MI_example'
diff -r 2492d7ccda7e -r 33141d198579 configs/common/CacheConfig.py
--- a/configs/common/CacheConfig.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/configs/common/CacheConfig.py	Wed Aug 05 11:39:08 2015 +0100
@@ -1,6 +1,6 @@
 # Copyright (c) 2012-2013 ARM Limited
 # All rights reserved
-# 
+#
 # The license below extends only to copyright in the software and shall
 # not be construed as granting a license to any other intellectual
 # property including but not limited to intellectual property relating
@@ -9,7 +9,7 @@
 # terms below provided that you ensure that this notice is replicated
 # unmodified and in its entirety in all distributions of the software,
 # modified or unmodified, in source code or in binary form.
-# 
+#
 # Copyright (c) 2010 Advanced Micro Devices, Inc.
 # All rights reserved.
 #
diff -r 2492d7ccda7e -r 33141d198579 configs/common/CpuConfig.py
--- a/configs/common/CpuConfig.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/configs/common/CpuConfig.py	Wed Aug 05 11:39:08 2015 +0100
@@ -40,6 +40,12 @@
 import sys
 from textwrap import  TextWrapper
 
+import m5
+from m5.util import addToPath, fatal
+import os.path
+
+addToPath('../common')
+
 # Dictionary of mapping names of real CPU models to classes.
 _cpu_classes = {}
 
@@ -110,9 +116,11 @@
 # The ARM detailed CPU is special in the sense that it doesn't exist
 # in the normal object hierarchy, so we have to add it manually.
 try:
-    from O3_ARM_v7a import O3_ARM_v7a_3
+    from O3_ARM_v7a import *
+#    from O3_ARM_v7a import O3_ARM_v7a_3
     _cpu_classes["arm_detailed"] = O3_ARM_v7a_3
 except:
+    print "Error occured, coudn't import arm cpu"
     pass
 
 # Add all CPUs in the object hierarchy.
diff -r 2492d7ccda7e -r 33141d198579 configs/common/HelperCacheConfig.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/common/HelperCacheConfig.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,145 @@
+# Copyright (c) 2012-2013 ARM Limited
+# All rights reserved
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Copyright (c) 2010 Advanced Micro Devices, Inc.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Lisa Hsu
+
+# Configure the M5 cache hierarchy config in one place
+#
+
+import m5
+from m5.objects import *
+from Caches import *
+
+def config_cache(options, system):
+    if options.cpu_type == "arm_detailed":
+        try:
+            from O3_ARM_v7a import *
+        except:
+            print "arm_detailed is unavailable. Did you compile the O3 model?"
+            sys.exit(1)
+
+        dcache_class, icache_class, l2_cache_class = \
+            O3_ARM_v7a_DCache, O3_ARM_v7a_ICache, O3_ARM_v7aL2
+    else:
+        dcache_class, icache_class, l2_cache_class = \
+            L1Cache, L1Cache, L2Cache
+
+    # Set the cache line size of the system
+    system.cache_line_size = options.cacheline_size
+
+    if options.l2cache:
+        # Provide a clock for the L2 and the L1-to-L2 bus here as they
+        # are not connected using addTwoLevelCacheHierarchy. Use the
+        # same clock as the CPUs, and set the L1-to-L2 bus width to 32
+        # bytes (256 bits).
+        system.l2 = l2_cache_class(clk_domain=system.cpu_clk_domain,
+                                   size=options.l2_size,
+                                   assoc=options.l2_assoc)
+
+        system.tol2bus = CoherentBus(clk_domain = system.cpu_clk_domain,
+                                     width = 32)
+        system.l2.cpu_side = system.tol2bus.master
+        system.l2.mem_side = system.membus.slave
+
+    np = options.num_cpus
+#    system.cpu[np].addL2CacheConnection(system.l2)
+    for i in xrange(options.num_cpus):
+        if options.caches:
+            icache = icache_class(size=options.l1i_size,
+                                  assoc=options.l1i_assoc)
+            dcache = dcache_class(size=options.l1d_size,
+                                  assoc=options.l1d_assoc)
+
+            # When connecting the caches, the clock is also inherited
+            # from the CPU in question
+            if buildEnv['TARGET_ISA'] == 'x86':
+                system.cpu[i].addPrivateSplitL1Caches(icache, dcache,
+                                                      PageTableWalkerCache(),
+                                                      PageTableWalkerCache())
+            else:
+                system.cpu[i].addPrivateSplitL1Caches(icache, dcache)
+        system.cpu[i].createInterruptController()
+        if options.l2cache:
+            system.cpu[i].connectAllPorts(system.tol2bus, system.membus)
+        else:
+            system.cpu[i].connectAllPorts(system.membus)
+            # When connecting the caches, the clock is also inherited
+            # from the CPU in question
+    if len(system.cpu)!=options.num_cpus:
+        if options.caches:
+            icache = icache_class(size="2kB",
+                    assoc=options.l1i_assoc)
+            dcache = dcache_class(size="2kB",
+                    assoc=options.l1d_assoc)
+
+            if buildEnv['TARGET_ISA'] == 'x86':
+                system.cpu[np].addPrivateSplitL1Caches(icache, dcache,
+                        PageTableWalkerCache(),
+                        PageTableWalkerCache())
+            else:
+                system.cpu[np].addPrivateSplitL1Caches(icache, dcache)
+            system.cpu[np].createInterruptController()
+            if options.l2cache:
+                 system.cpu[np].connectAllPorts(system.tol2bus, system.membus)
+            else:
+                  system.cpu[np].connectAllPorts(system.membus)
+
+        system.cpu[np].createInterruptController()
+    return system
+def addRepairCache(options,system):
+    if len(system.cpu)!=options.num_cpus:
+        if options.caches:
+            icache = icache_class(size="2kB",
+                    assoc=options.l1i_assoc)
+            dcache = dcache_class(size="2kB",
+                    assoc=options.l1d_assoc)
+
+            if buildEnv['TARGET_ISA'] == 'x86':
+                system.cpu[np].addPrivateSplitL1Caches(icache, dcache,
+                        PageTableWalkerCache(),
+                        PageTableWalkerCache())
+            else:
+                system.cpu[np].addPrivateSplitL1Caches(icache, dcache)
+            system.cpu[np].createInterruptController()
+            if options.l2cache:
+                 system.cpu[np].connectAllPorts(system.tol2bus, system.membus)
+            else:
+                  system.cpu[np].connectAllPorts(system.membus)
+
+        system.cpu[np].createInterruptController()
+    return system
diff -r 2492d7ccda7e -r 33141d198579 configs/common/Options.py
--- a/configs/common/Options.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/configs/common/Options.py	Wed Aug 05 11:39:08 2015 +0100
@@ -64,6 +64,11 @@
                       help = "type of cpu to run with")
     parser.add_option("--checker", action="store_true");
     parser.add_option("-n", "--num-cpus", type="int", default=1)
+    parser.add_option("--sys-voltage", action="store", type="string",
+                      default='1.0V',
+                      help = """Top-level voltage for blocks running at system
+                      power supply""")
+
     parser.add_option("--sys-clock", action="store", type="string",
                       default='1GHz',
                       help = """Top-level clock for blocks running at system
@@ -81,12 +86,16 @@
     parser.add_option("--list-mem-types",
                       action="callback", callback=_listMemTypes,
                       help="List available memory types")
-    parser.add_option("--mem-type", type="choice", default="simple_mem",
+    parser.add_option("--mem-type", type="choice", default="ddr3_1600_x64",
                       choices=MemConfig.mem_names(),
                       help = "type of memory to use")
+    parser.add_option("--mem-channels", type="int", default=1,
+                      help = "number of memory channels")
     parser.add_option("--mem-size", action="store", type="string",
-                      default="512MB",
+                      default="2048MB",
                       help="Specify the physical memory size (single memory)")
+    parser.add_option("-l", "--lpae", action="store_true")
+    parser.add_option("-V", "--virtualisation", action="store_true")
 
     # Cache Options
     parser.add_option("--caches", action="store_true")
@@ -109,7 +118,7 @@
     parser.add_option("--ruby", action="store_true")
 
     # Run duration options
-    parser.add_option("-m", "--abs-max-tick", type="int", default=None,
+    parser.add_option("-m", "--abs-max-tick", type="int", default=m5.MaxTick,
                       metavar="TICKS", help="Run to absolute simulated tick " \
                       "specified including ticks from a restored checkpoint")
     parser.add_option("--rel-max-tick", type="int", default=None,
@@ -124,6 +133,9 @@
                                             simulate (default: run forever)""")
     parser.add_option("--work-item-id", action="store", type="int",
                       help="the specific work id for exit & checkpointing")
+    parser.add_option("--num-work-ids", action="store", type="int",
+                      help="Number of distinct work item types")
+
     parser.add_option("--work-begin-cpu-id-exit", action="store", type="int",
                       help="exit when work starts on the specified cpu")
     parser.add_option("--work-end-exit-count", action="store", type="int",
@@ -191,6 +203,16 @@
     parser.add_option("--at-instruction", action="store_true", default=False,
         help="""Treat value of --checkpoint-restore or --take-checkpoint as a
                 number of instructions.""")
+    parser.add_option("--spec-input", default="ref", type="choice",
+                      choices=["ref", "test", "train", "smred", "mdred",
+                               "lgred"],
+                      help="Input set size for SPEC CPU2000 benchmarks.")
+    parser.add_option("--arm-iset", default="arm", type="choice",
+                      choices=["arm", "thumb", "aarch64"],
+                      help="ARM instruction set.")
+
+def addErrorOptions(parser):
+    parser.add_option("--error_file",action="store",type="string")
 
 def addSEOptions(parser):
     # Benchmark options
@@ -226,6 +248,9 @@
         parser.add_option("--dtb-filename", action="store", type="string",
               help="Specifies device tree blob file to use with device-tree-"\
               "enabled kernels")
+        parser.add_option("--enable-context-switch-stats-dump", \
+                action="store_true", help="Enable stats dump at context "\
+                "switches and dump tasks file (required for Streamline)")
     # Benchmark options
     parser.add_option("--dual", action="store_true",
                       help="Simulate two systems attached with an ethernet link")
diff -r 2492d7ccda7e -r 33141d198579 configs/common/Simulation.py
--- a/configs/common/Simulation.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/configs/common/Simulation.py	Wed Aug 05 11:39:08 2015 +0100
@@ -1,6 +1,6 @@
 # Copyright (c) 2012-2013 ARM Limited
 # All rights reserved
-# 
+#
 # The license below extends only to copyright in the software and shall
 # not be construed as granting a license to any other intellectual
 # property including but not limited to intellectual property relating
@@ -53,6 +53,44 @@
 
 addToPath('../common')
 
+from Caches import *
+
+import errors
+
+def addRepairCache(options, system, cpu):
+    if options.cpu_type == "arm_detailed":
+        try:
+            from O3_ARM_v7a import *
+        except:
+            print "arm_detailed is unavailable. Did you compile the O3 model?"
+            sys.exit(1)
+
+        dcache_class, icache_class, l2_cache_class = \
+            O3_ARM_v7a_DCache, O3_ARM_v7a_ICache, O3_ARM_v7aL2
+    else:
+        dcache_class, icache_class, l2_cache_class = \
+            L1Cache, L1Cache, L2Cache
+
+    if options.caches:
+        icache = icache_class(size="2kB",
+                assoc=options.l1i_assoc)
+        dcache = dcache_class(size="2kB",
+                assoc=options.l1d_assoc)
+
+        if buildEnv['TARGET_ISA'] == 'x86':
+            cpu.addPrivateSplitL1Caches(icache, dcache,
+                    PageTableWalkerCache(),
+                    PageTableWalkerCache())
+#        else:
+#            cpu.addPrivateSplitL1Caches(icache, dcache)
+        cpu.createInterruptController()
+        if options.l2cache:
+             cpu.connectAllPorts(system.tol2bus, system.membus)
+        else:
+              cpu.connectAllPorts(system.membus)
+
+    cpu.createInterruptController()
+    return system
 def getCPUClass(cpu_type):
     """Returns the required cpu class and the mode of operation."""
     cls = CpuConfig.get(cpu_type)
@@ -93,6 +131,8 @@
 def setWorkCountOptions(system, options):
     if options.work_item_id != None:
         system.work_item_id = options.work_item_id
+    if options.num_work_ids != None:
+        system.num_work_ids = options.num_work_ids
     if options.work_begin_cpu_id_exit != None:
         system.work_begin_cpu_id_exit = options.work_begin_cpu_id_exit
     if options.work_end_exit_count != None:
@@ -126,6 +166,7 @@
     if not isdir(cptdir):
         fatal("checkpoint dir %s does not exist!", cptdir)
 
+    cpt_starttick = 0
     if options.at_instruction or options.simpoint:
         inst = options.checkpoint_restore
         if options.simpoint:
@@ -217,25 +258,136 @@
 
     return exit_event
 
-def benchCheckpoints(options, maxtick, cptdir):
+def allCoresReachedMaxInsts(maxinsts, pause, cpulist,incr):
+    cores_finished = 0
+    core_num = 0
+#    print len(cpulist)
+    for cpu in cpulist:
+        if cpu.totalInsts() >= int(maxinsts):
+            print "{0:d} cpu finished work".format(core_num)
+            cores_finished += 1
+            if pause:
+                cpu.pause(True)
+        core_num += 1
+#    print cores_finished
+#    print len(cpulist)
+
+    cores_finished +=incr
+    if cores_finished >= len(cpulist):
+#        print "Completed the run"
+        if pause:
+            for cpu in cpulist:
+                cpu.pause(False)
+        return True
+    return False
+
+def warmupAllCores(options, cpulist,incr):
+#    print "Warming up the cores"
+    exit_event = m5.simulate()
+    exit_cause = exit_event.getCause()
+#    print "Exited first round"
+    while exit_cause == "a thread reached the max instruction count":
+        print "At tick {0:d} a core reached the max instruction count".format(m5.curTick())
+#        m5.stats.dump()
+        m5.stats.reset()
+        if allCoresReachedMaxInsts(int(options.warmup_insts), options.pause_after_warmup, cpulist,incr):
+            break
+#        print "New cpu run starting off"
+        exit_event = m5.simulate()
+        exit_cause = exit_event.getCause()
+
+    return exit_event
+
+def benchCheckpoints(options, maxtick, cptdir, cpulist):
     exit_event = m5.simulate(maxtick - m5.curTick())
     exit_cause = exit_event.getCause()
 
     num_checkpoints = 0
     max_checkpoints = options.max_checkpoints
 
-    while exit_cause == "checkpoint":
-        m5.checkpoint(joinpath(cptdir, "cpt.%d"))
-        num_checkpoints += 1
-        if num_checkpoints == max_checkpoints:
-            exit_cause = "maximum %d checkpoints dropped" % max_checkpoints
-            break
+    while exit_cause == "checkpoint" or \
+            exit_cause == "a thread reached the max instruction count":
+
+        if exit_cause == "checkpoint":
+            m5.checkpoint(joinpath(cptdir, "cpt.%d"))
+            num_checkpoints += 1
+            if num_checkpoints == max_checkpoints:
+                exit_cause = "maximum %d checkpoints dropped" % max_checkpoints
+                break
+        else:
+            print "At tick {0:d} a core reached the max instruction count".format(m5.curTick())
+            m5.stats.dump()
+            if allCoresReachedMaxInsts(options.maxinsts, options.pause_at_max_insts, cpulist,1):
+                break
 
         exit_event = m5.simulate(maxtick - m5.curTick())
         exit_cause = exit_event.getCause()
 
     return exit_event
 
+def repeatSwitchHelper(testsys,options,maxtick,blockSize):
+    simulate_cycles = m5.MaxTick-m5.curTick()
+    numBlocks=simulate_cycles/blockSize
+    np = options.num_cpus
+
+    main_cpus=testsys.cpu
+    for x in xrange(numBlocks):
+        exit_event = m5.simulate(blockSize)
+        exit_cause = exit_event.getCause()
+        if exit_cause == "a thread reached the max instruction count":
+           print "At tick {0:d} a core reached the max instruction count".format(m5.curTick())
+           m5.stats.dump()
+
+           cores_finished = 0
+           for i in xrange(np):
+               if main_cpus[i].totalInsts() >= int(options.maxinsts):
+                    cores_finished += 1
+           if x ==numBlocks-1:
+               if cores_finished == np:
+                  break
+           print "{0:d} number of processors reached maximum instruction count".format(cores_finished)
+        elif exit_cause == "simulate() limit reached":
+             m5.stats.dump()
+             m5.stats.reset()
+             break
+        else:
+             fatal("Early exit because {0}".format(exit_cause))
+        m5.switchCpus(testsys, repeat_switch_cpu_list)
+        tmp_cpu_list = []
+        for old_cpu, new_cpu in repeat_switch_cpu_list:
+            tmp_cpu_list.append((new_cpu, old_cpu))
+        repeat_switch_cpu_list = tmp_cpu_list
+
+    print "At tick {0} all cores reached the max instruction count".format(m5.curTick())
+    return exit_event
+
+def runBreakless(testsys,options,maxtick):
+    simulate_cycles = m5.MaxTick-m5.curTick()
+    np = options.num_cpus
+
+    main_cpus=testsys.cpu
+    while True:
+        exit_event = m5.simulate(simulate_cycles)
+        exit_cause = exit_event.getCause()
+        if exit_cause == "a thread reached the max instruction count":
+#           print "At tick {0:d} a core reached the max instruction count".format(m5.curTick())
+           m5.stats.dump()
+           cores_finished = 0
+           import sys
+           for i in xrange(np):
+               if main_cpus[i].totalInsts() >= int(options.maxinsts):
+                    cores_finished += 1
+           sys.stdout.write("[%-20s] %d%%" % ('='*cores_finished*5, 25*cores_finished))
+           if cores_finished == np:
+              break
+        elif exit_cause == "simulate() limit reached":
+             m5.stats.dump()
+             m5.stats.reset()
+        else:
+             fatal("Early exit because {0}".format(exit_cause))
+    print "At tick {0} all cores reached the max instruction count".format(m5.curTick())
+    return exit_event
+
 def repeatSwitch(testsys, repeat_switch_cpu_list, maxtick, switch_freq):
     print "starting switch loop"
     while True:
@@ -288,29 +440,67 @@
             testsys.cpu[i].max_insts_any_thread = options.maxinsts
 
     if cpu_class:
+#        print "**** Alternate class available ****"
+        # print cpu_class
         switch_cpus = [cpu_class(switched_out=True, cpu_id=(i))
                        for i in xrange(np)]
+        tCpu=TimingHelperCPU(switched_out=True,cpu_id=np+1)
 
+        if options.error_file:
+           addRepairCache(options,testsys,tCpu)
+        switch_cpus.append(tCpu)
         for i in xrange(np):
+            if options.robCount:
+                switch_cpus[i].numROBEntries=options.robCount
             if options.fast_forward:
                 testsys.cpu[i].max_insts_any_thread = int(options.fast_forward)
+            elif options.warmup_insts:
+                testsys.cpu[i].max_insts_any_thread = int(options.warmup_insts)
             switch_cpus[i].system =  testsys
             switch_cpus[i].workload = testsys.cpu[i].workload
             switch_cpus[i].clk_domain = testsys.cpu[i].clk_domain
+            testsys.cpu[i].branchPred=switch_cpus[i].branchPred
+
             # simulation period
             if options.maxinsts:
                 switch_cpus[i].max_insts_any_thread = options.maxinsts
             # Add checker cpu if selected
             if options.checker:
                 switch_cpus[i].addCheckerCpu()
+        if options.error_file:
+            # print "Error file found! Adding errors to CPU"
+            # print options.error_file
+            errorList=errors.splitCPUErrorOptions(options.error_file)
+            if len(errorList) < np:
+                print "Number of CPUs dont match error list"
+                sys.exit(1)
+            else:
+                for i in xrange(np):
+                    switch_cpus[i].efetch,switch_cpus[i].efetchValue  = errors.splitTokens(errorList[i][0])
+                    switch_cpus[i].efetchZ,switch_cpus[i].efetchZValue  = errors.splitTokens(errorList[i][1])
+                    switch_cpus[i].eSB,switch_cpus[i].eSBValue   = errors.splitTokens(errorList[i][2])
+                    switch_cpus[i].eIQ,switch_cpus[i].eIQValue    = errors.splitTokens(errorList[i][3])
+                    switch_cpus[i].eRM,switch_cpus[i].eRMValue     = errors.splitTokens(errorList[i][4])
+                    switch_cpus[i].ePR,switch_cpus[i].ePRValue      = errors.splitTokens(errorList[i][5])
+                    switch_cpus[i].eROB,switch_cpus[i].eROBValue      = errors.splitTokens(errorList[i][6])
+                    switch_cpus[i].eLQ,switch_cpus[i].eLQValue      = errors.splitTokens(errorList[i][7])
+                    switch_cpus[i].eSQ,switch_cpus[i].eSQValue      = errors.splitTokens(errorList[i][7])
+                    switch_cpus[i].eFU,switch_cpus[i].eFUValue       = errors.splitTokens(errorList[i][8])
+
+        switch_cpus[np].system =  testsys
+        switch_cpus[np].workload = testsys.cpu[0].workload
+        switch_cpus[np].clk_domain = testsys.cpu[0].clk_domain
 
         testsys.switch_cpus = switch_cpus
+#        switch_cpu_list = [(testsys.cpu[i], switch_cpus[i]) for i in xrange(len(testsys.cpu))]
         switch_cpu_list = [(testsys.cpu[i], switch_cpus[i]) for i in xrange(np)]
-
+#        print "Number of cpu in testsys is "+ str(len(testsys.cpu))
+#        print "Number of cpu in switch list is "+ str(len(switch_cpus))
     if options.repeat_switch:
+        print "**** Repeat Switch ****"
         switch_class = getCPUClass(options.cpu_type)[0]
         if switch_class.require_caches() and \
-                not options.caches:
+           not options.caches:
             print "%s: Must be used with caches" % str(switch_class)
             sys.exit(1)
         if not switch_class.support_take_over():
@@ -341,6 +531,7 @@
                                       for i in xrange(np)]
 
     if options.standard_switch:
+        print "**** Standard Switch ****"
         switch_cpus = [TimingSimpleCPU(switched_out=True, cpu_id=(i))
                        for i in xrange(np)]
         switch_cpus_1 = [DerivO3CPU(switched_out=True, cpu_id=(i))
@@ -409,8 +600,10 @@
                 testsys.cpu[i].max_insts_any_thread = offset
 
     checkpoint_dir = None
-    if options.checkpoint_restore:
+    if options.checkpoint_restore != None:
+ #       print "**** Restoring from checkpoint ****"
         cpt_starttick, checkpoint_dir = findCptDir(options, cptdir, testsys)
+ #   print "**** Instantiating the objects ****"
     m5.instantiate(checkpoint_dir)
 
     # Handle the max tick settings now that tick frequency was resolved
@@ -430,6 +623,11 @@
             # NOTE: this may need to be updated if checkpoints ever store
             # the ticks per simulated second
             maxtick_from_rel += cpt_starttick
+            if options.at_instruction or options.simpoint:
+                warn("Relative max tick specified with --at-instruction or" \
+                     " --simpoint\n      These options don't specify the " \
+                     "checkpoint start tick, so assuming\n      you mean " \
+                     "absolute max tick")
         explicit_maxticks += 1
     if options.maxtime:
         maxtick_from_maxtime = m5.ticks.fromSeconds(options.maxtime)
@@ -443,6 +641,22 @@
         fatal("Bad maxtick (%d) specified: " \
               "Checkpoint starts starts from tick: %d", maxtick, cpt_starttick)
 
+    cpulist = testsys.cpu
+
+    if not options.standard_switch:
+        if options.warmup_insts:
+            if options.maxinsts:
+                for i in xrange(np):
+                    testsys.cpu[i].max_insts_any_thread = options.warmup_insts
+
+            print "Warm up for instruction count %s" % \
+                    str(testsys.cpu[0].max_insts_any_thread)
+#            exit_event = warmupAllCores(options, testsys.cpu,1)
+            if options.maxinsts:
+                for i in xrange(np):
+                    testsys.cpu[i].max_insts_any_thread = options.maxinsts
+
+
     if options.standard_switch or cpu_class:
         if options.standard_switch:
             print "Switch at instruction count:%s" % \
@@ -452,13 +666,19 @@
             print "Switch at instruction count:%s" % \
                     str(testsys.cpu[0].max_insts_any_thread)
             exit_event = m5.simulate()
+        elif cpu_class and options.warmup_insts:
+            print "Switch at instruction count:%s" % \
+                    str(testsys.cpu[0].max_insts_any_thread)
+            exit_event = warmupAllCores(options, testsys.cpu,1)
         else:
-            print "Switch at curTick count:%s" % str(10000)
+            print "Switch at curTick count for transition from old cpu to new cpu :%s" % str(10000)
             exit_event = m5.simulate(10000)
         print "Switched CPUS @ tick %s" % (m5.curTick())
 
         m5.switchCpus(testsys, switch_cpu_list)
 
+        cpulist = testsys.switch_cpus
+
         if options.standard_switch:
             print "Switch at instruction count:%d" % \
                     (testsys.switch_cpus[0].max_insts_any_thread)
@@ -472,6 +692,7 @@
             print "Simulation ends instruction count:%d" % \
                     (testsys.switch_cpus_1[0].max_insts_any_thread)
             m5.switchCpus(testsys, switch_cpu_list1)
+            cpulist = testsys.switch_cpus_1
 
     # If we're taking and restoring checkpoints, use checkpoint_dir
     # option only for finding the checkpoints to restore from.  This
@@ -492,7 +713,6 @@
     else:
         if options.fast_forward:
             m5.stats.reset()
-        print "**** REAL SIMULATION ****"
 
         # If checkpoints are being taken, then the checkpoint instruction
         # will occur in the benchmark code it self.
@@ -500,11 +720,12 @@
             exit_event = repeatSwitch(testsys, repeat_switch_cpu_list,
                                       maxtick, options.repeat_switch)
         else:
-            exit_event = benchCheckpoints(options, maxtick, cptdir)
+            exit_event = benchCheckpoints(options, maxtick, cptdir, cpulist)
+            print "****REAL SIMULATION ****"
 
     print 'Exiting @ tick %i because %s' % (m5.curTick(), exit_event.getCause())
     if options.checkpoint_at_end:
         m5.checkpoint(joinpath(cptdir, "cpt.%d"))
 
-    if not m5.options.interactive:
-        sys.exit(exit_event.getCode())
+    # if not m5.options.interactive:
+    #     sys.exit(exit_event.getCode())
diff -r 2492d7ccda7e -r 33141d198579 configs/common/cpu2006.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/common/cpu2006.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,382 @@
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+#          Timothy M. Jones
+
+import os
+import sys
+from os.path import basename, exists, join as joinpath, normpath
+from os.path import isdir, isfile, islink
+
+spec_dist = os.environ.get('M5_CPU2006', '/home/js2072/repo/cpu2006')
+
+def copyfiles(srcdir, dstdir):
+    from filecmp import cmp as filecmp
+    from shutil import copyfile
+
+    srcdir = normpath(srcdir)
+    dstdir = normpath(dstdir)
+
+    if not isdir(dstdir):
+        os.mkdir(dstdir)
+
+    for root, dirs, files in os.walk(srcdir):
+        root = normpath(root)
+        prefix = os.path.commonprefix([root, srcdir])
+
+        root = root[len(prefix):]
+        if root.startswith('/'):
+            root = root[1:]
+
+        for entry in dirs:
+            newdir = joinpath(dstdir, root, entry)
+            if not isdir(newdir):
+                os.mkdir(newdir)
+
+        for entry in files:
+            dest = normpath(joinpath(dstdir, root, entry))
+            src = normpath(joinpath(srcdir, root, entry))
+            if not isfile(dest) or not filecmp(src, dest):
+                copyfile(src, dest)
+
+    # some of the spec benchmarks expect to be run from one directory up.
+    # just create some symlinks that solve the problem
+    inlink = joinpath(dstdir, 'input')
+    outlink = joinpath(dstdir, 'output')
+    if not exists(inlink):
+        os.symlink('.', inlink)
+    if not exists(outlink):
+        os.symlink('.', outlink)
+
+class Benchmark(object):
+    def __init__(self, isa, os, input_set):
+        if not hasattr(self.__class__, 'name'):
+            self.name = self.__class__.__name__
+
+        if not hasattr(self.__class__, 'binary'):
+            self.binary = self.name
+
+        if not hasattr(self.__class__, 'args'):
+            self.args = []
+
+        if not hasattr(self.__class__, 'output'):
+            self.output = '%s.out' % self.name
+
+        if not hasattr(self.__class__, 'simpoint'):
+            self.simpoint = None
+
+        try:
+            func = getattr(self.__class__, input_set)
+        except AttributeError:
+            raise AttributeError, \
+                  'The benchmark %s does not have the %s input set' % \
+                  (self.name, input_set)
+
+        executable = joinpath(spec_dist, 'binaries', isa, os, self.binary)
+        if not isfile(executable):
+            raise AttributeError, '%s not found' % executable
+        self.executable = executable
+
+        # root of tree for input & output data files
+        data_dir = joinpath(spec_dist, 'data', self.name)
+        # optional subtree with files shared across input sets
+        all_dir = joinpath(data_dir, 'all')
+        # dirs for input & output files for this input set
+        inputs_dir = joinpath(data_dir, input_set, 'input')
+        outputs_dir = joinpath(data_dir, input_set, 'output')
+        # keep around which input set was specified
+        self.input_set = input_set
+
+        if not isdir(inputs_dir):
+            raise AttributeError, '%s not found' % inputs_dir
+
+        self.inputs_dir = [ inputs_dir ]
+        if isdir(all_dir):
+            self.inputs_dir += [ joinpath(all_dir, 'input') ]
+        if isdir(outputs_dir):
+            self.outputs_dir = outputs_dir
+
+        if not hasattr(self.__class__, 'stdin'):
+            self.stdin = joinpath(inputs_dir, '%s.in' % self.name)
+            if not isfile(self.stdin):
+                try:
+                    infile = getattr(self.__class__, 'infile')
+                    self.stdin = joinpath(inputs_dir, infile)
+                    if not isfile(self.stdin):
+                        self.stdin = None
+                except AttributeError:
+                    self.stdin = None
+
+        if not hasattr(self.__class__, 'stdout'):
+            # self.stdout = joinpath(outputs_dir, '%s.out' % self.name)
+            # if not isfile(self.stdout):
+            #     self.stdout = None
+            self.stdout = None
+
+        func(self, isa, os)
+
+    def makeLiveProcessArgs(self, **kwargs):
+        # set up default args for LiveProcess object
+        process_args = {}
+        process_args['cmd'] = [ self.name ] + self.args
+        process_args['executable'] = self.executable
+        if self.stdin:
+            process_args['input'] = self.stdin
+        if self.stdout:
+            process_args['output'] = self.stdout
+        if self.simpoint:
+            process_args['simpoint'] = self.simpoint
+        # explicit keywords override defaults
+        process_args.update(kwargs)
+
+        return process_args
+
+    def makeLiveProcess(self, copy=True, **kwargs):
+        process_args = self.makeLiveProcessArgs(**kwargs)
+
+        # figure out working directory: use m5's outdir unless
+        # overridden by LiveProcess's cwd param
+        cwd = process_args.get('cwd')
+
+        if not cwd:
+            from m5 import options
+            cwd = options.outdir
+            process_args['cwd'] = cwd
+        if not isdir(cwd):
+            os.makedirs(cwd)
+
+        # copy input files to working directory
+        if copy:
+            for d in self.inputs_dir:
+                copyfiles(d, cwd)
+
+        # generate LiveProcess object
+        from m5.objects import LiveProcess
+        return LiveProcess(**process_args)
+
+    def __str__(self):
+        return self.name
+
+class DefaultBenchmark(Benchmark):
+    def ref(self, isa, os): pass
+    def test(self, isa, os): pass
+    def train(self, isa, os): pass
+
+class MinneDefaultBenchmark(DefaultBenchmark):
+    def smred(self, isa, os): pass
+    def mdred(self, isa, os): pass
+    def lgred(self, isa, os): pass
+
+##
+# Integer Benchmarks.
+##
+
+class perlbench(DefaultBenchmark):
+    name = 'perlbench'
+    number = 400
+
+class perlbench_checkspam(perlbench):
+    def ref(self, isa, os):
+        self.args = ['-I./lib', 'checkspam.pl', '2500', '5', '25', '11', '150',
+                     '1', '1', '1', '1']
+
+class bzip2(DefaultBenchmark):
+    name = 'bzip2'
+    number = 401
+
+class bzip2_source(bzip2):
+    def ref(self, isa, os):
+        self.args = ['input.source', '280']
+
+class gcc(DefaultBenchmark):
+    name = 'gcc'
+    number = 403
+
+class gcc_166(gcc):
+    def ref(self, isa, os):
+        self.args = ['166.i', '-o', '166.s']
+
+class mcf(DefaultBenchmark):
+    name = 'mcf'
+    number = 429
+    args = ['inp.in']
+
+class gobmk(DefaultBenchmark):
+    name = 'gobmk'
+    number = 445
+
+class gobmk_13x13(gobmk):
+    infile = '13x13.tst'
+    def ref(self, isa, os):
+        self.args = ['--quiet', '--mode', 'gtp']
+
+class hmmer(DefaultBenchmark):
+    name = 'hmmer'
+    number = 456
+
+class hmmer_nph3(hmmer):
+    def ref(self, isa, os):
+        self.args = ['nph3.hmm', 'swiss41']
+
+class sjeng(DefaultBenchmark):
+    name = 'sjeng'
+    number = 458
+    def ref(self, isa, os):
+        self.args = ['ref.txt']
+
+class libquantum(DefaultBenchmark):
+    name = 'libquantum'
+    number = 462
+    def ref(self, isa, os):
+        self.args = ['1397', '8']
+
+class h264ref(DefaultBenchmark):
+    name = 'h264ref'
+    number = 464
+
+class h264ref_fbase(h264ref):
+    def ref(self, isa, os):
+        self.args = ['-d', 'foreman_ref_encoder_baseline.cfg']
+
+class omnetpp(DefaultBenchmark):
+    name = 'omnetpp'
+    number = 471
+    args = ['omnetpp.ini']
+
+class astar(DefaultBenchmark):
+    name = 'astar'
+    number = 473
+
+class astar_biglakes(astar):
+    def ref(self, isa, os):
+        self.args = ['BigLakes2048.cfg']
+
+class xalancbmk(DefaultBenchmark):
+    name = 'xalancbmk'
+    number = 483
+    binary = 'Xalan'
+    def ref(self, isa, os):
+        self.args = ['-v', 't5.xml', 'xalanc.xsl']
+
+
+##
+# Floating Point Benchmarks.
+##
+
+class bwaves(DefaultBenchmark):
+    name = 'bwaves'
+    number = 410
+
+class gamess(DefaultBenchmark):
+    name = 'gamess'
+    number = 416
+
+class gamess_cytosine(gamess):
+    infile = 'cytosine.2.config'
+
+class milc(DefaultBenchmark):
+    name = 'milc'
+    number = 433
+    infile = 'su3imp.in'
+
+class zeusmp(DefaultBenchmark):
+    name = 'zeusmp'
+    number = 434
+
+class gromacs(DefaultBenchmark):
+    name = 'gromacs'
+    number = 435
+    def ref(self, isa, os):
+        self.args = ['-silent', '-deffnm', 'gromacs', '-nice', '0']
+
+class cactusADM(DefaultBenchmark):
+    name = 'cactusADM'
+    number = 436
+    def ref(self, isa, os):
+        self.args = ['benchADM.par']
+
+class leslie3d(DefaultBenchmark):
+    name = 'leslie3d'
+    number = 437
+
+class namd(DefaultBenchmark):
+    name = 'namd'
+    number = 444
+    def ref(self, isa, os):
+        self.args = ['--input', 'namd.input', '--iterations', '38', '--output',
+                     'namd.out']
+
+class dealII(DefaultBenchmark):
+    name = 'dealII'
+    number = 447
+    def ref(self, isa, os):
+        self.args = ['23']
+
+class soplex(DefaultBenchmark):
+    name = 'soplex'
+    number = 450
+
+class soplex_pds50(soplex):
+    def ref(self, isa, os):
+        self.args = ['-s1', '-e', '-m45000', 'pds-50.mps']
+
+class povray(DefaultBenchmark):
+    name = 'povray'
+    number = 453
+    def ref(self, isa, os):
+        self.args = ['SPEC-benchmark-ref.ini']
+
+class calculix(DefaultBenchmark):
+    name = 'calculix'
+    number = 454
+    def ref(self, isa, os):
+        self.args = ['-i', 'hyperviscoplastic']
+
+class GemsFDTD(DefaultBenchmark):
+    name = 'GemsFDTD'
+    number = 459
+
+class tonto(DefaultBenchmark):
+    name = 'tonto'
+    number = 465
+
+class lbm(DefaultBenchmark):
+    name = 'lbm'
+    number = 470
+    def ref(self, isa, os):
+        self.args = ['3000', 'reference.dat', '0', '0', '100_100_130_ldc.of']
+
+class wrf(DefaultBenchmark):
+    name = 'wrf'
+    number = 481
+
+class sphinx3(DefaultBenchmark):
+    name = 'sphinx3'
+    number = 482
+    binary = 'sphinx_livepretend'
+    def ref(self, isa, os):
+        self.args = ['ctlfile', '.', 'args.an4']
diff -r 2492d7ccda7e -r 33141d198579 configs/example/errors.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/example/errors.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,30 @@
+def splitCPUErrorOptions(filename):
+    lines = (line.rstrip('\n') for line in open(filename))
+    itern=0
+    cpuEList=[]
+    elist=[]
+    for item in lines:
+        if item.isdigit():
+            if itern != 0:
+                cpuEList.append(elist)
+            elist=[]
+            if int(itern)==int(item):
+                itern=itern+1
+        else:
+            item=item.split(',')
+            elist.append(item)
+    cpuEList.append(elist)
+    return cpuEList
+
+def splitTokens(eList):
+	flag=False
+	val=0
+	if len(eList) == 2:
+		val=(eList[1])
+		flag=True
+	return flag, val
+
+
+
+
+
diff -r 2492d7ccda7e -r 33141d198579 configs/example/helper_se.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/configs/example/helper_se.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,410 @@
+# Copyright (c) 2012 ARM Limited
+# All rights reserved.
+#
+# The license below extends only to copyright in the software and shall
+# not be construed as granting a license to any other intellectual
+# property including but not limited to intellectual property relating
+# to a hardware implementation of the functionality of the software
+# licensed hereunder.  You may use the software subject to the license
+# terms below provided that you ensure that this notice is replicated
+# unmodified and in its entirety in all distributions of the software,
+# modified or unmodified, in source code or in binary form.
+#
+# Copyright (c) 2006-2008 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Steve Reinhardt
+
+# Simple test script
+#
+# "m5 test.py"
+
+import tempfile
+import optparse
+import shutil
+import sys
+import os
+import os.path
+
+import m5
+from m5.defines import buildEnv
+from m5.objects import *
+from m5.util import addToPath, fatal
+
+addToPath('../common')
+addToPath('../ruby')
+addToPath('../topologies')
+import Options
+import Ruby
+import Simulation
+import HelperCacheConfig
+import errors
+import MemConfig
+from Caches import *
+import cpu2000
+import cpu2006
+
+def get_processes(options):
+    """Interprets provided options and returns a list of processes"""
+
+    multiprocesses = []
+    inputs = []
+    outputs = []
+    errouts = []
+    pargs = []
+
+    workloads = options.cmd.split(';')
+    if options.input != "":
+        inputs = options.input.split(';')
+    if options.output != "":
+        outputs = options.output.split(';')
+    if options.errout != "":
+        errouts = options.errout.split(';')
+    if options.options != "":
+        pargs = options.options.split(';')
+
+    idx = 0
+    for wrkld in workloads:
+        process = LiveProcess()
+        process.executable = wrkld
+        process.cwd = os.getcwd()
+
+        if len(pargs) > idx:
+            process.cmd = [wrkld] + pargs[idx].split()
+        else:
+            process.cmd = [wrkld]
+
+        if len(inputs) > idx:
+            process.input = inputs[idx]
+        if len(outputs) > idx:
+            process.output = outputs[idx]
+        if len(errouts) > idx:
+            process.errout = errouts[idx]
+
+        multiprocesses.append(process)
+        idx += 1
+
+    if options.smt:
+        assert(options.cpu_type == "detailed" or options.cpu_type == "inorder")
+        return multiprocesses, idx
+    else:
+        return multiprocesses, 1
+
+parser = optparse.OptionParser()
+Options.addCommonOptions(parser)
+Options.addSEOptions(parser)
+parser.add_option('--suite', choices=['cpu2000', 'cpu2006'], default='cpu2006',
+                  help="Choose a benchmark suite to execute from")
+Options.addErrorOptions(parser)
+parser.add_option('--pause-at-max-insts', action='store_true', default=False,
+                  help="Pause cores when they reach their maximum instruction count")
+parser.add_option('--pause-after-warmup', action='store_true', default=False,
+                  help="Pause cores when they finish their warmup instructions")
+parser.add_option('--run-in-checkpoint-dir', action='store_true', default=False,
+                  help="Run the benchmarks within the checkpoint directory")
+parser.add_option('--run-in-tmp-dir', action='store_true', default=True,
+                  help="Run the benchmarks within a temporary directory")
+parser.add_option('--copy-checkpoint-dir', action='store_true', default=False,
+                  help="Copy the checkpoint directory to temporary space before running")
+parser.add_option("--repairDelay", type="int", default=0)
+parser.add_option("--robCount", type="int", default=0)
+
+if '--ruby' in sys.argv:
+    Ruby.define_options(parser)
+
+(options, args) = parser.parse_args()
+
+if args:
+    print "Error: script doesn't take any positional arguments"
+    sys.exit(1)
+
+multiprocesses = []
+numThreads = 1
+
+
+removeRunDir = None
+if options.copy_checkpoint_dir:
+    import fileinput, re, stat
+    tmpdir = tempfile.mkdtemp(prefix="/local/scratch/js2072/tempDir")
+    removeRunDir = tmpdir
+    if not os.path.isdir(tmpdir):
+        fatal("Can't find temporary directory to run within")
+    if options.checkpoint_dir.endswith('.tar.bz2'):
+        import tarfile
+        tf = tarfile.open(options.checkpoint_dir)
+        tf.extractall(tmpdir)
+        tf.close()
+        tmpdir = os.path.join(tmpdir, os.path.basename(os.path.normpath(options.checkpoint_dir))[:-8])
+    else:
+        cpu2006.copyfiles(options.checkpoint_dir, tmpdir)
+    options.checkpoint_dir = tmpdir
+#    print "Using temporary directory", tmpdir
+    pattern = re.compile(r'/home/js2072/repo/checkpoints/\d+c/[\w-]+')
+    os.chmod(tmpdir, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
+    for root, dirs, files in os.walk(tmpdir):
+        for entry in dirs:
+            os.chmod(os.path.join(root, entry), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
+        for entry in files:
+            fullpath = os.path.join(root, entry)
+            os.chmod(fullpath, stat.S_IRUSR | stat.S_IWUSR)
+            if entry == 'm5.cpt':
+                for line in fileinput.input(fullpath, inplace=1):
+                    line = re.sub(pattern, tmpdir, line.rstrip())
+                    # print line
+    if not options.run_in_tmp_dir:
+        options.run_in_checkpoint_dir = True
+
+
+if options.run_in_checkpoint_dir:
+    if options.checkpoint_dir:
+        rundir = options.checkpoint_dir
+    elif m5.options.outdir:
+        rundir = m5.options.outdir
+    else:
+        fatal("Must specify checkpoint-dir or sim outdir with run-in-checkpoint-dir")
+elif options.run_in_tmp_dir:
+    rundir = tempfile.mkdtemp()
+    if not os.path.isdir(rundir):
+        fatal("Can't find temporary directory to run within")
+    removeRunDir = rundir
+elif m5.options.outdir:
+    rundir = m5.options.outdir
+else:
+    fatal("Can't find a directory to run in")
+
+if options.bench:
+    apps = options.bench.split("-")
+    if len(apps) != options.num_cpus:
+        print "number of benchmarks not equal to set num_cpus!"
+        sys.exit(1)
+
+    for app in apps:
+        try:
+            if buildEnv['TARGET_ISA'] == 'alpha':
+                exec("workload = %s('alpha', 'tru64', '%s')" % (
+                        app, options.spec_input))
+            elif buildEnv['TARGET_ISA'] == 'arm':
+                exec("workload = %s.%s('arm_%s', 'linux', '%s')" % (
+                       options.suite, app, options.arm_iset, options.spec_input))
+            else:
+                exec("workload = %s(buildEnv['TARGET_ISA', 'linux', '%s')" % (
+                        app, options.spec_input))
+            if options.copy_checkpoint_dir:
+                appdir = rundir
+                copyfiles = False
+            else:
+                appdir = tempfile.mkdtemp(dir=rundir)
+                copyfiles = True
+            multiprocesses.append(workload.makeLiveProcess(cwd=appdir, copy=copyfiles))
+        except Exception as e:
+            print >>sys.stderr, e
+            # print >>sys.stderr, "Unable to find workload for %s: %s" % (buildEnv['TARGET_ISA'], app)
+            sys.exit(1)
+elif options.cmd:
+    multiprocesses, numThreads = get_processes(options)
+else:
+    print >> sys.stderr, "No workload specified. Exiting!\n"
+    sys.exit(1)
+
+
+(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+CPUClass.numThreads = numThreads
+
+# print CPUClass
+# print FutureClass
+
+MemClass = Simulation.setMemClass(options)
+
+# Check -- do not allow SMT with multiple CPUs
+if options.smt and options.num_cpus > 1:
+    fatal("You cannot use SMT with multiple CPUs!")
+
+np = options.num_cpus
+
+cpucls=[]
+for i in xrange(np):
+    tCpu=CPUClass(cpu_id=i)
+    cpucls.append(tCpu)
+#print CPUClass
+
+#if not options.warmup_insts:
+#   print "** Adding Helper CPU **"
+#   if CPUClass!=AtomicSimpleCPU:
+#       tCpu=TimingHelperCPU(cpu_id=np+1)
+#   else:
+#       tCpu=TimingHelperCPU(switched_out=True,cpu_id=np+1)
+#   tCpu.createInterruptController()
+#   if options.smt:
+#       tCpu.workload = multiprocesses
+#   else:
+#       tCpu.workload = multiprocesses[0]
+#   if options.simpoint_profile:
+#       tCpu.simpoint_profile = True
+#       tCpu.simpoint_interval = options.simpoint_interval
+#
+#   cpucls.append(tCpu)
+#
+##print "Size of cpu list is "+str(len(cpucls))
+if options.error_file and not options.checkpoint_restore and not options.warmup_insts:
+#    print "Error File found helper CPU being added in"
+    process = LiveProcess()
+    wrkld="../helloworld/simple"
+    process.executable =wrkld
+    process.cmd = [wrkld]
+    process.cwd = os.getcwd()
+    if not FutureClass:
+        if CPUClass!=AtomicSimpleCPU:
+#            print "Adding helper CPU"
+            tCpu=TimingHelperCPU(cpu_id=np+1)
+        else:
+            tCpu=TimingHelperCPU(cpu_id=np+1)
+        tCpu.createInterruptController()
+        if options.simpoint_profile:
+            tCpu.simpoint_profile = True
+            tCpu.simpoint_interval = options.simpoint_interval
+        tCpu.workload=multiprocesses[0]
+        cpucls.append(tCpu)
+    else:
+        if CPUClass == AtomicSimpleCPU:
+            tCpu=TimingHelperCPU(switched_out=True,cpu_id=np+1)
+#            tCpu=AtomicSimpleCPU(cpu_id=np+1)
+        else:
+            tCpu=TimingHelperCPU(switched_out=True,cpu_id=np+1)
+        tCpu.workload=process
+        cpucls.append(tCpu)
+
+system = System(cpu = cpucls,
+                physmem = MemClass(range=AddrRange(options.mem_size)),
+                mem_mode = test_mem_mode,
+                clk_domain = SrcClockDomain(clock = options.sys_clock),
+                cache_line_size = options.cacheline_size)
+# Create a separate clock domain for the CPUs
+system.cpu_clk_domain = SrcClockDomain(clock = options.cpu_clock)
+
+# All cpus belong to a common cpu_clk_domain, therefore running at a common
+# frequency.
+for cpu in system.cpu:
+    cpu.clk_domain = system.cpu_clk_domain
+
+
+
+# Sanity check
+if options.fastmem:
+    if CPUClass != AtomicSimpleCPU:
+        fatal("Fastmem can only be used with atomic CPU!")
+    if (options.caches or options.l2cache):
+        fatal("You cannot use fastmem in combination with caches!")
+
+if options.simpoint_profile:
+    if not options.fastmem:
+        # Atomic CPU checked with fastmem option already
+        fatal("SimPoint generation should be done with atomic cpu and fastmem")
+    if np > 1:
+        fatal("SimPoint generation not supported with more than one CPUs")
+
+if not options.warmup_insts:
+    if options.error_file:
+
+        errorList=errors.splitCPUErrorOptions(options.error_file)
+        if len(errorList) < np:
+            print "Number of CPUs dont match error list"
+            sys.exit(1)
+        else:
+            print "Error File available asking all cpus to go into error mode"
+            for i in xrange(np):
+                system.cpu[i].efetch,system.cpu[i].efetchValue  = errors.splitTokens(errorList[i][0])
+                system.cpu[i].efetchZ,system.cpu[i].efetchZValue  = errors.splitTokens(errorList[i][1])
+                system.cpu[i].eSB,system.cpu[i].eSBValue   = errors.splitTokens(errorList[i][2])
+                system.cpu[i].eIQ,system.cpu[i].eIQValue    = errors.splitTokens(errorList[i][3])
+                system.cpu[i].eRM,system.cpu[i].eRMValue     = errors.splitTokens(errorList[i][4])
+                system.cpu[i].ePR,system.cpu[i].ePRValue      = errors.splitTokens(errorList[i][5])
+                system.cpu[i].eROB,system.cpu[i].eROBValue      = errors.splitTokens(errorList[i][6])
+                system.cpu[i].eLQ,system.cpu[i].eLQValue      = errors.splitTokens(errorList[i][7])
+                system.cpu[i].eSQ,system.cpu[i].eSQValue      = errors.splitTokens(errorList[i][8])
+                system.cpu[i].eFU,system.cpu[i].eFUValue       = errors.splitTokens(errorList[i][9])
+
+for i in xrange(np):
+    if options.smt:
+        system.cpu[i].workload = multiprocesses
+    elif len(multiprocesses) == 1:
+        system.cpu[i].workload = multiprocesses[0]
+    else:
+        system.cpu[i].workload = multiprocesses[i]
+
+    if options.fastmem:
+        system.cpu[i].fastmem = True
+
+    if options.simpoint_profile:
+        system.cpu[i].simpoint_profile = True
+        system.cpu[i].simpoint_interval = options.simpoint_interval
+
+    if options.checker:
+        system.cpu[i].addCheckerCpu()
+
+    system.cpu[i].createThreads()
+
+if options.ruby:
+    if not (options.cpu_type == "detailed" or options.cpu_type == "timing"):
+        print >> sys.stderr, "Ruby requires TimingSimpleCPU or O3CPU!!"
+        sys.exit(1)
+
+    # Set the option for physmem so that it is not allocated any space
+    system.physmem = MemClass(range=AddrRange(options.mem_size),
+                              null = True)
+
+    options.use_map = True
+    Ruby.create_system(options, system)
+    assert(options.num_cpus == len(system.ruby._cpu_ruby_ports))
+
+    for i in xrange(np):
+        ruby_port = system.ruby._cpu_ruby_ports[i]
+
+        # Create the interrupt controller and connect its ports to Ruby
+        # Note that the interrupt controller is always present but only
+        # in x86 does it have message ports that need to be connected
+        system.cpu[i].createInterruptController()
+
+        # Connect the cpu's cache ports to Ruby
+        system.cpu[i].icache_port = ruby_port.slave
+        system.cpu[i].dcache_port = ruby_port.slave
+        if buildEnv['TARGET_ISA'] == 'x86':
+            system.cpu[i].interrupts.pio = ruby_port.master
+            system.cpu[i].interrupts.int_master = ruby_port.slave
+            system.cpu[i].interrupts.int_slave = ruby_port.master
+            system.cpu[i].itb.walker.port = ruby_port.slave
+            system.cpu[i].dtb.walker.port = ruby_port.slave
+else:
+    system.membus = CoherentBus()
+    system.system_port = system.membus.slave
+    system.physmem.port = system.membus.master
+    HelperCacheConfig.config_cache(options, system)
+
+root = Root(full_system = False, system = system)
+Simulation.run(options, root, system, FutureClass)
+
+if removeRunDir is not None:
+    print "Removing directory"
+    shutil.rmtree(removeRunDir)
diff -r 2492d7ccda7e -r 33141d198579 configs/example/se.py
--- a/configs/example/se.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/configs/example/se.py	Wed Aug 05 11:39:08 2015 +0100
@@ -42,8 +42,12 @@
 #
 # "m5 test.py"
 
+import tempfile
 import optparse
+import shutil
 import sys
+import os
+import os.path
 
 import m5
 from m5.defines import buildEnv
@@ -56,10 +60,12 @@
 
 import Options
 import Ruby
-import Simulation
+import cpSimulation
 import CacheConfig
+import MemConfig
 from Caches import *
-from cpu2000 import *
+import cpu2000
+import cpu2006
 
 def get_processes(options):
     """Interprets provided options and returns a list of processes"""
@@ -84,6 +90,7 @@
     for wrkld in workloads:
         process = LiveProcess()
         process.executable = wrkld
+        process.cwd = os.getcwd()
 
         if len(pargs) > idx:
             process.cmd = [wrkld] + pargs[idx].split()
@@ -110,6 +117,21 @@
 parser = optparse.OptionParser()
 Options.addCommonOptions(parser)
 Options.addSEOptions(parser)
+parser.add_option('--suite', choices=['cpu2000', 'cpu2006'], default='cpu2006',
+                  help="Choose a benchmark suite to execute from")
+Options.addErrorOptions(parser)
+parser.add_option('--pause-at-max-insts', action='store_true', default=False,
+                  help="Pause cores when they reach their maximum instruction count")
+parser.add_option('--pause-after-warmup', action='store_true', default=False,
+                  help="Pause cores when they finish their warmup instructions")
+parser.add_option('--run-in-checkpoint-dir', action='store_true', default=False,
+                  help="Run the benchmarks within the checkpoint directory")
+parser.add_option('--run-in-tmp-dir', action='store_true', default=True,
+                  help="Run the benchmarks within a temporary directory")
+parser.add_option('--copy-checkpoint-dir', action='store_true', default=False,
+                  help="Copy the checkpoint directory to temporary space before running")
+parser.add_option("--repairDelay", type="int", default=0)
+parser.add_option("--robCount", type="int", default=0)
 
 if '--ruby' in sys.argv:
     Ruby.define_options(parser)
@@ -123,6 +145,57 @@
 multiprocesses = []
 numThreads = 1
 
+
+removeRunDir = None
+if options.copy_checkpoint_dir:
+    import fileinput, re, stat
+    tmpdir = tempfile.mkdtemp(prefix="/local/scratch/js2072/tempDir")
+    removeRunDir = tmpdir
+    if not os.path.isdir(tmpdir):
+        fatal("Can't find temporary directory to run within")
+    if options.checkpoint_dir.endswith('.tar.bz2'):
+        import tarfile
+        tf = tarfile.open(options.checkpoint_dir)
+        tf.extractall(tmpdir)
+        tf.close()
+        tmpdir = os.path.join(tmpdir, os.path.basename(os.path.normpath(options.checkpoint_dir))[:-8])
+    else:
+        cpu2006.copyfiles(options.checkpoint_dir, tmpdir)
+    options.checkpoint_dir = tmpdir
+#    print "Using temporary directory", tmpdir
+    pattern = re.compile(r'/home/js2072/repo/checkpoints/\d+c/[\w-]+')
+    os.chmod(tmpdir, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
+    for root, dirs, files in os.walk(tmpdir):
+        for entry in dirs:
+            os.chmod(os.path.join(root, entry), stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
+        for entry in files:
+            fullpath = os.path.join(root, entry)
+            os.chmod(fullpath, stat.S_IRUSR | stat.S_IWUSR)
+            if entry == 'm5.cpt':
+                for line in fileinput.input(fullpath, inplace=1):
+                    line = re.sub(pattern, tmpdir, line.rstrip())
+                    print line
+    if not options.run_in_tmp_dir:
+        options.run_in_checkpoint_dir = True
+
+
+if options.run_in_checkpoint_dir:
+    if options.checkpoint_dir:
+        rundir = options.checkpoint_dir
+    elif m5.options.outdir:
+        rundir = m5.options.outdir
+    else:
+        fatal("Must specify checkpoint-dir or sim outdir with run-in-checkpoint-dir")
+elif options.run_in_tmp_dir:
+    rundir = tempfile.mkdtemp()
+    if not os.path.isdir(rundir):
+        fatal("Can't find temporary directory to run within")
+    removeRunDir = rundir
+elif m5.options.outdir:
+    rundir = m5.options.outdir
+else:
+    fatal("Can't find a directory to run in")
+
 if options.bench:
     apps = options.bench.split("-")
     if len(apps) != options.num_cpus:
@@ -132,11 +205,23 @@
     for app in apps:
         try:
             if buildEnv['TARGET_ISA'] == 'alpha':
-                exec("workload = %s('alpha', 'tru64', 'ref')" % app)
+                exec("workload = %s('alpha', 'tru64', '%s')" % (
+                        app, options.spec_input))
+            elif buildEnv['TARGET_ISA'] == 'arm':
+                exec("workload = %s.%s('arm_%s', 'linux', '%s')" % (
+                       options.suite, app, options.arm_iset, options.spec_input))
             else:
-                exec("workload = %s(buildEnv['TARGET_ISA'], 'linux', 'ref')" % app)
-            multiprocesses.append(workload.makeLiveProcess())
-        except:
+                exec("workload = %s(buildEnv['TARGET_ISA', 'linux', '%s')" % (
+                        app, options.spec_input))
+            if options.copy_checkpoint_dir:
+                appdir = rundir
+                copyfiles = False
+            else:
+                appdir = tempfile.mkdtemp(dir=rundir)
+                copyfiles = True
+            multiprocesses.append(workload.makeLiveProcess(cwd=appdir, copy=copyfiles))
+        except Exception as e:
+            print >>sys.stderr, e
             print >>sys.stderr, "Unable to find workload for %s: %s" % (buildEnv['TARGET_ISA'], app)
             sys.exit(1)
 elif options.cmd:
@@ -146,10 +231,10 @@
     sys.exit(1)
 
 
-(CPUClass, test_mem_mode, FutureClass) = Simulation.setCPUClass(options)
+(CPUClass, test_mem_mode, FutureClass) = cpSimulation.setCPUClass(options)
 CPUClass.numThreads = numThreads
 
-MemClass = Simulation.setMemClass(options)
+MemClass = cpSimulation.setMemClass(options)
 
 # Check -- do not allow SMT with multiple CPUs
 if options.smt and options.num_cpus > 1:
@@ -210,7 +295,8 @@
         sys.exit(1)
 
     # Set the option for physmem so that it is not allocated any space
-    system.physmem.null = True
+    system.physmem = MemClass(range=AddrRange(options.mem_size),
+                              null = True)
 
     options.use_map = True
     Ruby.create_system(options, system)
@@ -240,4 +326,8 @@
     CacheConfig.config_cache(options, system)
 
 root = Root(full_system = False, system = system)
-Simulation.run(options, root, system, FutureClass)
+cpSimulation.run(options, root, system, FutureClass)
+
+if removeRunDir is not None:
+    print "Removing directory"
+    shutil.rmtree(removeRunDir)
diff -r 2492d7ccda7e -r 33141d198579 src/arch/arm/SConscript
--- a/src/arch/arm/SConscript	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/arch/arm/SConscript	Wed Aug 05 11:39:08 2015 +0100
@@ -81,6 +81,7 @@
     DebugFlag('Decoder', "Instructions returned by the predecoder")
     DebugFlag('Faults', "Trace Exceptions, interrupts, svc/swi")
     DebugFlag('TLBVerbose')
+    DebugFlag('TLBCheck')
 
     # Add in files generated by the ISA description.
     isa_desc_files = env.ISADesc('isa/main.isa')
diff -r 2492d7ccda7e -r 33141d198579 src/arch/arm/isa.cc
--- a/src/arch/arm/isa.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/arch/arm/isa.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -271,7 +271,8 @@
                 miscRegName[misc_reg]);
         break;
       case MISCREG_CPSR_Q:
-        panic("shouldn't be reading this register seperately\n");
+       return  readMiscRegNoEffect(MISCREG_CPSR) & ~CpsrMaskQ;
+//        panic("shouldn't be reading this register seperately\n");
       case MISCREG_FPSCR_QC:
         return readMiscRegNoEffect(MISCREG_FPSCR) & ~FpscrQcMask;
       case MISCREG_FPSCR_EXC:
diff -r 2492d7ccda7e -r 33141d198579 src/arch/arm/types.hh
--- a/src/arch/arm/types.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/arch/arm/types.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -334,7 +334,6 @@
             Base::advance();
             flags = nextFlags;
             npc(pc() + (thumb() ? 2 : 4));
-
             if (_nextItstate) {
                 _itstate = _nextItstate;
                 _nextItstate = 0;
diff -r 2492d7ccda7e -r 33141d198579 src/arch/generic/types.hh
--- a/src/arch/generic/types.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/arch/generic/types.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -136,10 +136,12 @@
   public:
 
     Addr pc() const { return _pc; }
-    void pc(Addr val) { _pc = val; }
+    void pc(Addr val) {
+        _pc = val; }
 
     Addr npc() const { return _npc; }
-    void npc(Addr val) { _npc = val; }
+    void npc(Addr val) {
+        _npc = val; }
 
     void
     set(Addr val)
diff -r 2492d7ccda7e -r 33141d198579 src/base/refcnt.hh
--- a/src/base/refcnt.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/base/refcnt.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -31,6 +31,7 @@
 #ifndef __BASE_REFCNT_HH__
 #define __BASE_REFCNT_HH__
 
+#include<iostream>
 /**
  * @file base/refcnt.hh
  *
@@ -82,9 +83,19 @@
     /// Increment the reference count
     void incref() { ++count; }
 
+    int getCount(){
+        return count;
+    }
+
     /// Decrement the reference count and destroy the object if all
     /// references are gone.
-    void decref() { if (--count <= 0) delete this; }
+    void decref() { 
+        if (--count <= 0){
+//            std::cout<<"Freed pointer: "<<this<<std::endl;
+            delete this; 
+
+        }
+    }
 };
 
 /**
@@ -132,8 +143,18 @@
     void
     del()
     {
-        if (data)
+        bool check;
+        if (data){
+            check=false;
+            if(data->getCount()<=1){
+                check=true;
+            }
             data->decref();
+            if(check){
+//                std::cout<<"Aaj me roya!!"<<std::endl;
+                data=0;
+            }
+        }
     }
 
     /**
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/BaseCPU.py
--- a/src/cpu/BaseCPU.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/BaseCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -95,6 +95,7 @@
     @classmethod
     def export_methods(cls, code):
         code('''
+    void pause(bool pause);
     void switchOut();
     void takeOverFrom(BaseCPU *cpu);
     bool switchedOut();
@@ -146,6 +147,30 @@
 
     workload = VectorParam.Process([], "processes to run")
 
+    efetch       = Param.Bool(False,"error list to be used per cpu")
+    efetchValue  =Param.String("","Fetch error map")
+    efetchZ       = Param.Bool(False,"error list to be used per cpu")
+    efetchZValue  =Param.String("","Fetch error map")
+    eSB          =Param.Bool(False,"error list to be used per cpu")
+    eSBValue     =Param.String("","Scoreboard error map")
+    eIQ          =Param.Bool(False,"error list to be used per cpu")
+    eIQValue     =Param.String("","Instruction queue error map")
+    eRM          =Param.Bool(False,"error list to be used per cpu")
+    eRMValue     =Param.String("","Rename Map error map")
+    ePR          =Param.Bool(False,"error list to be used per cpu")
+    ePRValue     =Param.String("","Physical Register error map")
+    eROB         =Param.Bool(False,"error list to be used per cpu")
+    eROBValue    =Param.String("","Reorder Buffer error map")
+    eLQ         =Param.Bool(False,"error list to be used per cpu")
+    eLQValue    =Param.String("","Load store queue error map")
+    eSQ         =Param.Bool(False,"error list to be used per cpu")
+    eSQValue    =Param.String("","Load store queue error map")
+    eFU          =Param.Bool(False,"error list to be used per cpu")
+    eFUValue     =Param.String("","Functional unit error map")
+
+
+
+
     if buildEnv['TARGET_ISA'] == 'sparc':
         dtb = Param.SparcTLB(SparcTLB(), "Data TLB")
         itb = Param.SparcTLB(SparcTLB(), "Instruction TLB")
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/PortManager.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/PortManager.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,580 @@
+/*
+ * Copyright (c) 2011-2012 University of Cambridge
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2004-2006 The Regents of The University of Michigan
+ * Copyright (c) 2011 Regents of the University of California
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Jyothish Soman
+ */
+#include <cstdlib>
+#include"PortManager.hh"
+
+CommPack::CommPack(int cpuId) : cpuid(cpuId) {
+    numSrcRegs = 0;
+    numDestRegs=0;
+    addedSrcCount = 0;
+    addedDestCount=0;
+}
+
+CommPack::CommPack(StaticInstPtr instr, int cpuId) : cpuid(cpuId) {
+    curStaticInst = instr;
+    numSrcRegs = 0;
+    numDestRegs=0;
+    setNumSrcRegs(instr->numSrcRegs());
+    setNumDestRegs(instr->numDestRegs());
+    addedSrcCount = 0;
+    addedDestCount=0;
+}
+
+CommPack::~CommPack() {
+    /*      free(srcData);
+            free(dType);
+            free(destType);
+     */
+    DPRINTF(Squasher, "Deleting commdata %i\n", this);
+    process = NULL;
+    curStaticInst = NULL;
+    dtlb = NULL;
+}
+
+void CommPack::setPhase(dataPhase ph) {
+    dataPh = ph;
+}
+
+ThreadID CommPack::getTID() {
+    return tid;
+}
+
+void CommPack::setTID(ThreadID td) {
+    tid = td;
+}
+
+dataPhase CommPack::getPhase() {
+    return dataPh;
+}
+
+void CommPack::setProcess(Process * prs) {
+    process = prs;
+}
+
+void CommPack::setInstPtr(StaticInstPtr ptr) {
+    curStaticInst = ptr;
+}
+
+Process* CommPack::getProcess() {
+    return process;
+}
+
+void CommPack::setDTLB(TheISA::TLB * dtlb_cpu) {
+    dtlb = dtlb_cpu;
+}
+
+TheISA::TLB* CommPack::getDTLB() {
+    return dtlb;
+}
+
+void CommPack::setITLB(TheISA::TLB * itlb_cpu) {
+    itlb = itlb_cpu;
+}
+
+TheISA::TLB* CommPack::getITLB() {
+    return itlb;
+}
+
+int CommPack::getNumSrcRegs() {
+    return addedSrcCount;
+}
+
+void CommPack::setNumSrcRegs(int nRegs) {
+    int tRegs = nRegs + 5;
+    addedSrcCount = 0;
+    if (numSrcRegs > 0) {
+        if (numSrcRegs < tRegs) {
+            srcData = (transferData*) realloc(srcData, sizeof (transferData) * tRegs);
+            sdType = (dataChar*) realloc(sdType, sizeof (transferData) * tRegs);
+        }
+    } else {
+        srcData = (transferData*) calloc(tRegs, sizeof (transferData));
+        sdType = (dataChar*) calloc(tRegs, sizeof (transferData));
+    }
+    this->numSrcRegs = nRegs;
+}
+
+int CommPack::getNumDestRegs() {
+    return addedDestCount;
+}
+
+void CommPack::setNumDestRegs(int nRegs) {
+    int tRegs = nRegs + 5;
+    addedDestCount = 0;
+    if (numDestRegs > 0) {
+        if (numDestRegs < tRegs) {
+            destData = (transferData*) realloc(destData, sizeof (transferData) * tRegs);
+            ddType = (dataChar*) realloc(ddType, sizeof (transferData) * tRegs);
+        }
+    } else {
+        destData = (transferData*) calloc(tRegs, sizeof (transferData));
+        ddType = (dataChar*) calloc(tRegs, sizeof (transferData));
+    }
+    this->numDestRegs = nRegs;
+}
+
+
+transferData CommPack::getSrcData(int id) {
+    if (id >= numSrcRegs) {
+        exit(-1);
+    }
+    return srcData[id];
+}
+
+void CommPack::setSrcData(int64_t data, int index) {
+    if (numSrcRegs > addedSrcCount) {
+        srcData[addedSrcCount].data.i = data;
+        srcData[addedSrcCount].index = index;
+        addedSrcCount++;
+    } else {
+        printf("Error occured Src%d \n", addedSrcCount);
+        exit(-1);
+    }
+}
+
+void CommPack::setSrcData(float data, int index) {
+    if (numSrcRegs > addedSrcCount) {
+        srcData[addedSrcCount].data.f = data;
+        srcData[addedSrcCount].index = index;
+        addedSrcCount++;
+    } else {
+        printf("Error occured Src %d \n", addedSrcCount);
+        exit(-1);
+    }
+}
+
+void CommPack::setSrcData(uint64_t data, int index) {
+    if (numSrcRegs > addedSrcCount) {
+        srcData[addedSrcCount].data.ui = data;
+        srcData[addedSrcCount].index = index;
+        addedSrcCount++;
+    } else {
+        printf("Error occured Src %d \n", addedSrcCount);
+        exit(-1);
+    }
+}
+
+transferData CommPack::getDestData(int id) {
+    if (id >= numDestRegs) {
+        exit(-1);
+    }
+    return destData[id];
+}
+
+void CommPack::setDestData(int64_t data, int index) {
+    if (numDestRegs > addedDestCount) {
+        destData[addedDestCount].data.i = data;
+        destData[addedDestCount].index = index;
+        addedDestCount++;
+    } else {
+        printf("Error occured Dest%d \n", addedDestCount);
+        exit(-1);
+    }
+}
+
+void CommPack::setDestData(float data, int index) {
+    if (numDestRegs > addedDestCount) {
+        destData[addedDestCount].data.f = data;
+        destData[addedDestCount].index = index;
+        addedDestCount++;
+    } else {
+        printf("Error occured Dest%d \n", addedDestCount);
+        exit(-1);
+    }
+}
+
+void CommPack::setDestData(uint64_t data, int index) {
+    if (numDestRegs > addedDestCount) {
+        destData[addedDestCount].data.ui = data;
+        destData[addedDestCount].index = index;
+        addedDestCount++;
+    } else {
+        printf("Error occured Dest %d \n", addedDestCount);
+        exit(-1);
+    }
+}
+
+void CommPack::modifyDestData(int64_t data, int index) {
+    if (index < addedDestCount) {
+        destData[index].data.i = data;
+    } else {
+        printf("Error occured Dest int %d %d\n", addedDestCount,index);
+        exit(-1);
+    }
+}
+
+void CommPack::modifyDestData(float data, int index) {
+    if (index < addedDestCount) {
+        destData[index].data.f = data;
+    } else {
+        printf("Error occured Dest %d %d\n", addedDestCount,index);
+        exit(-1);
+    }
+}
+
+void CommPack::modifyDestData(uint64_t data, int index) {
+    if (index < addedDestCount) {
+        destData[index].data.ui = data;
+    } else {
+        printf("Error occured Dest %d %d\n", addedDestCount,index);
+        exit(-1);
+    }
+}
+
+TheISA::PCState CommPack::getPC() {
+    return pcstate;
+}
+
+void CommPack::setSrcType(dataChar dtype, int indx) {
+    sdType[indx] = dtype;
+}
+
+void CommPack::initDest(int numDest) {
+    setNumDestRegs(numDest);
+}
+
+void CommPack::setDestType(dataChar dtype, int indx) {
+    ddType[indx] = dtype;
+}
+
+dataChar CommPack::getSrcType(int indx) {
+    return sdType[indx];
+}
+
+dataChar CommPack::getDestType(int indx) {
+    return ddType[indx];
+}
+
+StaticInstPtr CommPack::getInstPtr() {
+    return this->curStaticInst;
+}
+
+int CommPack::getCPUid() {
+    return cpuid;
+}
+
+void CommPack::setPC(TheISA::PCState pcs) {
+    pcstate = pcs;
+}
+
+BaseInstrIOWire::BaseInstrIOWire(int id, InstrIOPortsHandler* ioph) : processorId(id), dataAv(false) {
+    DPRINTF(Squasher, "ioph is being set to %i for [id:%d]\n", ioph, id);
+    this->ioph = ioph;
+    mport = false;
+    initBuffer(100);
+}
+
+BaseInstrIOWire::BaseInstrIOWire(int id, InstrIOPortsHandler* ioph, bool port) : processorId(id), dataAv(false) {
+    this->ioph = ioph;
+    DPRINTF(Squasher, "ioph is being set to %i with [id:%d] and port as %s\n", ioph, id, port ? "true" : "false");
+    mport = port;
+    initBuffer(100);
+}
+
+BaseInstrIOWire::BaseInstrIOWire(int id, InstrIOPortsHandler* ioph, bool port, bool in) : processorId(id), dataAv(false) {
+    this->ioph = ioph;
+    DPRINTF(Squasher, "Wire %i with ioph is being set to %i with [id:%d] and master port as  %s is in? %s \n", this, ioph, id, port ? "true" : "false", in ? "true" : "false");
+    inport = in;
+    mport = port;
+    if (!inport)
+        initBuffer(100);
+}
+
+BaseInstrIOWire::BaseInstrIOWire(int id, int bufferSize) : processorId(id), bufferDepth(bufferSize), dataAv(false) {
+    initBuffer(bufferSize);
+    ioph = NULL;
+    DPRINTF(Squasher, "ioph is being set to %i with buffer size as %d\n", ioph, bufferSize);
+    exit(1);
+}
+
+BaseInstrIOWire::BaseInstrIOWire() : processorId(-1), dataAv(false) {
+    initBuffer(100);
+}
+
+void BaseInstrIOWire::initBuffer(int bufferSize) {
+    bufferDepth = bufferSize;
+}
+
+void BaseInstrIOWire::setProcessorId(int id) {
+    processorId = id;
+}
+
+bool BaseInstrIOWire::isAvailable() {
+    //DPRINTF(Squasher,"wire check for availability, answer is %s\n",dataAv?"true":"false");
+    return dataAv;
+}
+
+void BaseInstrIOWire::setAvailable() {
+    dataAv = true;
+}
+
+void BaseInstrIOWire::resetAvailable() {
+    dataAv = false;
+}
+
+int BaseInstrIOWire::getProcessorId() {
+    return processorId;
+}
+
+CommPack* BaseInstrIOWire::readData() {
+    CommPack* temp = NULL;
+    if (isAvailable()) {
+        temp = bufferedData.front();
+        DPRINTF(Squasher, "Reading Data\n");
+    } else {
+        printf("Invalid data request\n");
+        return NULL;
+    }
+    return temp;
+}
+
+CommPack* BaseInstrIOWire::getData() {
+    CommPack* temp;
+    if (isAvailable()) {
+        //                DPRINTF(Squasher,"Getting Data\t");
+        temp = bufferedData.front();
+        bufferedData.pop_front();
+        DPRINTF(Squasher, "wire is %i,  mport is %s and inport is %s, getting data %i, now size is %d\n", this, mport ? "true" : "false", inport ? "true" : "false", temp, bufferedData.size());
+        if (bufferedData.empty()) {
+            DPRINTF(Squasher, "Setting wire to empty\n");
+            resetAvailable();
+        }
+    } else {
+        printf("Invalid data request\n");
+        return NULL;
+    }
+    DPRINTF(Squasher, "The packet being read is %i\n", temp);
+    return temp;
+}
+
+bool BaseInstrIOWire::isMaster() {
+    return mport;
+}
+
+bool BaseInstrIOWire::isIn() {
+    return inport;
+}
+
+bool BaseInstrIOWire::setData(CommPack* data) {
+    DPRINTF(Squasher, "wire is %i,  mport is %s and inport is %s\n", this, mport ? "true" : "false", inport ? "true" : "false");
+    if (!mport && inport) {
+        return ioph->redirectToHelper(data);
+    }
+    if (mport && inport) {
+        return ioph->redirectFromHelper(data, data->getCPUid());
+    }
+    if (bufferedData.size() < bufferDepth) {
+        bufferedData.push_back(data);
+        DPRINTF(Squasher, "Size of buffer now is %d\n", bufferedData.size());
+        setAvailable();
+        return true;
+    }
+    return false;
+}
+bool BaseInstrIOWire::setData(CommPack* data,bool front) {
+    DPRINTF(Squasher, "wire is %i,  mport is %s and inport is %s\n", this, mport ? "true" : "false", inport ? "true" : "false");
+    if (!mport && inport) {
+        return ioph->redirectToHelper(data);
+    }
+    if (mport && inport) {
+        return ioph->redirectFromHelper(data, data->getCPUid());
+    }
+    if (bufferedData.size() < bufferDepth) {
+        if(!front){
+            bufferedData.push_back(data);
+        }
+        else{
+            bufferedData.push_front(data);
+        }
+        DPRINTF(Squasher, "Size of buffer now is %d\n", bufferedData.size());
+        setAvailable();
+        return true;
+    }
+    return false;
+}
+bool BaseInstrIOWire::setData(CommPack* data, int cpuId) {
+    DPRINTF(Squasher, "wire is %i,  mport is %s and inport is %s\n", this, mport ? "true" : "false", inport ? "true" : "false");
+    if (!mport && inport)
+        return ioph->redirectToHelper(data);
+    if (mport && inport)
+        return ioph->redirectFromHelper(data, cpuId);
+    if (bufferedData.size() < bufferDepth) {
+        bufferedData.push_back(data);
+        DPRINTF(Squasher, "Size of buffer now is %d\n", bufferedData.size());
+        setAvailable();
+        return true;
+    }
+    return false;
+}
+
+portInterface::portInterface(bool port) : masterPort(port) {
+
+}
+
+CommPack* portInterface::getData() {
+    DPRINTF(Squasher, "Requesting Port interface for data\n");
+    return outwire->getData();
+}
+
+CommPack* portInterface::readData() {
+    DPRINTF(Squasher, "Requesting Port interface for data read\n");
+    return outwire->readData();
+}
+
+bool portInterface::isAvailable() {
+    //            DPRINTF(Squasher,"Requesting Port interface for availability\n");
+    return outwire->isAvailable();
+}
+
+bool portInterface::isEmpty() {
+    //            DPRINTF(Squasher,"Requesting Port interface for availability\n");
+    return !isAvailable();
+}
+
+bool portInterface::setData(CommPack* data) {
+    DPRINTF(Squasher, "Requesting Port interface for write\n");
+    return inwire->setData(data);
+}
+
+void portInterface::setInBaseWire(BaseInstrIOWire* inw) {
+    inwire = inw;
+}
+
+void portInterface::setOutBaseWire(BaseInstrIOWire* inw) {
+    outwire = inw;
+}
+
+BaseInstrIOWire* InstrIOPortsHandler::getInWire(int id) {
+    int tid = wireIds[id];
+    if (tid < numPorts)
+        return inWires[tid];
+    else
+        return NULL;
+}
+
+BaseInstrIOWire* InstrIOPortsHandler::getOutWire(int id) {
+    int tid = wireIds[id];
+    if (tid < numPorts)
+        return outWires[tid];
+    else
+        return NULL;
+}
+
+BaseInstrIOWire* InstrIOPortsHandler::getMasterInWire() {
+    return masterInWire;
+}
+
+BaseInstrIOWire* InstrIOPortsHandler::getMasterOutWire() {
+    return masterOutWire;
+}
+
+void InstrIOPortsHandler::setConnection(int id, portInterface* port) {
+    port->setInBaseWire(getInWire(id));
+    port->setOutBaseWire(getOutWire(id));
+}
+
+void InstrIOPortsHandler::addWire(int id) {
+    DPRINTF(Squasher, "Adding wires for %d CPU\n");
+    BaseInstrIOWire* tempInPort = new BaseInstrIOWire(id, this, false, true);
+    BaseInstrIOWire* tempOutPort = new BaseInstrIOWire(id, this, false, false);
+    wireIds[id] = numPorts;
+    inWires.push_back(tempInPort);
+    outWires.push_back(tempOutPort);
+    numPorts++;
+}
+
+InstrIOPortsHandler::InstrIOPortsHandler(int numPorts) : numPorts(numPorts), lastChecked(0) {
+    DPRINTF(Squasher, "IOPH formed at %i \n", this);
+    for (int i = 0; i < numPorts; i++) {
+        DPRINTF(Squasher, "Initialize useless wires\n");
+        addWire(i);
+    }
+    DPRINTF(Squasher, "Initialize master wires\n");
+
+    masterInWire = new BaseInstrIOWire(-1, this, true, true);
+    DPRINTF(Squasher, "Initialize masterOut  wires\n");
+    masterOutWire = new BaseInstrIOWire(-1, this, true, false);
+}
+
+void InstrIOPortsHandler::setHelperCPU(BaseCPU* bcpu) {
+    DPRINTF(Squasher, "Setting helper CPU as %i for %i IOPH\n", tcpu, this);
+    tcpu = bcpu;
+}
+
+void InstrIOPortsHandler::addMasterConnection(portInterface* port) {
+    DPRINTF(Squasher, "Adding Master Connection %i\n", port);
+    port->setInBaseWire(this->masterInWire);
+    port->setOutBaseWire(this->masterOutWire);
+}
+
+void InstrIOPortsHandler::addConnection(int id, portInterface* port) {
+    addWire(id);
+    setConnection(id, port);
+}
+
+bool InstrIOPortsHandler::redirectToHelper(CommPack* data) {
+    DPRINTF(Squasher, "redirecting to Helper CPU  ioph is %i The masterOutWire is %i\n", this, masterOutWire);
+    if (!masterOutWire->isMaster() && masterOutWire->isIn()) {
+        DPRINTF(Squasher, "mport is %s and inport is %s\n", masterOutWire->isMaster() ? "true" : "false", masterOutWire->isIn() ? "true" : "false");
+        DPRINTF(Squasher, "Strange Master Port Behaviour\n");
+    } else {
+    }
+
+    bool ret = false;
+    if(tcpu->waitingData(data)){
+        DPRINTF(Squasher,"CPU is locked with a data request, overriding que\n");
+        ret=masterOutWire->setData(data,true);
+        tcpu->addCorrectorEvent();
+        return ret;
+    }
+    ret=masterOutWire->setData(data,false);
+    if (!tcpu->isLocked())
+        tcpu->addCorrectorEvent();
+    return ret;
+}
+
+bool InstrIOPortsHandler::redirectFromHelper(CommPack* data, int id) {
+    DPRINTF(Squasher, "Requesting IOPorthander for redirect from helper\n");
+    return getOutWire(id)->setData(data);
+}
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/PortManager.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/PortManager.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,368 @@
+/*
+ * Copyright (c) 2011-2012 University of Cambridge
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2004-2006 The Regents of The University of Michigan
+ * Copyright (c) 2011 Regents of the University of California
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Jyothish Soman
+ */
+
+#ifndef pm_header_port_handler
+#define pm_header_port_handler
+#ifndef __CPU_BASE_HH__
+#include"cpu/base.hh"
+#endif
+//class BaseCPU;
+//#include "sim/sim_object.hh"
+//#include "config/the_isa.hh"
+#include "cpu/static_inst.hh"
+//#include "cpu/helper/timing.hh"
+#include<vector>
+#include<cstdlib>
+#include<cstdint>
+#include<queue>
+#include<debug/Squasher.hh>
+#include <debug/PH.hh>
+#include "sim/process.hh"
+
+
+
+//using namespace TheISA;
+using namespace std;
+
+/*
+ *  Basic datapacket class, add staticinst features to this class
+ *
+ *
+ *
+ */
+//class TimingHelperCPU;
+
+typedef enum {
+    fetchP, decodeP, executeP,fullP,dataRequest, completedP
+} dataPhase;
+
+enum dataChar {
+    enFloat, enInt, enMisc
+};
+
+typedef union dataStore {
+    char c;
+    int64_t i;
+    uint64_t ui;
+    float f;
+} dataStore_t;
+
+typedef struct {
+    dataStore_t data;
+    int index;
+} transferData;
+
+class CommPack {
+    
+    int numSrcRegs,numDestRegs;
+    
+    int testVal;
+    
+    transferData* srcData,*destData;
+    
+    dataChar *sdType,*ddType;
+    
+    int cpuid;
+
+    Tick placedTick;
+    
+    int addedSrcCount,addedDestCount;
+    
+    ThreadID tid;
+
+    dataPhase dataPh;
+
+    Process * process;
+
+    TheISA::PCState pcstate;
+    
+    TheISA::TLB *dtlb;
+    
+    TheISA::TLB *itlb;
+    
+    StaticInstPtr curStaticInst;
+    
+
+    public:
+
+    //
+    //  Function to pack an instruction into this class
+    //  #TODO complete the details, currently bare bones version
+    //
+    CommPack(StaticInstPtr instr, int cpuId);
+
+    CommPack( int cpuId);
+
+    ~CommPack();
+
+    void setProcess(Process * prs);
+
+    Process* getProcess();
+
+    void setTID(ThreadID tid);
+    
+    ThreadID getTID();
+    
+    void setITLB(TheISA::TLB * itlb_cpu);
+    
+    
+    void setDTLB(TheISA::TLB * dtlb_cpu);
+
+    void setTick(Tick curTick){
+        placedTick=curTick;
+    }
+    Tick getTick(){
+        return placedTick;
+    }
+    TheISA::TLB* getDTLB();
+    
+    TheISA::TLB* getITLB();
+
+    int getNumSrcRegs();
+
+    void setNumSrcRegs(int nRegs);
+
+    int getNumDestRegs();
+
+    void setNumDestRegs(int nRegs);    
+    
+    void setPhase(dataPhase ph);
+
+    dataPhase getPhase();
+
+    transferData getSrcData(int id);
+
+    transferData getDestData(int id);
+    
+    void setSrcData(int64_t data, int index);
+
+    void setSrcData(float data, int index);
+
+    void setSrcData(uint64_t data, int index);
+
+    void setDestData(int64_t data, int index);
+
+    void setDestData(float data, int index);
+
+    void setDestData(uint64_t data, int index);
+ 
+    void modifyDestData(int64_t data, int index);
+
+    void modifyDestData(float data, int index);
+
+    void modifyDestData(uint64_t data, int index);
+   
+    TheISA::PCState getPC();
+
+    void setSrcType(dataChar dtype, int indx);
+
+    void initDest(int numDest);
+   
+    void setDestType(dataChar dtype, int indx);
+    
+    dataChar getSrcType(int indx);
+    
+    dataChar getDestType(int indx);
+    
+    StaticInstPtr getInstPtr();
+    
+    void setInstPtr(StaticInstPtr ptr);
+
+    int getCPUid();
+
+    void setPC(TheISA::PCState pcs);
+
+};
+
+/*
+ * queue for each buffer, we are implementing it as a queue as it is a natural fit
+ */
+
+typedef deque<CommPack*> cbuf;
+
+
+
+
+/*
+   enum direction_t {
+   toHub, fromHub
+   };
+ */
+
+/*
+ *  Wire class that holds the temporary data from each of the ports
+ *  It is unaware of the ports, ports access and write to the wire
+ *
+ */
+class InstrIOPortsHandler;
+
+class BaseInstrIOWire {
+    /*
+     *  Keeping data as protected, so that inheritence is simple.
+     *  Class keeps track of the processor to which it connects to and the queue properties
+     *
+     */
+
+
+
+protected:
+    int processorId, bufferDepth;
+    bool dataAv, mport, inport;
+    cbuf bufferedData;
+    InstrIOPortsHandler * ioph;
+
+    BaseCPU *tcpu;
+
+
+public:
+
+    BaseInstrIOWire(int id, InstrIOPortsHandler* ioph);
+
+
+    BaseInstrIOWire(int id, InstrIOPortsHandler* ioph, bool port);
+
+
+    BaseInstrIOWire(int id, InstrIOPortsHandler* ioph, bool port, bool in);
+
+
+    BaseInstrIOWire(int id, int bufferSize);
+
+
+    BaseInstrIOWire();
+
+
+    void initBuffer(int bufferSize);
+
+    void setProcessorId(int id);
+
+    bool isAvailable();
+
+    void setAvailable();
+
+    void resetAvailable();
+
+    int getProcessorId();
+
+    bool setData(CommPack* data);
+
+    bool setData(CommPack* data, int cpuId);
+
+    bool setData(CommPack* data,bool front);
+
+    CommPack* readData();
+
+    CommPack* getData();
+
+    bool isMaster();
+
+    bool isIn();
+
+};
+
+class portInterface {
+private:
+    BaseInstrIOWire* inwire, *outwire;
+    bool masterPort;
+public:
+    portInterface(bool port);
+    CommPack* getData();
+    CommPack* readData();
+
+    bool isAvailable();
+
+    bool isEmpty();
+    bool setData(CommPack* data);
+    void setInBaseWire(BaseInstrIOWire* inw);
+    void setOutBaseWire(BaseInstrIOWire* inw);
+};
+
+/*
+ *  InstrIOPortsHandler class is the primary hub class, and is used for operational uses
+ *  Change the CommPack and this class for most usages. The constructor is setting the queue
+ *  size as 1, change according to convenience
+ */
+
+class InstrIOPortsHandler {
+protected:
+    int numPorts, lastChecked;
+    std::vector<BaseInstrIOWire*> inWires, outWires;
+    std::map<int, int> wireIds;
+    BaseInstrIOWire* masterInWire, * masterOutWire;
+    BaseCPU *tcpu;
+    BaseInstrIOWire* getInWire(int id);
+
+    BaseInstrIOWire* getOutWire(int id);
+
+    BaseInstrIOWire* getMasterInWire();
+
+    BaseInstrIOWire* getMasterOutWire();
+
+    void setConnection(int id, portInterface* port);
+
+    void addWire(int id);
+public:
+
+
+    InstrIOPortsHandler(int numPorts);
+
+    void setHelperCPU(BaseCPU* bcpu);
+
+    void addMasterConnection(portInterface* port);
+
+    void addConnection(int id, portInterface* port);
+
+
+
+    bool redirectToHelper(CommPack* data);
+
+    bool redirectFromHelper(CommPack* data, int id);
+
+    bool checkEvent() {
+        return false;
+    }
+
+};
+
+
+#endif	/* PORTMANAGER_HH */
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/SConscript
--- a/src/cpu/SConscript	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/SConscript	Wed Aug 05 11:39:08 2015 +0100
@@ -120,6 +120,7 @@
 Source('simple_thread.cc')
 Source('thread_context.cc')
 Source('thread_state.cc')
+Source('PortManager.cc')
 
 if env['TARGET_ISA'] == 'sparc':
     SimObject('LegionTrace.py')
@@ -129,7 +130,9 @@
 Source('checker/cpu.cc')
 Source('dummy_checker.cc')
 DebugFlag('Checker')
-
+DebugFlag('Basedyn')
+DebugFlag('Squasher')
+DebugFlag('PH')
 DebugFlag('Activity')
 DebugFlag('Commit')
 DebugFlag('Context')
@@ -157,6 +160,7 @@
 DebugFlag('O3PipeView')
 DebugFlag('PCEvent')
 DebugFlag('Quiesce')
+DebugFlag('TLBUsage')
 
 CompoundFlag('ExecAll', [ 'ExecEnable', 'ExecCPSeq', 'ExecEffAddr',
     'ExecFaulting', 'ExecFetchSeq', 'ExecOpClass', 'ExecRegDelta',
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/base.cc
--- a/src/cpu/base.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/base.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -59,6 +59,7 @@
 #include "cpu/profile.hh"
 #include "cpu/thread_context.hh"
 #include "debug/SyscallVerbose.hh"
+#include "debug/Squasher.hh"
 #include "params/BaseCPU.hh"
 #include "sim/full_system.hh"
 #include "sim/process.hh"
@@ -72,7 +73,7 @@
 using namespace std;
 
 vector<BaseCPU *> BaseCPU::cpuList;
-
+ InstrIOPortsHandler* BaseCPU::ioh;
 // This variable reflects the max number of threads in any CPU.  Be
 // careful to only use it once all the CPUs that you care about have
 // been initialized
@@ -123,6 +124,10 @@
       interrupts(p->interrupts), profileEvent(NULL),
       numThreads(p->numThreads), system(p->system)
 {
+    if(cpuList.size()==0){
+        DPRINTF(Squasher,"IOH initialized\n");
+        ioh=new InstrIOPortsHandler(0);
+    }
     // if Python did not provide a valid ID, do it here
     if (_cpuId == -1 ) {
         _cpuId = cpuList.size();
@@ -130,7 +135,7 @@
 
     // add self to global list of CPUs
     cpuList.push_back(this);
-
+    
     DPRINTF(SyscallVerbose, "Constructing CPU with id %d\n", _cpuId);
 
     if (numThreads > maxThreadsPerCPU)
@@ -288,7 +293,7 @@
 
     numCycles
         .name(name() + ".numCycles")
-        .desc("number of cpu cycles simulated")
+        .desc("number of cpu cyclezzzzz simulated")
         ;
 
     numWorkItemsStarted
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/base.hh
--- a/src/cpu/base.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/base.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -58,11 +58,14 @@
 #include "sim/full_system.hh"
 #include "sim/insttracer.hh"
 #include "sim/system.hh"
+#include"cpu/PortManager.hh"
 
 struct BaseCPUParams;
 class CheckerCPU;
 class ThreadContext;
-
+class InstrIOPortsHandler;
+class CommPack;
+class BPredUnit;
 class CPUProgressEvent : public Event
 {
   protected:
@@ -101,6 +104,7 @@
 
     /** data side request id that must be placed in all requests */
     MasterID _dataMasterId;
+    
 
     /** An intrenal representation of a task identifier within gem5. This is
      * used so the CPU can add which taskId (which is an internal representation
@@ -120,6 +124,17 @@
     const unsigned int _cacheLineSize;
 
   public:
+        virtual void addCorrectorEvent(){
+
+        }
+        
+        virtual bool  waitingData(CommPack *check){
+            return false;
+        }
+        virtual bool isLocked(){
+            return false;
+        }
+        BPredUnit *branchPred;
 
     /**
      * Purely virtual method that returns a reference to the data
@@ -272,6 +287,11 @@
     void registerThreadContexts();
 
     /**
+     * Pause a CPU.
+     */
+    virtual void pause(bool pause) {}
+
+    /**
      * Prepare for another CPU to take over execution.
      *
      * When this method exits, all internal state should have been
@@ -438,7 +458,9 @@
 
   private:
     static std::vector<BaseCPU *> cpuList;   //!< Static global cpu list
-
+   
+  protected:
+    static InstrIOPortsHandler * ioh;
   public:
     void traceFunctions(Addr pc)
     {
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/base_dyn_inst.hh
--- a/src/cpu/base_dyn_inst.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/base_dyn_inst.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -65,6 +65,7 @@
 #include "sim/fault_fwd.hh"
 #include "sim/system.hh"
 #include "sim/tlb.hh"
+#include "debug/Basedyn.hh"
 
 /**
  * @file
@@ -696,6 +697,10 @@
     /** Clears this instruction being able to issue. */
     void clearCanIssue() { status.reset(CanIssue); }
 
+    void resetRenamedRegisterCount(){
+        readyRegs = 0;
+    }
+
     /** Sets this instruction as issued from the IQ. */
     void setIssued() { status.set(Issued); }
 
@@ -731,7 +736,9 @@
     bool isCommitted() const { return status[Committed]; }
 
     /** Sets this instruction as squashed. */
-    void setSquashed() { status.set(Squashed); }
+    void setSquashed() { 
+        DPRINTF(Basedyn, "Squash requested for [sn:%i] \n",seqNum);
+        status.set(Squashed); }
 
     /** Returns whether or not this instruction is squashed. */
     bool isSquashed() const { return status[Squashed]; }
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/base_dyn_inst_impl.hh
--- a/src/cpu/base_dyn_inst_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/base_dyn_inst_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -152,7 +152,6 @@
 #ifdef DEBUG
     cpu->snList.erase(seqNum);
 #endif
-
     if (reqToVerify)
         delete reqToVerify;
 }
@@ -178,7 +177,7 @@
 BaseDynInst<Impl>::dump()
 {
     cprintf("T%d : %#08d `", threadNumber, pc.instAddr());
-    std::cout << staticInst->disassemble(pc.instAddr());
+    std::cout <<"instr dump" <<staticInst->disassemble(pc.instAddr());
     cprintf("'\n");
 }
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/BaseDeadCPU.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/BaseDeadCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,48 @@
+# Copyright (c) 2008 The Hewlett-Packard Development Company
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabe Black
+
+from m5.defines import buildEnv
+from m5.params import *
+from BaseCPU import BaseCPU
+from DummyChecker import DummyChecker
+
+class BaseDeadCPU(BaseCPU):
+    type = 'BaseDeadCPU'
+    abstract = True
+    cxx_header = "cpu/deadTiming/base.hh"
+
+    def addCheckerCpu(self):
+        if buildEnv['TARGET_ISA'] in ['arm']:
+            from ArmTLB import ArmTLB
+
+            self.checker = DummyChecker(workload = self.workload)
+            self.checker.itb = ArmTLB(size = self.itb.size)
+            self.checker.dtb = ArmTLB(size = self.dtb.size)
+        else:
+            print "ERROR: Checker only supported under ARM ISA!"
+            exit(1)
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/SConscript
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/SConscript	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,50 @@
+# -*- mode:python -*-
+
+# Copyright (c) 2006 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+Import('*')
+
+need_dead_base = False
+if 'AtomicDeadCPU' in env['CPU_MODELS']:
+    need_dead_base = True
+    SimObject('AtomicDeadCPU.py')
+    Source('atomic.cc')
+
+if 'TimingDeadCPU' in env['CPU_MODELS']:
+    need_dead_base = True
+    SimObject('TimingDeadCPU.py')
+    Source('timing.cc')
+
+if 'AtomicDeadCPU' in env['CPU_MODELS'] or \
+       'TimingDeadCPU' in env['CPU_MODELS']:
+    DebugFlag('DeadCPU')
+
+if need_dead_base:
+    Source('base.cc')
+    SimObject('BaseDeadCPU.py')
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/SConsopts
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/SConsopts	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,40 @@
+# -*- mode:python -*-
+
+# Copyright (c) 2006 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+Import('*')
+
+CpuModel('AtomicDeadCPU', 'atomic_dead_cpu_exec.cc',
+         '#include "cpu/deadTiming/atomic.hh"',
+         { 'CPU_exec_context': 'AtomicDeadCPU' },
+         default=True)
+CpuModel('TimingDeadCPU', 'timing_dead_cpu_exec.cc',
+         '#include "cpu/deadTiming/timing.hh"',
+         { 'CPU_exec_context': 'TimingDeadCPU' },
+         default=True)
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/TimingDeadCPU.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/TimingDeadCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,42 @@
+# Copyright (c) 2007 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+from m5.params import *
+from BaseDeadCPU import BaseDeadCPU
+
+class TimingDeadCPU(BaseDeadCPU):
+    type = 'TimingDeadCPU'
+    cxx_header = "cpu/deadTiming/timing.hh"
+
+    @classmethod
+    def memory_mode(cls):
+        return 'timing'
+
+    @classmethod
+    def support_take_over(cls):
+        return True
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/base.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/base.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,523 @@
+/*
+ * Copyright (c) 2010-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+#include "arch/kernel_stats.hh"
+#include "arch/stacktrace.hh"
+#include "arch/tlb.hh"
+#include "arch/utility.hh"
+#include "arch/vtophys.hh"
+#include "base/loader/symtab.hh"
+#include "base/cp_annotate.hh"
+#include "base/cprintf.hh"
+#include "base/inifile.hh"
+#include "base/misc.hh"
+#include "base/pollevent.hh"
+#include "base/trace.hh"
+#include "base/types.hh"
+#include "config/the_isa.hh"
+#include "cpu/deadTiming/base.hh"
+#include "cpu/base.hh"
+#include "cpu/checker/cpu.hh"
+#include "cpu/checker/thread_context.hh"
+#include "cpu/exetrace.hh"
+#include "cpu/profile.hh"
+#include "cpu/simple_thread.hh"
+#include "cpu/smt.hh"
+#include "cpu/static_inst.hh"
+#include "cpu/thread_context.hh"
+#include "debug/Decode.hh"
+
+#include "debug/SimpleCPU.hh"
+#include "debug/Fetch.hh"
+#include "debug/Quiesce.hh"
+#include "mem/mem_object.hh"
+#include "mem/packet.hh"
+#include "mem/request.hh"
+#include "params/BaseDeadCPU.hh"
+#include "sim/byteswap.hh"
+#include "sim/debug.hh"
+#include "sim/faults.hh"
+#include "sim/full_system.hh"
+#include "sim/sim_events.hh"
+#include "sim/sim_object.hh"
+#include "sim/stats.hh"
+#include "sim/system.hh"
+
+using namespace std;
+using namespace TheISA;
+
+BaseDeadCPU::BaseDeadCPU(BaseDeadCPUParams *p)
+    : BaseCPU(p), traceData(NULL), thread(NULL)
+{
+    if (FullSystem)
+        thread = new SimpleThread(this, 0, p->system, p->itb, p->dtb,
+                                  p->isa[0]);
+    else
+        thread = new SimpleThread(this, /* thread_num */ 0, p->system,
+                                  p->workload[0], p->itb, p->dtb, p->isa[0]);
+
+    thread->setStatus(ThreadContext::Halted);
+
+    tc = thread->getTC();
+
+    if (p->checker) {
+        BaseCPU *temp_checker = p->checker;
+        checker = dynamic_cast<CheckerCPU *>(temp_checker);
+        checker->setSystem(p->system);
+        // Manipulate thread context
+        ThreadContext *cpu_tc = tc;
+        tc = new CheckerThreadContext<ThreadContext>(cpu_tc, this->checker);
+    } else {
+        checker = NULL;
+    }
+
+    numInst = 0;
+    startNumInst = 0;
+    numOp = 0;
+    startNumOp = 0;
+    numLoad = 0;
+    startNumLoad = 0;
+    lastIcacheStall = 0;
+    lastDcacheStall = 0;
+
+    threadContexts.push_back(tc);
+
+
+    fetchOffset = 0;
+    stayAtPC = false;
+}
+
+BaseDeadCPU::~BaseDeadCPU()
+{
+}
+
+void
+BaseDeadCPU::deallocateContext(ThreadID thread_num)
+{
+    // for now, these are equivalent
+    suspendContext(thread_num);
+}
+
+
+void
+BaseDeadCPU::haltContext(ThreadID thread_num)
+{
+    // for now, these are equivalent
+    suspendContext(thread_num);
+}
+
+
+void
+BaseDeadCPU::regStats()
+{
+    using namespace Stats;
+
+    BaseCPU::regStats();
+
+    numInsts
+        .name(name() + ".committedInsts")
+        .desc("Number of instructions committed")
+        ;
+
+    numOps
+        .name(name() + ".committedOps")
+        .desc("Number of ops (including micro ops) committed")
+        ;
+
+    numIntAluAccesses
+        .name(name() + ".num_int_alu_accesses")
+        .desc("Number of integer alu accesses")
+        ;
+
+    numFpAluAccesses
+        .name(name() + ".num_fp_alu_accesses")
+        .desc("Number of float alu accesses")
+        ;
+
+    numCallsReturns
+        .name(name() + ".num_func_calls")
+        .desc("number of times a function call or return occured")
+        ;
+
+    numCondCtrlInsts
+        .name(name() + ".num_conditional_control_insts")
+        .desc("number of instructions that are conditional controls")
+        ;
+
+    numIntInsts
+        .name(name() + ".num_int_insts")
+        .desc("number of integer instructions")
+        ;
+
+    numFpInsts
+        .name(name() + ".num_fp_insts")
+        .desc("number of float instructions")
+        ;
+
+    numIntRegReads
+        .name(name() + ".num_int_register_reads")
+        .desc("number of times the integer registers were read")
+        ;
+
+    numIntRegWrites
+        .name(name() + ".num_int_register_writes")
+        .desc("number of times the integer registers were written")
+        ;
+
+    numFpRegReads
+        .name(name() + ".num_fp_register_reads")
+        .desc("number of times the floating registers were read")
+        ;
+
+    numFpRegWrites
+        .name(name() + ".num_fp_register_writes")
+        .desc("number of times the floating registers were written")
+        ;
+
+    numMemRefs
+        .name(name()+".num_mem_refs")
+        .desc("number of memory refs")
+        ;
+
+    numStoreInsts
+        .name(name() + ".num_store_insts")
+        .desc("Number of store instructions")
+        ;
+
+    numLoadInsts
+        .name(name() + ".num_load_insts")
+        .desc("Number of load instructions")
+        ;
+
+    notIdleFraction
+        .name(name() + ".not_idle_fraction")
+        .desc("Percentage of non-idle cycles")
+        ;
+
+    idleFraction
+        .name(name() + ".idle_fraction")
+        .desc("Percentage of idle cycles")
+        ;
+
+    numBusyCycles
+        .name(name() + ".num_busy_cycles")
+        .desc("Number of busy cycles")
+        ;
+
+    numIdleCycles
+        .name(name()+".num_idle_cycles")
+        .desc("Number of idle cycles")
+        ;
+
+    icacheStallCycles
+        .name(name() + ".icache_stall_cycles")
+        .desc("ICache total stall cycles")
+        .prereq(icacheStallCycles)
+        ;
+
+    dcacheStallCycles
+        .name(name() + ".dcache_stall_cycles")
+        .desc("DCache total stall cycles")
+        .prereq(dcacheStallCycles)
+        ;
+
+    icacheRetryCycles
+        .name(name() + ".icache_retry_cycles")
+        .desc("ICache total retry cycles")
+        .prereq(icacheRetryCycles)
+        ;
+
+    dcacheRetryCycles
+        .name(name() + ".dcache_retry_cycles")
+        .desc("DCache total retry cycles")
+        .prereq(dcacheRetryCycles)
+        ;
+
+    idleFraction = constant(1.0) - notIdleFraction;
+    numIdleCycles = idleFraction * numCycles;
+    numBusyCycles = (notIdleFraction)*numCycles;
+}
+
+void
+BaseDeadCPU::resetStats()
+{
+//    startNumInst = numInst;
+     notIdleFraction = (_status != Idle);
+}
+
+void
+BaseDeadCPU::serializeThread(ostream &os, ThreadID tid)
+{
+    assert(_status == Idle || _status == Running);
+    assert(tid == 0);
+
+    thread->serialize(os);
+}
+
+void
+BaseDeadCPU::unserializeThread(Checkpoint *cp, const string &section,
+                                 ThreadID tid)
+{
+    if (tid != 0)
+        fatal("Trying to load more than one thread into a DeadCPU\n");
+    thread->unserialize(cp, section);
+}
+
+Addr
+BaseDeadCPU::dbg_vtophys(Addr addr)
+{
+    return vtophys(tc, addr);
+}
+
+void
+BaseDeadCPU::wakeup()
+{
+    if (thread->status() != ThreadContext::Suspended)
+        return;
+
+    DPRINTF(Quiesce,"Suspended Processor awoke\n");
+    thread->activate();
+}
+
+void
+BaseDeadCPU::checkForInterrupts()
+{
+    if (checkInterrupts(tc)) {
+        Fault interrupt = interrupts->getInterrupt(tc);
+
+        if (interrupt != NoFault) {
+            fetchOffset = 0;
+            interrupts->updateIntrInfo(tc);
+            interrupt->invoke(tc);
+            thread->decoder.reset();
+        }
+    }
+}
+
+
+void
+BaseDeadCPU::setupFetchRequest(Request *req)
+{
+    Addr instAddr = thread->instAddr();
+
+    // set up memory request for instruction fetch
+    DPRINTF(Fetch, "Fetch: PC:%08p\n", instAddr);
+
+    Addr fetchPC = (instAddr & PCMask) + fetchOffset;
+    req->setVirt(0, fetchPC, sizeof(MachInst), Request::INST_FETCH, instMasterId(),
+            instAddr);
+}
+
+
+void
+BaseDeadCPU::preExecute()
+{
+    // maintain $r0 semantics
+    thread->setIntReg(ZeroReg, 0);
+#if THE_ISA == ALPHA_ISA
+    thread->setFloatReg(ZeroReg, 0.0);
+#endif // ALPHA_ISA
+
+    // check for instruction-count-based events
+    comInstEventQueue[0]->serviceEvents(numInst);
+    system->instEventQueue.serviceEvents(system->totalNumInsts);
+
+    // decode the instruction
+    inst = gtoh(inst);
+
+    TheISA::PCState pcState = thread->pcState();
+
+    if (isRomMicroPC(pcState.microPC())) {
+        stayAtPC = false;
+        curStaticInst = microcodeRom.fetchMicroop(pcState.microPC(),
+                                                  curMacroStaticInst);
+    } else if (!curMacroStaticInst) {
+        //We're not in the middle of a macro instruction
+        StaticInstPtr instPtr = NULL;
+
+        TheISA::Decoder *decoder = &(thread->decoder);
+
+        //Predecode, ie bundle up an ExtMachInst
+        //If more fetch data is needed, pass it in.
+        Addr fetchPC = (pcState.instAddr() & PCMask) + fetchOffset;
+        //if(decoder->needMoreBytes())
+            decoder->moreBytes(pcState, fetchPC, inst);
+        //else
+        //    decoder->process();
+
+        //Decode an instruction if one is ready. Otherwise, we'll have to
+        //fetch beyond the MachInst at the current pc.
+        instPtr = decoder->decode(pcState);
+        if (instPtr) {
+            stayAtPC = false;
+            thread->pcState(pcState);
+        } else {
+            stayAtPC = true;
+            fetchOffset += sizeof(MachInst);
+        }
+
+        //If we decoded an instruction and it's microcoded, start pulling
+        //out micro ops
+        if (instPtr && instPtr->isMacroop()) {
+            curMacroStaticInst = instPtr;
+            curStaticInst = curMacroStaticInst->fetchMicroop(pcState.microPC());
+        } else {
+            curStaticInst = instPtr;
+        }
+    DPRINTF(SimpleCPU, "Instruction is: %s %#x\n",
+                curStaticInst->getName(), curStaticInst->machInst);
+
+    } else {
+        //Read the next micro op from the macro op
+        curStaticInst = curMacroStaticInst->fetchMicroop(pcState.microPC());
+    }
+
+    //If we decoded an instruction this "tick", record information about it.
+    if (curStaticInst) {
+#if TRACING_ON
+        traceData = tracer->getInstRecord(curTick(), tc,
+                curStaticInst, thread->pcState(), curMacroStaticInst);
+
+        DPRINTF(Decode,"Decode: Decoded %s instruction: %#x\n",
+                curStaticInst->getName(), curStaticInst->machInst);
+#endif // TRACING_ON
+    }
+}
+
+void
+BaseDeadCPU::postExecute()
+{
+    assert(curStaticInst);
+
+    TheISA::PCState pc = tc->pcState();
+    Addr instAddr = pc.instAddr();
+    if (FullSystem && thread->profile) {
+        bool usermode = TheISA::inUserMode(tc);
+        thread->profilePC = usermode ? 1 : instAddr;
+        ProfileNode *node = thread->profile->consume(tc, curStaticInst);
+        if (node)
+            thread->profileNode = node;
+    }
+
+    if (curStaticInst->isMemRef()) {
+        numMemRefs++;
+    }
+
+    if (curStaticInst->isLoad()) {
+        ++numLoad;
+        comLoadEventQueue[0]->serviceEvents(numLoad);
+    }
+
+    if (CPA::available()) {
+        CPA::cpa()->swAutoBegin(tc, pc.nextInstAddr());
+    }
+
+    /* Power model statistics */
+    //integer alu accesses
+    if (curStaticInst->isInteger()){
+        numIntAluAccesses++;
+        numIntInsts++;
+    }
+
+    //float alu accesses
+    if (curStaticInst->isFloating()){
+        numFpAluAccesses++;
+        numFpInsts++;
+    }
+    
+    //number of function calls/returns to get window accesses
+    if (curStaticInst->isCall() || curStaticInst->isReturn()){
+        numCallsReturns++;
+    }
+    
+    //the number of branch predictions that will be made
+    if (curStaticInst->isCondCtrl()){
+        numCondCtrlInsts++;
+    }
+    
+    //result bus acceses
+    if (curStaticInst->isLoad()){
+        numLoadInsts++;
+    }
+    
+    if (curStaticInst->isStore()){
+        numStoreInsts++;
+    }
+    /* End power model statistics */
+
+    if (FullSystem)
+        traceFunctions(instAddr);
+
+    if (traceData) {
+        traceData->dump();
+        delete traceData;
+        traceData = NULL;
+    }
+}
+
+
+void
+BaseDeadCPU::advancePC(Fault fault)
+{
+    //Since we're moving to a new pc, zero out the offset
+    fetchOffset = 0;
+    if (fault != NoFault) {
+        curMacroStaticInst = StaticInst::nullStaticInstPtr;
+        fault->invoke(tc, curStaticInst);
+        thread->decoder.reset();
+    } else {
+        if (curStaticInst) {
+            if (curStaticInst->isLastMicroop())
+                curMacroStaticInst = StaticInst::nullStaticInstPtr;
+            TheISA::PCState pcState = thread->pcState();
+            TheISA::advancePC(pcState, curStaticInst);
+            thread->pcState(pcState);
+        }
+    }
+}
+
+void
+BaseDeadCPU::startup()
+{
+    BaseCPU::startup();
+    thread->startup();
+}
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/base.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/base.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,431 @@
+/*
+ * Copyright (c) 2011-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ *          Dave Greene
+ *          Nathan Binkert
+ */
+
+#ifndef __CPU_DEAD_BASE_HH__
+#define __CPU_DEAD_BASE_HH__
+
+#include "base/statistics.hh"
+#include "config/the_isa.hh"
+#include "cpu/base.hh"
+#include "cpu/checker/cpu.hh"
+#include "cpu/pc_event.hh"
+#include "cpu/simple_thread.hh"
+#include "cpu/static_inst.hh"
+#include "mem/packet.hh"
+#include "mem/port.hh"
+#include "mem/request.hh"
+#include "sim/eventq.hh"
+#include "sim/full_system.hh"
+#include "sim/system.hh"
+
+// forward declarations
+class Checkpoint;
+class Process;
+class Processor;
+class ThreadContext;
+
+namespace TheISA
+{
+    class DTB;
+    class ITB;
+}
+
+namespace Trace {
+    class InstRecord;
+}
+
+struct BaseDeadCPUParams;
+
+
+class BaseDeadCPU : public BaseCPU
+{
+  protected:
+    typedef TheISA::MiscReg MiscReg;
+    typedef TheISA::FloatReg FloatReg;
+    typedef TheISA::FloatRegBits FloatRegBits;
+
+  protected:
+    Trace::InstRecord *traceData;
+
+    inline void checkPcEventQueue() {
+        Addr oldpc, pc = thread->instAddr();
+        do {
+            oldpc = pc;
+            system->pcEventQueue.service(tc);
+            pc = thread->instAddr();
+        } while (oldpc != pc);
+    }
+
+  public:
+    void wakeup();
+
+    void zero_fill_64(Addr addr) {
+      static int warned = 0;
+      if (!warned) {
+        warn ("WH64 is not implemented");
+        warned = 1;
+      }
+    };
+
+  public:
+    BaseDeadCPU(BaseDeadCPUParams *params);
+    virtual ~BaseDeadCPU();
+
+  public:
+    /** DeadThread object, provides all the architectural state. */
+    SimpleThread *thread;
+
+    /** ThreadContext object, provides an interface for external
+     * objects to modify this thread's state.
+     */
+    ThreadContext *tc;
+
+    CheckerCPU *checker;
+
+  protected:
+
+    enum Status {
+        Idle,
+        Running,
+        Faulting,
+        ITBWaitResponse,
+        IcacheRetry,
+        IcacheWaitResponse,
+        IcacheWaitSwitch,
+        DTBWaitResponse,
+        DcacheRetry,
+        DcacheWaitResponse,
+        DcacheWaitSwitch,
+    };
+
+    Status _status;
+
+  public:
+
+    Addr dbg_vtophys(Addr addr);
+
+    bool interval_stats;
+
+    // current instruction
+    TheISA::MachInst inst;
+
+    StaticInstPtr curStaticInst;
+    StaticInstPtr curMacroStaticInst;
+
+    //This is the offset from the current pc that fetch should be performed at
+    Addr fetchOffset;
+    //This flag says to stay at the current pc. This is useful for
+    //instructions which go beyond MachInst boundaries.
+    bool stayAtPC;
+
+    void checkForInterrupts();
+    void setupFetchRequest(Request *req);
+    void preExecute();
+    void postExecute();
+    void advancePC(Fault fault);
+
+    virtual void deallocateContext(ThreadID thread_num);
+    virtual void haltContext(ThreadID thread_num);
+
+    // statistics
+    virtual void regStats();
+    virtual void resetStats();
+
+    virtual void startup();
+
+    // number of simulated instructions
+    Counter numInst;
+    Counter startNumInst;
+    Stats::Scalar numInsts;
+    Counter numOp;
+    Counter startNumOp;
+    Stats::Scalar numOps;
+
+    void countInst()
+    {
+        if (!curStaticInst->isMicroop() || curStaticInst->isLastMicroop()) {
+            numInst++;
+            numInsts++;
+        }
+        numOp++;
+        numOps++;
+
+        system->totalNumInsts++;
+        thread->funcExeInst++;
+    }
+
+    virtual Counter totalInsts() const
+    {
+        return numInst - startNumInst;
+    }
+
+    virtual Counter totalOps() const
+    {
+        return numOp - startNumOp;
+    }
+
+    //number of integer alu accesses
+    Stats::Scalar numIntAluAccesses;
+
+    //number of float alu accesses
+    Stats::Scalar numFpAluAccesses;
+
+    //number of function calls/returns
+    Stats::Scalar numCallsReturns;
+
+    //conditional control instructions;
+    Stats::Scalar numCondCtrlInsts;
+
+    //number of int instructions
+    Stats::Scalar numIntInsts;
+
+    //number of float instructions
+    Stats::Scalar numFpInsts;
+
+    //number of integer register file accesses
+    Stats::Scalar numIntRegReads;
+    Stats::Scalar numIntRegWrites;
+
+    //number of float register file accesses
+    Stats::Scalar numFpRegReads;
+    Stats::Scalar numFpRegWrites;
+
+    // number of simulated memory references
+    Stats::Scalar numMemRefs;
+    Stats::Scalar numLoadInsts;
+    Stats::Scalar numStoreInsts;
+
+    // number of idle cycles
+    Stats::Formula numIdleCycles;
+
+    // number of busy cycles
+    Stats::Formula numBusyCycles;
+
+    // number of simulated loads
+    Counter numLoad;
+    Counter startNumLoad;
+
+    // number of idle cycles
+    Stats::Average notIdleFraction;
+    Stats::Formula idleFraction;
+
+    // number of cycles stalled for I-cache responses
+    Stats::Scalar icacheStallCycles;
+    Counter lastIcacheStall;
+
+    // number of cycles stalled for I-cache retries
+    Stats::Scalar icacheRetryCycles;
+    Counter lastIcacheRetry;
+
+    // number of cycles stalled for D-cache responses
+    Stats::Scalar dcacheStallCycles;
+    Counter lastDcacheStall;
+
+    // number of cycles stalled for D-cache retries
+    Stats::Scalar dcacheRetryCycles;
+    Counter lastDcacheRetry;
+
+    void serializeThread(std::ostream &os, ThreadID tid);
+    void unserializeThread(Checkpoint *cp, const std::string &section,
+                           ThreadID tid);
+
+    // These functions are only used in CPU models that split
+    // effective address computation from the actual memory access.
+    void setEA(Addr EA) { panic("BaseDeadCPU::setEA() not implemented\n"); }
+    Addr getEA()        { panic("BaseDeadCPU::getEA() not implemented\n");
+        M5_DUMMY_RETURN}
+
+    // The register accessor methods provide the index of the
+    // instruction's operand (e.g., 0 or 1), not the architectural
+    // register index, to simplify the implementation of register
+    // renaming.  We find the architectural register index by indexing
+    // into the instruction's own operand index table.  Note that a
+    // raw pointer to the StaticInst is provided instead of a
+    // ref-counted StaticInstPtr to redice overhead.  This is fine as
+    // long as these methods don't copy the pointer into any long-term
+    // storage (which is pretty hard to imagine they would have reason
+    // to do).
+
+    uint64_t readIntRegOperand(const StaticInst *si, int idx)
+    {
+        numIntRegReads++;
+        return thread->readIntReg(si->srcRegIdx(idx));
+    }
+
+    FloatReg readFloatRegOperand(const StaticInst *si, int idx)
+    {
+        numFpRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatReg(reg_idx);
+    }
+
+    FloatRegBits readFloatRegOperandBits(const StaticInst *si, int idx)
+    {
+        numFpRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatRegBits(reg_idx);
+    }
+
+    void setIntRegOperand(const StaticInst *si, int idx, uint64_t val)
+    {
+        numIntRegWrites++;
+        thread->setIntReg(si->destRegIdx(idx), val);
+    }
+
+    void setFloatRegOperand(const StaticInst *si, int idx, FloatReg val)
+    {
+        numFpRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        thread->setFloatReg(reg_idx, val);
+    }
+
+    void setFloatRegOperandBits(const StaticInst *si, int idx,
+                                FloatRegBits val)
+    {
+        numFpRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        thread->setFloatRegBits(reg_idx, val);
+    }
+
+    bool readPredicate() { return thread->readPredicate(); }
+    void setPredicate(bool val)
+    {
+        thread->setPredicate(val);
+        if (traceData) {
+            traceData->setPredicate(val);
+        }
+    }
+    TheISA::PCState pcState() { return thread->pcState(); }
+    void pcState(const TheISA::PCState &val) { thread->pcState(val); }
+    Addr instAddr() { return thread->instAddr(); }
+    Addr nextInstAddr() { return thread->nextInstAddr(); }
+    MicroPC microPC() { return thread->microPC(); }
+
+    MiscReg readMiscRegNoEffect(int misc_reg)
+    {
+        return thread->readMiscRegNoEffect(misc_reg);
+    }
+
+    MiscReg readMiscReg(int misc_reg)
+    {
+        numIntRegReads++;
+        return thread->readMiscReg(misc_reg);
+    }
+
+    void setMiscReg(int misc_reg, const MiscReg &val)
+    {
+        numIntRegWrites++;
+        return thread->setMiscReg(misc_reg, val);
+    }
+
+    MiscReg readMiscRegOperand(const StaticInst *si, int idx)
+    {
+        numIntRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::Ctrl_Base_DepTag;
+        return thread->readMiscReg(reg_idx);
+    }
+
+    void setMiscRegOperand(
+            const StaticInst *si, int idx, const MiscReg &val)
+    {
+        numIntRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::Ctrl_Base_DepTag;
+        return thread->setMiscReg(reg_idx, val);
+    }
+
+    void demapPage(Addr vaddr, uint64_t asn)
+    {
+        thread->demapPage(vaddr, asn);
+    }
+
+    void demapInstPage(Addr vaddr, uint64_t asn)
+    {
+        thread->demapInstPage(vaddr, asn);
+    }
+
+    void demapDataPage(Addr vaddr, uint64_t asn)
+    {
+        thread->demapDataPage(vaddr, asn);
+    }
+
+    unsigned readStCondFailures() {
+        return thread->readStCondFailures();
+    }
+
+    void setStCondFailures(unsigned sc_failures) {
+        thread->setStCondFailures(sc_failures);
+    }
+
+     MiscReg readRegOtherThread(int regIdx, ThreadID tid = InvalidThreadID)
+     {
+        panic("Dead CPU models do not support multithreaded "
+              "register access.\n");
+     }
+
+     void setRegOtherThread(int regIdx, const MiscReg &val,
+                            ThreadID tid = InvalidThreadID)
+     {
+        panic("Dead CPU models do not support multithreaded "
+              "register access.\n");
+     }
+
+    //Fault CacheOp(uint8_t Op, Addr EA);
+
+    Fault hwrei() { return thread->hwrei(); }
+    bool simPalCheck(int palFunc) { return thread->simPalCheck(palFunc); }
+
+    void
+    syscall(int64_t callnum)
+    {
+        if (FullSystem)
+            panic("Syscall emulation isn't available in FS mode.\n");
+
+        thread->syscall(callnum);
+    }
+
+    bool misspeculating() { return thread->misspeculating(); }
+    ThreadContext *tcBase() { return tc; }
+};
+
+#endif // __CPU_DEAD_BASE_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/timing.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/timing.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,918 @@
+/*
+ * Copyright (c) 2010-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+#include "arch/locked_mem.hh"
+#include "arch/mmapped_ipr.hh"
+#include "arch/utility.hh"
+#include "base/bigint.hh"
+#include "config/the_isa.hh"
+#include "cpu/deadTiming/timing.hh"
+#include "cpu/exetrace.hh"
+#include "debug/Config.hh"
+#include "debug/Drain.hh"
+#include "debug/ExecFaulting.hh"
+#include "debug/DeadCPU.hh"
+#include "mem/packet.hh"
+#include "mem/packet_access.hh"
+#include "params/TimingDeadCPU.hh"
+#include "sim/faults.hh"
+#include "sim/full_system.hh"
+#include "sim/system.hh"
+
+using namespace std;
+using namespace TheISA;
+
+void
+TimingDeadCPU::init()
+{
+    BaseCPU::init();
+
+    // Initialise the ThreadContext's memory proxies
+    tcBase()->initMemProxies(tcBase());
+
+    if (FullSystem && !params()->switched_out) {
+        for (int i = 0; i < threadContexts.size(); ++i) {
+            ThreadContext *tc = threadContexts[i];
+            // initialize CPU, including PC
+            TheISA::initCPU(tc, _cpuId);
+        }
+    }
+}
+
+void
+TimingDeadCPU::TimingCPUPort::TickEvent::schedule(PacketPtr _pkt, Tick t)
+{
+    pkt = _pkt;
+    cpu->schedule(this, t);
+}
+
+TimingDeadCPU::TimingDeadCPU(TimingDeadCPUParams *p)
+    : BaseDeadCPU(p), fetchTranslation(this), icachePort(this),
+      dcachePort(this), ifetch_pkt(NULL), dcache_pkt(NULL), previousCycle(0),
+      fetchEvent(this), drainManager(NULL)
+{
+    _status = Idle;
+
+    system->totalNumInsts = 0;
+}
+
+
+TimingDeadCPU::~TimingDeadCPU()
+{
+}
+
+unsigned int
+TimingDeadCPU::drain(DrainManager *drain_manager)
+{
+    assert(!drainManager);
+    if (switchedOut())
+        return 0;
+
+    if (_status == Idle ||
+        (_status == BaseDeadCPU::Running && isDrained())) {
+        assert(!fetchEvent.scheduled());
+        DPRINTF(Drain, "No need to drain.\n");
+        return 0;
+    } else {
+        drainManager = drain_manager;
+        DPRINTF(Drain, "Requesting drain: %s\n", pcState());
+
+        // The fetch event can become descheduled if a drain didn't
+        // succeed on the first attempt. We need to reschedule it if
+        // the CPU is waiting for a microcode routine to complete.
+        if (_status == BaseDeadCPU::Running && !fetchEvent.scheduled())
+            schedule(fetchEvent, clockEdge());
+
+        return 1;
+    }
+}
+
+void
+TimingDeadCPU::drainResume()
+{
+    assert(!fetchEvent.scheduled());
+    assert(!drainManager);
+    if (switchedOut())
+        return;
+
+    DPRINTF(DeadCPU, "Resume\n");
+    verifyMemoryMode();
+
+    assert(!threadContexts.empty());
+    if (threadContexts.size() > 1)
+        fatal("The timing CPU only supports one thread.\n");
+
+    if (thread->status() == ThreadContext::Active) {
+        schedule(fetchEvent, nextCycle());
+        _status = BaseDeadCPU::Running;
+    } else {
+        _status = BaseDeadCPU::Idle;
+    }
+}
+
+bool
+TimingDeadCPU::tryCompleteDrain()
+{
+    if (!drainManager)
+        return false;
+
+    DPRINTF(Drain, "tryCompleteDrain: %s\n", pcState());
+    if (!isDrained())
+        return false;
+
+    DPRINTF(Drain, "CPU done draining, processing drain event\n");
+    drainManager->signalDrainDone();
+    drainManager = NULL;
+
+    return true;
+}
+
+void
+TimingDeadCPU::switchOut()
+{
+    BaseDeadCPU::switchOut();
+
+    assert(!fetchEvent.scheduled());
+    assert(_status == BaseDeadCPU::Running || _status == Idle);
+    assert(!stayAtPC);
+    assert(microPC() == 0);
+
+    numCycles += curCycle() - previousCycle;
+}
+
+
+void
+TimingDeadCPU::takeOverFrom(BaseCPU *oldCPU)
+{
+    BaseDeadCPU::takeOverFrom(oldCPU);
+
+    previousCycle = curCycle();
+}
+
+void
+TimingDeadCPU::verifyMemoryMode() const
+{
+    if (!system->isTimingMode()) {
+        fatal("The timing CPU requires the memory system to be in "
+              "'timing' mode.\n");
+    }
+}
+
+void
+TimingDeadCPU::activateContext(ThreadID thread_num, Cycles delay)
+{
+    DPRINTF(DeadCPU, "ActivateContext %d (%d cycles)\n", thread_num, delay);
+
+    assert(thread_num == 0);
+    assert(thread);
+
+    assert(_status == Idle);
+
+    notIdleFraction++;
+    _status = BaseDeadCPU::Running;
+
+    // kick things off by initiating the fetch of the next instruction
+    schedule(fetchEvent, clockEdge(delay));
+}
+
+
+void
+TimingDeadCPU::suspendContext(ThreadID thread_num)
+{
+    DPRINTF(DeadCPU, "SuspendContext %d\n", thread_num);
+
+    assert(thread_num == 0);
+    assert(thread);
+
+    if (_status == Idle)
+        return;
+
+    assert(_status == BaseDeadCPU::Running);
+
+    // just change status to Idle... if status != Running,
+    // completeInst() will not initiate fetch of next instruction.
+
+    notIdleFraction--;
+    _status = Idle;
+}
+
+bool
+TimingDeadCPU::handleReadPacket(PacketPtr pkt)
+{
+    RequestPtr req = pkt->req;
+    if (req->isMmappedIpr()) {
+        Cycles delay = TheISA::handleIprRead(thread->getTC(), pkt);
+        new IprEvent(pkt, this, clockEdge(delay));
+        _status = DcacheWaitResponse;
+        dcache_pkt = NULL;
+    } else if (!dcachePort.sendTimingReq(pkt)) {
+        _status = DcacheRetry;
+        dcache_pkt = pkt;
+    } else {
+        _status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        dcache_pkt = NULL;
+    }
+    return dcache_pkt == NULL;
+}
+
+void
+TimingDeadCPU::sendData(RequestPtr req, uint8_t *data, uint64_t *res,
+                          bool read)
+{
+    PacketPtr pkt;
+    buildPacket(pkt, req, read);
+    pkt->dataDynamicArray<uint8_t>(data);
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        assert(!dcache_pkt);
+        pkt->makeResponse();
+        completeDataAccess(pkt);
+    } else if (read) {
+        handleReadPacket(pkt);
+    } else {
+        bool do_access = true;  // flag to suppress cache access
+
+        if (req->isLLSC()) {
+            do_access = TheISA::handleLockedWrite(thread, req);
+        } else if (req->isCondSwap()) {
+            assert(res);
+            req->setExtraData(*res);
+        }
+
+        if (do_access) {
+            dcache_pkt = pkt;
+            handleWritePacket();
+        } else {
+            _status = DcacheWaitResponse;
+            completeDataAccess(pkt);
+        }
+    }
+}
+
+void
+TimingDeadCPU::sendSplitData(RequestPtr req1, RequestPtr req2,
+                               RequestPtr req, uint8_t *data, bool read)
+{
+    PacketPtr pkt1, pkt2;
+    buildSplitPacket(pkt1, pkt2, req1, req2, req, data, read);
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        assert(!dcache_pkt);
+        pkt1->makeResponse();
+        completeDataAccess(pkt1);
+    } else if (read) {
+        SplitFragmentSenderState * send_state =
+            dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
+        if (handleReadPacket(pkt1)) {
+            send_state->clearFromParent();
+            send_state = dynamic_cast<SplitFragmentSenderState *>(
+                    pkt2->senderState);
+            if (handleReadPacket(pkt2)) {
+                send_state->clearFromParent();
+            }
+        }
+    } else {
+        dcache_pkt = pkt1;
+        SplitFragmentSenderState * send_state =
+            dynamic_cast<SplitFragmentSenderState *>(pkt1->senderState);
+        if (handleWritePacket()) {
+            send_state->clearFromParent();
+            dcache_pkt = pkt2;
+            send_state = dynamic_cast<SplitFragmentSenderState *>(
+                    pkt2->senderState);
+            if (handleWritePacket()) {
+                send_state->clearFromParent();
+            }
+        }
+    }
+}
+
+void
+TimingDeadCPU::translationFault(Fault fault)
+{
+    // fault may be NoFault in cases where a fault is suppressed,
+    // for instance prefetches.
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    if (traceData) {
+        // Since there was a fault, we shouldn't trace this instruction.
+        delete traceData;
+        traceData = NULL;
+    }
+
+    postExecute();
+
+    advanceInst(fault);
+}
+
+void
+TimingDeadCPU::buildPacket(PacketPtr &pkt, RequestPtr req, bool read)
+{
+    MemCmd cmd;
+    if (read) {
+        cmd = MemCmd::ReadReq;
+        if (req->isLLSC())
+            cmd = MemCmd::LoadLockedReq;
+    } else {
+        cmd = MemCmd::WriteReq;
+        if (req->isLLSC()) {
+            cmd = MemCmd::StoreCondReq;
+        } else if (req->isSwap()) {
+            cmd = MemCmd::SwapReq;
+        }
+    }
+    pkt = new Packet(req, cmd);
+}
+
+void
+TimingDeadCPU::buildSplitPacket(PacketPtr &pkt1, PacketPtr &pkt2,
+        RequestPtr req1, RequestPtr req2, RequestPtr req,
+        uint8_t *data, bool read)
+{
+    pkt1 = pkt2 = NULL;
+
+    assert(!req1->isMmappedIpr() && !req2->isMmappedIpr());
+
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        buildPacket(pkt1, req, read);
+        return;
+    }
+
+    buildPacket(pkt1, req1, read);
+    buildPacket(pkt2, req2, read);
+
+    req->setPhys(req1->getPaddr(), req->getSize(), req1->getFlags(), dataMasterId());
+    PacketPtr pkt = new Packet(req, pkt1->cmd.responseCommand());
+
+    pkt->dataDynamicArray<uint8_t>(data);
+    pkt1->dataStatic<uint8_t>(data);
+    pkt2->dataStatic<uint8_t>(data + req1->getSize());
+
+    SplitMainSenderState * main_send_state = new SplitMainSenderState;
+    pkt->senderState = main_send_state;
+    main_send_state->fragments[0] = pkt1;
+    main_send_state->fragments[1] = pkt2;
+    main_send_state->outstanding = 2;
+    pkt1->senderState = new SplitFragmentSenderState(pkt, 0);
+    pkt2->senderState = new SplitFragmentSenderState(pkt, 1);
+}
+
+Fault
+TimingDeadCPU::readMem(Addr addr, uint8_t *data,
+                         unsigned size, unsigned flags)
+{
+    Fault fault;
+    const int asid = 0;
+    const ThreadID tid = 0;
+    const Addr pc = thread->instAddr();
+    unsigned block_size = cacheLineSize();
+    BaseTLB::Mode mode = BaseTLB::Read;
+
+    if (traceData) {
+        traceData->setAddr(addr);
+    }
+
+    RequestPtr req  = new Request(asid, addr, size,
+                                  flags, dataMasterId(), pc, _cpuId, tid);
+
+    Addr split_addr = roundDown(addr + size - 1, block_size);
+    assert(split_addr <= addr || split_addr - addr < block_size);
+
+    _status = DTBWaitResponse;
+    if (split_addr > addr) {
+        RequestPtr req1, req2;
+        assert(!req->isLLSC() && !req->isSwap());
+        req->splitOnVaddr(split_addr, req1, req2);
+
+        WholeTranslationState *state =
+            new WholeTranslationState(req, req1, req2, new uint8_t[size],
+                                      NULL, mode);
+        DataTranslation<TimingDeadCPU *> *trans1 =
+            new DataTranslation<TimingDeadCPU *>(this, state, 0);
+        DataTranslation<TimingDeadCPU *> *trans2 =
+            new DataTranslation<TimingDeadCPU *>(this, state, 1);
+
+        thread->dtb->translateTiming(req1, tc, trans1, mode);
+        thread->dtb->translateTiming(req2, tc, trans2, mode);
+    } else {
+        WholeTranslationState *state =
+            new WholeTranslationState(req, new uint8_t[size], NULL, mode);
+        DataTranslation<TimingDeadCPU *> *translation
+            = new DataTranslation<TimingDeadCPU *>(this, state);
+        thread->dtb->translateTiming(req, tc, translation, mode);
+    }
+
+    return NoFault;
+}
+
+bool
+TimingDeadCPU::handleWritePacket()
+{
+    RequestPtr req = dcache_pkt->req;
+    if (req->isMmappedIpr()) {
+        Cycles delay = TheISA::handleIprWrite(thread->getTC(), dcache_pkt);
+        new IprEvent(dcache_pkt, this, clockEdge(delay));
+        _status = DcacheWaitResponse;
+        dcache_pkt = NULL;
+    } else if (!dcachePort.sendTimingReq(dcache_pkt)) {
+        _status = DcacheRetry;
+    } else {
+        _status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        dcache_pkt = NULL;
+    }
+    return dcache_pkt == NULL;
+}
+
+Fault
+TimingDeadCPU::writeMem(uint8_t *data, unsigned size,
+                          Addr addr, unsigned flags, uint64_t *res)
+{
+    uint8_t *newData = new uint8_t[size];
+    memcpy(newData, data, size);
+
+    const int asid = 0;
+    const ThreadID tid = 0;
+    const Addr pc = thread->instAddr();
+    unsigned block_size = cacheLineSize();
+    BaseTLB::Mode mode = BaseTLB::Write;
+
+    if (traceData) {
+        traceData->setAddr(addr);
+    }
+
+    RequestPtr req = new Request(asid, addr, size,
+                                 flags, dataMasterId(), pc, _cpuId, tid);
+
+    Addr split_addr = roundDown(addr + size - 1, block_size);
+    assert(split_addr <= addr || split_addr - addr < block_size);
+
+    _status = DTBWaitResponse;
+    if (split_addr > addr) {
+        RequestPtr req1, req2;
+        assert(!req->isLLSC() && !req->isSwap());
+        req->splitOnVaddr(split_addr, req1, req2);
+
+        WholeTranslationState *state =
+            new WholeTranslationState(req, req1, req2, newData, res, mode);
+        DataTranslation<TimingDeadCPU *> *trans1 =
+            new DataTranslation<TimingDeadCPU *>(this, state, 0);
+        DataTranslation<TimingDeadCPU *> *trans2 =
+            new DataTranslation<TimingDeadCPU *>(this, state, 1);
+
+        thread->dtb->translateTiming(req1, tc, trans1, mode);
+        thread->dtb->translateTiming(req2, tc, trans2, mode);
+    } else {
+        WholeTranslationState *state =
+            new WholeTranslationState(req, newData, res, mode);
+        DataTranslation<TimingDeadCPU *> *translation =
+            new DataTranslation<TimingDeadCPU *>(this, state);
+        thread->dtb->translateTiming(req, tc, translation, mode);
+    }
+
+    // Translation faults will be returned via finishTranslation()
+    return NoFault;
+}
+
+
+void
+TimingDeadCPU::finishTranslation(WholeTranslationState *state)
+{
+    _status = BaseDeadCPU::Running;
+
+    if (state->getFault() != NoFault) {
+        if (state->isPrefetch()) {
+            state->setNoFault();
+        }
+        delete [] state->data;
+        state->deleteReqs();
+        translationFault(state->getFault());
+    } else {
+        if (!state->isSplit) {
+            sendData(state->mainReq, state->data, state->res,
+                     state->mode == BaseTLB::Read);
+        } else {
+            sendSplitData(state->sreqLow, state->sreqHigh, state->mainReq,
+                          state->data, state->mode == BaseTLB::Read);
+        }
+    }
+
+    delete state;
+}
+
+
+void
+TimingDeadCPU::fetch()
+{
+    DPRINTF(DeadCPU, "Fetch\n");
+
+    if (!curStaticInst || !curStaticInst->isDelayedCommit())
+        checkForInterrupts();
+
+    checkPcEventQueue();
+
+    // We must have just got suspended by a PC event
+    if (_status == Idle)
+        return;
+
+    TheISA::PCState pcState = thread->pcState();
+    bool needToFetch = !isRomMicroPC(pcState.microPC()) && !curMacroStaticInst;
+
+    if (needToFetch) {
+        _status = BaseDeadCPU::Running;
+        Request *ifetch_req = new Request();
+        ifetch_req->setThreadContext(_cpuId, /* thread ID */ 0);
+        setupFetchRequest(ifetch_req);
+        DPRINTF(DeadCPU, "Translating address %#x\n", ifetch_req->getVaddr());
+        thread->itb->translateTiming(ifetch_req, tc, &fetchTranslation,
+                BaseTLB::Execute);
+    } else {
+        _status = IcacheWaitResponse;
+        completeIfetch(NULL);
+
+        numCycles += curCycle() - previousCycle;
+        previousCycle = curCycle();
+    }
+}
+
+
+void
+TimingDeadCPU::sendFetch(Fault fault, RequestPtr req, ThreadContext *tc)
+{
+    if (fault == NoFault) {
+        DPRINTF(DeadCPU, "Sending fetch for addr %#x(pa: %#x)\n",
+                req->getVaddr(), req->getPaddr());
+        ifetch_pkt = new Packet(req, MemCmd::ReadReq);
+        ifetch_pkt->dataStatic(&inst);
+        DPRINTF(DeadCPU, " -- pkt addr: %#x\n", ifetch_pkt->getAddr());
+
+        if (!icachePort.sendTimingReq(ifetch_pkt)) {
+            // Need to wait for retry
+            _status = IcacheRetry;
+        } else {
+            // Need to wait for cache to respond
+            _status = IcacheWaitResponse;
+            // ownership of packet transferred to memory system
+            ifetch_pkt = NULL;
+        }
+    } else {
+        DPRINTF(DeadCPU, "Translation of addr %#x faulted\n", req->getVaddr());
+        delete req;
+        // fetch fault: advance directly to next instruction (fault handler)
+        _status = BaseDeadCPU::Running;
+        advanceInst(fault);
+    }
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+}
+
+
+void
+TimingDeadCPU::advanceInst(Fault fault)
+{
+    if (_status == Faulting)
+        return;
+
+    if (fault != NoFault) {
+        advancePC(fault);
+        DPRINTF(DeadCPU, "Fault occured, scheduling fetch event\n");
+        reschedule(fetchEvent, clockEdge(), true);
+        _status = Faulting;
+        return;
+    }
+
+
+    if (!stayAtPC)
+        advancePC(fault);
+
+    if (tryCompleteDrain())
+            return;
+
+    if (_status == BaseDeadCPU::Running) {
+        // kick off fetch of next instruction... callback from icache
+        // response will cause that instruction to be executed,
+        // keeping the CPU running.
+        fetch();
+    }
+}
+
+
+void
+TimingDeadCPU::completeIfetch(PacketPtr pkt)
+{
+    DPRINTF(DeadCPU, "Complete ICache Fetch for addr %#x\n", pkt ?
+            pkt->getAddr() : 0);
+
+    // received a response from the icache: execute the received
+    // instruction
+
+    assert(!pkt || !pkt->isError());
+    assert(_status == IcacheWaitResponse);
+
+    _status = BaseDeadCPU::Running;
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    preExecute();
+    if (curStaticInst && curStaticInst->isMemRef()) {
+        // load or store: just send to dcache
+        Fault fault = curStaticInst->initiateAcc(this, traceData);
+
+        // If we're not running now the instruction will complete in a dcache
+        // response callback or the instruction faulted and has started an
+        // ifetch
+        if (_status == BaseDeadCPU::Running) {
+            if (fault != NoFault && traceData) {
+                // If there was a fault, we shouldn't trace this instruction.
+                delete traceData;
+                traceData = NULL;
+            }
+
+            postExecute();
+            // @todo remove me after debugging with legion done
+            if (curStaticInst && (!curStaticInst->isMicroop() ||
+                        curStaticInst->isFirstMicroop()))
+                instCnt++;
+            advanceInst(fault);
+        }
+    } else if (curStaticInst) {
+        // non-memory instruction: execute completely now
+        Fault fault = curStaticInst->execute(this, traceData);
+
+        // keep an instruction count
+        if (fault == NoFault)
+            countInst();
+        else if (traceData && !DTRACE(ExecFaulting)) {
+            delete traceData;
+            traceData = NULL;
+        }
+
+        postExecute();
+        // @todo remove me after debugging with legion done
+        if (curStaticInst && (!curStaticInst->isMicroop() ||
+                    curStaticInst->isFirstMicroop()))
+            instCnt++;
+        advanceInst(fault);
+    } else {
+        advanceInst(NoFault);
+    }
+
+    if (pkt) {
+        delete pkt->req;
+        delete pkt;
+    }
+}
+
+void
+TimingDeadCPU::IcachePort::ITickEvent::process()
+{
+    cpu->completeIfetch(pkt);
+}
+
+bool
+TimingDeadCPU::IcachePort::recvTimingResp(PacketPtr pkt)
+{
+    DPRINTF(DeadCPU, "Received timing response %#x\n", pkt->getAddr());
+    // delay processing of returned data until next CPU clock edge
+    Tick next_tick = cpu->clockEdge();
+
+    if (next_tick == curTick())
+        cpu->completeIfetch(pkt);
+    else
+        tickEvent.schedule(pkt, next_tick);
+
+    return true;
+}
+
+void
+TimingDeadCPU::IcachePort::recvRetry()
+{
+    // we shouldn't get a retry unless we have a packet that we're
+    // waiting to transmit
+    assert(cpu->ifetch_pkt != NULL);
+    assert(cpu->_status == IcacheRetry);
+    PacketPtr tmp = cpu->ifetch_pkt;
+    if (sendTimingReq(tmp)) {
+        cpu->_status = IcacheWaitResponse;
+        cpu->ifetch_pkt = NULL;
+    }
+}
+
+void
+TimingDeadCPU::completeDataAccess(PacketPtr pkt)
+{
+    // received a response from the dcache: complete the load or store
+    // instruction
+    assert(!pkt->isError());
+    assert(_status == DcacheWaitResponse || _status == DTBWaitResponse ||
+           pkt->req->getFlags().isSet(Request::NO_ACCESS));
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    if (pkt->senderState) {
+        SplitFragmentSenderState * send_state =
+            dynamic_cast<SplitFragmentSenderState *>(pkt->senderState);
+        assert(send_state);
+        delete pkt->req;
+        delete pkt;
+        PacketPtr big_pkt = send_state->bigPkt;
+        delete send_state;
+        
+        SplitMainSenderState * main_send_state =
+            dynamic_cast<SplitMainSenderState *>(big_pkt->senderState);
+        assert(main_send_state);
+        // Record the fact that this packet is no longer outstanding.
+        assert(main_send_state->outstanding != 0);
+        main_send_state->outstanding--;
+
+        if (main_send_state->outstanding) {
+            return;
+        } else {
+            delete main_send_state;
+            big_pkt->senderState = NULL;
+            pkt = big_pkt;
+        }
+    }
+
+    _status = BaseDeadCPU::Running;
+
+    Fault fault = curStaticInst->completeAcc(pkt, this, traceData);
+
+    // keep an instruction count
+    if (fault == NoFault)
+        countInst();
+    else if (traceData) {
+        // If there was a fault, we shouldn't trace this instruction.
+        delete traceData;
+        traceData = NULL;
+    }
+
+    // the locked flag may be cleared on the response packet, so check
+    // pkt->req and not pkt to see if it was a load-locked
+    if (pkt->isRead() && pkt->req->isLLSC()) {
+        TheISA::handleLockedRead(thread, pkt->req);
+    }
+
+    delete pkt->req;
+    delete pkt;
+
+    postExecute();
+
+    advanceInst(fault);
+}
+
+bool
+TimingDeadCPU::DcachePort::recvTimingResp(PacketPtr pkt)
+{
+    // delay processing of returned data until next CPU clock edge
+    Tick next_tick = cpu->clockEdge();
+
+    if (next_tick == curTick()) {
+        cpu->completeDataAccess(pkt);
+    } else {
+        if (!tickEvent.scheduled()) {
+            tickEvent.schedule(pkt, next_tick);
+        } else {
+            // In the case of a split transaction and a cache that is
+            // faster than a CPU we could get two responses before
+            // next_tick expires
+            if (!retryEvent.scheduled())
+                cpu->schedule(retryEvent, next_tick);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+void
+TimingDeadCPU::DcachePort::DTickEvent::process()
+{
+    cpu->completeDataAccess(pkt);
+}
+
+void
+TimingDeadCPU::DcachePort::recvRetry()
+{
+    // we shouldn't get a retry unless we have a packet that we're
+    // waiting to transmit
+    assert(cpu->dcache_pkt != NULL);
+    assert(cpu->_status == DcacheRetry);
+    PacketPtr tmp = cpu->dcache_pkt;
+    if (tmp->senderState) {
+        // This is a packet from a split access.
+        SplitFragmentSenderState * send_state =
+            dynamic_cast<SplitFragmentSenderState *>(tmp->senderState);
+        assert(send_state);
+        PacketPtr big_pkt = send_state->bigPkt;
+        
+        SplitMainSenderState * main_send_state =
+            dynamic_cast<SplitMainSenderState *>(big_pkt->senderState);
+        assert(main_send_state);
+
+        if (sendTimingReq(tmp)) {
+            // If we were able to send without retrying, record that fact
+            // and try sending the other fragment.
+            send_state->clearFromParent();
+            int other_index = main_send_state->getPendingFragment();
+            if (other_index > 0) {
+                tmp = main_send_state->fragments[other_index];
+                cpu->dcache_pkt = tmp;
+                if ((big_pkt->isRead() && cpu->handleReadPacket(tmp)) ||
+                        (big_pkt->isWrite() && cpu->handleWritePacket())) {
+                    main_send_state->fragments[other_index] = NULL;
+                }
+            } else {
+                cpu->_status = DcacheWaitResponse;
+                // memory system takes ownership of packet
+                cpu->dcache_pkt = NULL;
+            }
+        }
+    } else if (sendTimingReq(tmp)) {
+        cpu->_status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        cpu->dcache_pkt = NULL;
+    }
+}
+
+TimingDeadCPU::IprEvent::IprEvent(Packet *_pkt, TimingDeadCPU *_cpu,
+    Tick t)
+    : pkt(_pkt), cpu(_cpu)
+{
+    cpu->schedule(this, t);
+}
+
+void
+TimingDeadCPU::IprEvent::process()
+{
+    cpu->completeDataAccess(pkt);
+}
+
+const char *
+TimingDeadCPU::IprEvent::description() const
+{
+    return "Timing Dead CPU Delay IPR event";
+}
+
+
+void
+TimingDeadCPU::printAddr(Addr a)
+{
+    dcachePort.printAddr(a);
+}
+
+
+////////////////////////////////////////////////////////////////////////
+//
+//  TimingDeadCPU Simulation Object
+//
+TimingDeadCPU *
+TimingDeadCPUParams::create()
+{
+    numThreads = 1;
+    if (!FullSystem && workload.size() != 1)
+        panic("only one workload allowed");
+    return new TimingDeadCPU(this);
+}
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/deadTiming/timing.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/deadTiming/timing.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,345 @@
+/*
+ * Copyright (c) 2012-2013 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+#ifndef __CPU_DEAD_TIMING_HH__
+#define __CPU_DEAD_TIMING_HH__
+
+#include "cpu/deadTiming/base.hh"
+#include "cpu/translation.hh"
+#include "params/TimingDeadCPU.hh"
+
+class TimingDeadCPU : public BaseDeadCPU
+{
+  public:
+
+    TimingDeadCPU(TimingDeadCPUParams * params);
+    virtual ~TimingDeadCPU();
+
+    virtual void init();
+
+  private:
+
+    /*
+     * If an access needs to be broken into fragments, currently at most two,
+     * the the following two classes are used as the sender state of the
+     * packets so the CPU can keep track of everything. In the main packet
+     * sender state, there's an array with a spot for each fragment. If a
+     * fragment has already been accepted by the CPU, aka isn't waiting for
+     * a retry, it's pointer is NULL. After each fragment has successfully
+     * been processed, the "outstanding" counter is decremented. Once the
+     * count is zero, the entire larger access is complete.
+     */
+    class SplitMainSenderState : public Packet::SenderState
+    {
+      public:
+        int outstanding;
+        PacketPtr fragments[2];
+
+        int
+        getPendingFragment()
+        {
+            if (fragments[0]) {
+                return 0;
+            } else if (fragments[1]) {
+                return 1;
+            } else {
+                return -1;
+            }
+        }
+    };
+
+    class SplitFragmentSenderState : public Packet::SenderState
+    {
+      public:
+        SplitFragmentSenderState(PacketPtr _bigPkt, int _index) :
+            bigPkt(_bigPkt), index(_index)
+        {}
+        PacketPtr bigPkt;
+        int index;
+
+        void
+        clearFromParent()
+        {
+            SplitMainSenderState * main_send_state =
+                dynamic_cast<SplitMainSenderState *>(bigPkt->senderState);
+            main_send_state->fragments[index] = NULL;
+        }
+    };
+
+    class FetchTranslation : public BaseTLB::Translation
+    {
+      protected:
+        TimingDeadCPU *cpu;
+
+      public:
+        FetchTranslation(TimingDeadCPU *_cpu)
+            : cpu(_cpu)
+        {}
+
+        void
+        markDelayed()
+        {
+            assert(cpu->_status == BaseDeadCPU::Running);
+            cpu->_status = ITBWaitResponse;
+        }
+
+        void
+        finish(Fault fault, RequestPtr req, ThreadContext *tc,
+               BaseTLB::Mode mode)
+        {
+            cpu->sendFetch(fault, req, tc);
+        }
+    };
+    FetchTranslation fetchTranslation;
+
+    void sendData(RequestPtr req, uint8_t *data, uint64_t *res, bool read);
+    void sendSplitData(RequestPtr req1, RequestPtr req2, RequestPtr req,
+                       uint8_t *data, bool read);
+
+    void translationFault(Fault fault);
+
+    void buildPacket(PacketPtr &pkt, RequestPtr req, bool read);
+    void buildSplitPacket(PacketPtr &pkt1, PacketPtr &pkt2,
+            RequestPtr req1, RequestPtr req2, RequestPtr req,
+            uint8_t *data, bool read);
+
+    bool handleReadPacket(PacketPtr pkt);
+    // This function always implicitly uses dcache_pkt.
+    bool handleWritePacket();
+
+    /**
+     * A TimingCPUPort overrides the default behaviour of the
+     * recvTiming and recvRetry and implements events for the
+     * scheduling of handling of incoming packets in the following
+     * cycle.
+     */
+    class TimingCPUPort : public MasterPort
+    {
+      public:
+
+        TimingCPUPort(const std::string& _name, TimingDeadCPU* _cpu)
+            : MasterPort(_name, _cpu), cpu(_cpu), retryEvent(this)
+        { }
+
+      protected:
+
+        /**
+         * Snooping a coherence request, do nothing.
+         */
+        virtual void recvTimingSnoopReq(PacketPtr pkt) { }
+
+        TimingDeadCPU* cpu;
+
+        struct TickEvent : public Event
+        {
+            PacketPtr pkt;
+            TimingDeadCPU *cpu;
+
+            TickEvent(TimingDeadCPU *_cpu) : pkt(NULL), cpu(_cpu) {}
+            const char *description() const { return "Timing CPU tick"; }
+            void schedule(PacketPtr _pkt, Tick t);
+        };
+
+        EventWrapper<MasterPort, &MasterPort::sendRetry> retryEvent;
+    };
+
+    class IcachePort : public TimingCPUPort
+    {
+      public:
+
+        IcachePort(TimingDeadCPU *_cpu)
+            : TimingCPUPort(_cpu->name() + ".icache_port", _cpu),
+              tickEvent(_cpu)
+        { }
+
+      protected:
+
+        virtual bool recvTimingResp(PacketPtr pkt);
+
+        virtual void recvRetry();
+
+        struct ITickEvent : public TickEvent
+        {
+
+            ITickEvent(TimingDeadCPU *_cpu)
+                : TickEvent(_cpu) {}
+            void process();
+            const char *description() const { return "Timing CPU icache tick"; }
+        };
+
+        ITickEvent tickEvent;
+
+    };
+
+    class DcachePort : public TimingCPUPort
+    {
+      public:
+
+        DcachePort(TimingDeadCPU *_cpu)
+            : TimingCPUPort(_cpu->name() + ".dcache_port", _cpu),
+              tickEvent(_cpu)
+        { }
+
+      protected:
+
+        virtual bool recvTimingResp(PacketPtr pkt);
+
+        virtual void recvRetry();
+
+        struct DTickEvent : public TickEvent
+        {
+            DTickEvent(TimingDeadCPU *_cpu)
+                : TickEvent(_cpu) {}
+            void process();
+            const char *description() const { return "Timing CPU dcache tick"; }
+        };
+
+        DTickEvent tickEvent;
+
+    };
+
+    IcachePort icachePort;
+    DcachePort dcachePort;
+
+    PacketPtr ifetch_pkt;
+    PacketPtr dcache_pkt;
+
+    Tick previousCycle;
+
+  protected:
+
+     /** Return a reference to the data port. */
+    virtual MasterPort &getDataPort() { return dcachePort; }
+
+    /** Return a reference to the instruction port. */
+    virtual MasterPort &getInstPort() { return icachePort; }
+
+  public:
+
+    unsigned int drain(DrainManager *drain_manager);
+    void drainResume();
+
+    void switchOut();
+    void takeOverFrom(BaseCPU *oldCPU);
+
+    void verifyMemoryMode() const;
+
+    virtual void activateContext(ThreadID thread_num, Cycles delay);
+    virtual void suspendContext(ThreadID thread_num);
+
+    Fault readMem(Addr addr, uint8_t *data, unsigned size, unsigned flags);
+
+    Fault writeMem(uint8_t *data, unsigned size,
+                   Addr addr, unsigned flags, uint64_t *res);
+
+    void fetch();
+    void sendFetch(Fault fault, RequestPtr req, ThreadContext *tc);
+    void completeIfetch(PacketPtr );
+    void completeDataAccess(PacketPtr pkt);
+    void advanceInst(Fault fault);
+
+    /** This function is used by the page table walker to determine if it could
+     * translate the a pending request or if the underlying request has been
+     * squashed. This always returns false for the dead timing CPU as it never
+     * executes any instructions speculatively.
+     * @ return Is the current instruction squashed?
+     */
+    bool isSquashed() const { return false; }
+
+    /**
+     * Print state of address in memory system via PrintReq (for
+     * debugging).
+     */
+    void printAddr(Addr a);
+
+    /**
+     * Finish a DTB translation.
+     * @param state The DTB translation state.
+     */
+    void finishTranslation(WholeTranslationState *state);
+
+  private:
+
+    typedef EventWrapper<TimingDeadCPU, &TimingDeadCPU::fetch> FetchEvent;
+    FetchEvent fetchEvent;
+
+    struct IprEvent : Event {
+        Packet *pkt;
+        TimingDeadCPU *cpu;
+        IprEvent(Packet *_pkt, TimingDeadCPU *_cpu, Tick t);
+        virtual void process();
+        virtual const char *description() const;
+    };
+
+    /**
+     * Check if a system is in a drained state.
+     *
+     * We need to drain if:
+     * <ul>
+     * <li>We are in the middle of a microcode sequence as some CPUs
+     *     (e.g., HW accelerated CPUs) can't be started in the middle
+     *     of a gem5 microcode sequence.
+     *
+     * <li>Stay at PC is true.
+     * </ul>
+     */
+    bool isDrained() {
+        return microPC() == 0 &&
+            !stayAtPC;
+    }
+
+    /**
+     * Try to complete a drain request.
+     *
+     * @returns true if the CPU is drained, false otherwise.
+     */
+    bool tryCompleteDrain();
+
+    /**
+     * Drain manager to use when signaling drain completion
+     *
+     * This pointer is non-NULL when draining and NULL otherwise.
+     */
+    DrainManager *drainManager;
+};
+
+#endif // __CPU_DEAD_TIMING_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/BaseHelperCPU.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/BaseHelperCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,48 @@
+# Copyright (c) 2008 The Hewlett-Packard Development Company
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Gabe Black
+
+from m5.defines import buildEnv
+from m5.params import *
+from BaseCPU import BaseCPU
+from DummyChecker import DummyChecker
+
+class BaseHelperCPU(BaseCPU):
+    type = 'BaseHelperCPU'
+    abstract = True
+    cxx_header = "cpu/helper/base.hh"
+
+    def addCheckerCpu(self):
+        if buildEnv['TARGET_ISA'] in ['arm']:
+            from ArmTLB import ArmTLB
+
+            self.checker = DummyChecker(workload = self.workload)
+            self.checker.itb = ArmTLB(size = self.itb.size)
+            self.checker.dtb = ArmTLB(size = self.dtb.size)
+        else:
+            print "ERROR: Checker only supported under ARM ISA!"
+            exit(1)
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/SConscript
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/SConscript	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,47 @@
+# -*- mode:python -*-
+
+# Copyright (c) 2006 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+Import('*')
+
+need_simple_base = False
+#if 'HelperCPU' in env['CPU_MODELS']:
+#    SimObject('HelperCPU.py')
+#    need_simple_base=True
+#    Source('helper.cc')
+if 'TimingHelperCPU' in env['CPU_MODELS']:
+    SimObject('TimingHelperCPU.py')
+    need_simple_base=True
+    Source('repair.cc')
+if need_simple_base:
+    Source('base.cc')
+#    DebugFlag('PH')
+    SimObject('BaseHelperCPU.py')
+
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/SConsopts
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/SConsopts	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,41 @@
+# -*- mode:python -*-
+
+# Copyright (c) 2006 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+Import('*')
+CpuModel('TimingHelperCPU', 'timing_helper_cpu_exec.cc',
+         '#include "cpu/helper/timing.hh"',
+         { 'CPU_exec_context': 'TimingHelperCPU' },
+         default=True)
+
+CpuModel('HelperCPU', 'helper_cpu_exec.cc',
+         '#include "cpu/helper/helper.hh"',
+         { 'CPU_exec_context': 'HelperCPU' },
+         default=True)
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/THelper.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/THelper.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,620 @@
+#include "debug/Squasher.hh"
+#include "debug/SimpleCPU.hh"
+#include "debug/Config.hh"
+#include "debug/Drain.hh"
+#include "debug/ExecFaulting.hh"
+
+
+void
+TimingHelperCPU::init() {
+    BaseCPU::init();
+
+    // Initialise the ThreadContext's memory proxies
+    tcBase()->initMemProxies(tcBase());
+
+    if (FullSystem && !params()->switched_out) {
+        for (int i = 0; i < threadContexts.size(); ++i) {
+            ThreadContext *tc = threadContexts[i];
+            // initialize CPU, including PC
+            TheISA::initCPU(tc, _cpuId);
+        }
+    }
+}
+
+void
+TimingHelperCPU::TimingCPUPort::TickEvent::schedule(PacketPtr _pkt, Tick t) {
+    pkt = _pkt;
+    cpu->schedule(this, t);
+}
+
+TimingHelperCPU::TimingHelperCPU(TimingHelperCPUParams *p)
+: BaseHelperCPU(p), fetchTranslation(this), icachePort(this),
+dcachePort(this), ifetch_pkt(NULL), dcache_pkt(NULL), previousCycle(0),
+fetchEvent(this), cEvent(this),
+drainManager(NULL) {
+    getIOPort();
+    _status = Idle;
+    locked = false;
+    dSend = false;
+    lastTick=0;
+    DPRINTF(Squasher, "TimingHelperCPU instantiated\n");
+    ioh->setHelperCPU(this);
+
+
+    system->totalNumInsts = 0;
+    resetStage();
+}
+
+TimingHelperCPU::~TimingHelperCPU() {
+}
+
+unsigned int
+TimingHelperCPU::drain(DrainManager *drain_manager) {
+    assert(!drainManager);
+    if (switchedOut())
+        return 0;
+
+    if (_status == Idle ||
+            (_status == BaseHelperCPU::Running && isDrained())) {
+        assert(!fetchEvent.scheduled());
+        DPRINTF(Drain, "No need to drain.\n");
+        return 0;
+    } else {
+        drainManager = drain_manager;
+        DPRINTF(Drain, "Requesting drain: %s\n", pcState());
+
+        // The fetch event can become descheduled if a drain didn't
+        // succeed on the first attempt. We need to reschedule it if
+        // the CPU is waiting for a microcode routine to complete.
+        if (_status == BaseHelperCPU::Running && !fetchEvent.scheduled())
+            schedule(fetchEvent, clockEdge());
+
+        return 1;
+    }
+}
+
+void
+TimingHelperCPU::drainResume() {
+    assert(!fetchEvent.scheduled());
+    assert(!drainManager);
+    if (switchedOut())
+        return;
+
+    DPRINTF(SimpleCPU, "Resume\n");
+    printf("Verifying Memory Mode\n");
+    verifyMemoryMode();
+
+    assert(!threadContexts.empty());
+    if (threadContexts.size() > 1)
+        fatal("The timing CPU only supports one thread.\n");
+
+    if (thread->status() == ThreadContext::Active) {
+        _status = BaseHelperCPU::Running;
+    } else {
+        _status = BaseHelperCPU::Idle;
+    }
+}
+
+bool
+TimingHelperCPU::tryCompleteDrain() {
+    if (!drainManager)
+        return false;
+
+    DPRINTF(Drain, "tryCompleteDrain: %s\n", pcState());
+    if (!isDrained())
+        return false;
+
+    DPRINTF(Drain, "CPU done draining, processing drain event\n");
+    drainManager->signalDrainDone();
+    drainManager = NULL;
+
+    return true;
+}
+
+void
+TimingHelperCPU::switchOut() {
+    BaseHelperCPU::switchOut();
+
+    assert(!fetchEvent.scheduled());
+    assert(_status == BaseHelperCPU::Running || _status == Idle);
+    assert(!stayAtPC);
+    assert(microPC() == 0);
+
+    numCycles += curCycle() - previousCycle;
+}
+
+void
+TimingHelperCPU::takeOverFrom(BaseCPU *oldCPU) {
+    BaseHelperCPU::takeOverFrom(oldCPU);
+
+    previousCycle = curCycle();
+}
+
+void
+TimingHelperCPU::verifyMemoryMode() const {
+    if (!system->isTimingMode()) {
+        fatal("The timing CPU requires the memory system to be in "
+                "'timing' mode.\n");
+    }
+}
+
+void
+TimingHelperCPU::activateContext(ThreadID thread_num, Cycles delay) {
+    DPRINTF(SimpleCPU, "ActivateContext %d (%d cycles)\n", thread_num, delay);
+
+    assert(thread_num == 0);
+    assert(thread);
+
+    assert(_status == Idle);
+
+    notIdleFraction++;
+    _status = BaseHelperCPU::Running;
+
+    // kick things off by initiating the fetch of the next instruction
+    schedule(fetchEvent, clockEdge(delay));
+}
+
+void
+TimingHelperCPU::suspendContext(ThreadID thread_num) {
+    DPRINTF(SimpleCPU, "SuspendContext %d\n", thread_num);
+
+    assert(thread_num == 0);
+    assert(thread);
+
+    if (_status == Idle)
+        return;
+
+    assert(_status == BaseHelperCPU::Running);
+
+    // just change status to Idle... if status != Running,
+    // completeInst() will not initiate fetch of next instruction.
+
+    notIdleFraction--;
+    _status = Idle;
+}
+
+bool
+TimingHelperCPU::handleReadPacket(PacketPtr pkt) {
+    DPRINTF(SimpleCPU,"handlereadpacket\n");
+    RequestPtr req = pkt->req;
+    if (req->isMmappedIpr()) {
+        Cycles delay = TheISA::handleIprRead(thread->getTC(), pkt);
+        new IprEvent(pkt, this, clockEdge(delay));
+        _status = DcacheWaitResponse;
+        dcache_pkt = NULL;
+    } else if (!dcachePort.sendTimingReq(pkt)) {
+        _status = DcacheRetry;
+        dcache_pkt = pkt;
+    } else {
+        _status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        dcache_pkt = NULL;
+    }
+    return dcache_pkt == NULL;
+}
+
+void
+TimingHelperCPU::sendData(RequestPtr req, uint8_t *data, uint64_t *res,
+        bool read) {
+    DPRINTF(SimpleCPU,"sendData\n");
+    PacketPtr pkt;
+    buildPacket(pkt, req, read);
+    pkt->dataDynamicArray<uint8_t>(data);
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        assert(!dcache_pkt);
+        pkt->makeResponse();
+        completeDataAccess(pkt);
+    } else if (read) {
+        handleReadPacket(pkt);
+    } else {
+        bool do_access = true; // flag to suppress cache access
+
+        if (req->isLLSC()) {
+            do_access = TheISA::handleLockedWrite(thread, req);
+        } else if (req->isCondSwap()) {
+            assert(res);
+            req->setExtraData(*res);
+        }
+
+        if (do_access) {
+            dcache_pkt = pkt;
+            handleWritePacket();
+        } else {
+            _status = DcacheWaitResponse;
+            completeDataAccess(pkt);
+        }
+    }
+}
+
+void
+TimingHelperCPU::sendSplitData(RequestPtr req1, RequestPtr req2,
+        RequestPtr req, uint8_t *data, bool read) {
+    DPRINTF(SimpleCPU,"send split data\n");
+    PacketPtr pkt1, pkt2;
+    buildSplitPacket(pkt1, pkt2, req1, req2, req, data, read);
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        assert(!dcache_pkt);
+        pkt1->makeResponse();
+        completeDataAccess(pkt1);
+    } else if (read) {
+        SplitFragmentSenderState * send_state =
+                dynamic_cast<SplitFragmentSenderState *> (pkt1->senderState);
+        if (handleReadPacket(pkt1)) {
+            send_state->clearFromParent();
+            send_state = dynamic_cast<SplitFragmentSenderState *> (
+                    pkt2->senderState);
+            if (handleReadPacket(pkt2)) {
+                send_state->clearFromParent();
+            }
+        }
+    } else {
+        dcache_pkt = pkt1;
+        SplitFragmentSenderState * send_state =
+                dynamic_cast<SplitFragmentSenderState *> (pkt1->senderState);
+        if (handleWritePacket()) {
+            send_state->clearFromParent();
+            dcache_pkt = pkt2;
+            send_state = dynamic_cast<SplitFragmentSenderState *> (
+                    pkt2->senderState);
+            if (handleWritePacket()) {
+                send_state->clearFromParent();
+            }
+        }
+    }
+}
+
+void
+TimingHelperCPU::translationFault(Fault fault) {
+    DPRINTF(SimpleCPU,"translation fault\n");
+    // fault may be NoFault in cases where a fault is suppressed,
+    // for instance prefetches.
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    if (traceData) {
+        // Since there was a fault, we shouldn't trace this instruction.
+        delete traceData;
+        traceData = NULL;
+    }
+
+    postExecute();
+    DPRINTF(SimpleCPU,"Translation fault occured, unhandled yet\n");
+    advanceInst(fault);
+}
+
+void
+TimingHelperCPU::buildPacket(PacketPtr &pkt, RequestPtr req, bool read) {
+    DPRINTF(SimpleCPU,"buildPacket\n");
+    MemCmd cmd;
+    if (read) {
+        cmd = MemCmd::ReadReq;
+        if (req->isLLSC())
+            cmd = MemCmd::LoadLockedReq;
+    } else {
+        cmd = MemCmd::WriteReq;
+        if (req->isLLSC()) {
+            cmd = MemCmd::StoreCondReq;
+        } else if (req->isSwap()) {
+            cmd = MemCmd::SwapReq;
+        }
+    }
+    pkt = new Packet(req, cmd);
+}
+
+void
+TimingHelperCPU::buildSplitPacket(PacketPtr &pkt1, PacketPtr &pkt2,
+        RequestPtr req1, RequestPtr req2, RequestPtr req,
+        uint8_t *data, bool read) {
+    DPRINTF(SimpleCPU,"build split packet\n");
+    pkt1 = pkt2 = NULL;
+
+    assert(!req1->isMmappedIpr() && !req2->isMmappedIpr());
+
+    if (req->getFlags().isSet(Request::NO_ACCESS)) {
+        buildPacket(pkt1, req, read);
+        return;
+    }
+
+    buildPacket(pkt1, req1, read);
+    buildPacket(pkt2, req2, read);
+
+    req->setPhys(req1->getPaddr(), req->getSize(), req1->getFlags(), dataMasterId());
+    PacketPtr pkt = new Packet(req, pkt1->cmd.responseCommand());
+
+    pkt->dataDynamicArray<uint8_t>(data);
+    pkt1->dataStatic<uint8_t>(data);
+    pkt2->dataStatic<uint8_t>(data + req1->getSize());
+
+    SplitMainSenderState * main_send_state = new SplitMainSenderState;
+    pkt->senderState = main_send_state;
+    main_send_state->fragments[0] = pkt1;
+    main_send_state->fragments[1] = pkt2;
+    main_send_state->outstanding = 2;
+    pkt1->senderState = new SplitFragmentSenderState(pkt, 0);
+    pkt2->senderState = new SplitFragmentSenderState(pkt, 1);
+}
+
+Fault
+TimingHelperCPU::readMem(Addr addr, uint8_t *data,
+        unsigned size, unsigned flags) {
+    DPRINTF(SimpleCPU,"readmem\n");
+    Fault fault;
+    const int asid = 0;
+    const ThreadID tid = 0;
+    const Addr pc = thread->instAddr();
+    unsigned block_size = cacheLineSize();
+    BaseTLB::Mode mode = BaseTLB::Read;
+
+    if (traceData) {
+        traceData->setAddr(addr);
+    }
+
+    RequestPtr req = new Request(asid, addr, size,
+            flags, dataMasterId(), pc, _cpuId, tid);
+
+    Addr split_addr = roundDown(addr + size - 1, block_size);
+    assert(split_addr <= addr || split_addr - addr < block_size);
+
+    _status = DTBWaitResponse;
+    if (split_addr > addr) {
+        RequestPtr req1, req2;
+        assert(!req->isLLSC() && !req->isSwap());
+        req->splitOnVaddr(split_addr, req1, req2);
+
+        WholeTranslationState *state =
+                new WholeTranslationState(req, req1, req2, new uint8_t[size],
+                NULL, mode);
+        DataTranslation<TimingHelperCPU *> *trans1 =
+                new DataTranslation<TimingHelperCPU *>(this, state, 0);
+        DataTranslation<TimingHelperCPU *> *trans2 =
+                new DataTranslation<TimingHelperCPU *>(this, state, 1);
+
+        thread->dtb->translateTiming(req1, tc, trans1, mode);
+        thread->dtb->translateTiming(req2, tc, trans2, mode);
+    } else {
+        WholeTranslationState *state =
+                new WholeTranslationState(req, new uint8_t[size], NULL, mode);
+        DataTranslation<TimingHelperCPU *> *translation
+                = new DataTranslation<TimingHelperCPU *>(this, state);
+        thread->dtb->translateTiming(req, tc, translation, mode);
+    }
+
+    return NoFault;
+}
+
+bool
+TimingHelperCPU::handleWritePacket() {
+    DPRINTF(SimpleCPU,"handlewritepacket\n");
+    RequestPtr req = dcache_pkt->req;
+    if (req->isMmappedIpr()) {
+        Cycles delay = TheISA::handleIprWrite(thread->getTC(), dcache_pkt);
+        new IprEvent(dcache_pkt, this, clockEdge(delay));
+        _status = DcacheWaitResponse;
+        dcache_pkt = NULL;
+    } else if (!dcachePort.sendTimingReq(dcache_pkt)) {
+        _status = DcacheRetry;
+    } else {
+        _status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        dcache_pkt = NULL;
+    }
+    return dcache_pkt == NULL;
+}
+
+Fault
+TimingHelperCPU::writeMem(uint8_t *data, unsigned size,
+        Addr addr, unsigned flags, uint64_t *res) {
+    DPRINTF(SimpleCPU,"writemme\n");
+    uint8_t *newData = new uint8_t[size];
+    memcpy(newData, data, size);
+
+    const int asid = 0;
+    const ThreadID tid = 0;
+    const Addr pc = thread->instAddr();
+    unsigned block_size = cacheLineSize();
+    BaseTLB::Mode mode = BaseTLB::Write;
+
+    if (traceData) {
+        traceData->setAddr(addr);
+    }
+
+    RequestPtr req = new Request(asid, addr, size,
+            flags, dataMasterId(), pc, _cpuId, tid);
+
+    Addr split_addr = roundDown(addr + size - 1, block_size);
+    assert(split_addr <= addr || split_addr - addr < block_size);
+
+    _status = DTBWaitResponse;
+    if (split_addr > addr) {
+        RequestPtr req1, req2;
+        assert(!req->isLLSC() && !req->isSwap());
+        req->splitOnVaddr(split_addr, req1, req2);
+
+        WholeTranslationState *state =
+                new WholeTranslationState(req, req1, req2, newData, res, mode);
+        DataTranslation<TimingHelperCPU *> *trans1 =
+                new DataTranslation<TimingHelperCPU *>(this, state, 0);
+        DataTranslation<TimingHelperCPU *> *trans2 =
+                new DataTranslation<TimingHelperCPU *>(this, state, 1);
+
+        thread->dtb->translateTiming(req1, tc, trans1, mode);
+        thread->dtb->translateTiming(req2, tc, trans2, mode);
+    } else {
+        WholeTranslationState *state =
+                new WholeTranslationState(req, newData, res, mode);
+        DataTranslation<TimingHelperCPU *> *translation =
+                new DataTranslation<TimingHelperCPU *>(this, state);
+        thread->dtb->translateTiming(req, tc, translation, mode);
+    }
+
+    // Translation faults will be returned via finishTranslation()
+    return NoFault;
+}
+
+
+void
+TimingHelperCPU::finishTranslation(WholeTranslationState *state) {
+    DPRINTF(SimpleCPU,"finish translation\n");
+    _status = BaseHelperCPU::Running;
+
+    if (state->getFault() != NoFault) {
+        if (state->isPrefetch()) {
+            state->setNoFault();
+        }
+        delete [] state->data;
+        state->deleteReqs();
+        translationFault(state->getFault());
+    } else {
+        if (!state->isSplit) {
+            sendData(state->mainReq, state->data, state->res,
+                    state->mode == BaseTLB::Read);
+        } else {
+            sendSplitData(state->sreqLow, state->sreqHigh, state->mainReq,
+                    state->data, state->mode == BaseTLB::Read);
+        }
+    }
+
+    delete state;
+}
+
+bool
+TimingHelperCPU::DcachePort::recvTimingResp(PacketPtr pkt) {
+    DPRINTF(SimpleCPU,"recvtimingresp\n");
+    // delay processing of returned data until next CPU clock edge
+    Tick next_tick = cpu->clockEdge();
+
+    if (next_tick == curTick()) {
+        cpu->completeDataAccess(pkt);
+    } else {
+        if (!tickEvent.scheduled()) {
+            tickEvent.schedule(pkt, next_tick);
+        } else {
+            // In the case of a split transaction and a cache that is
+            // faster than a CPU we could get two responses before
+            // next_tick expires
+            if (!retryEvent.scheduled())
+                cpu->schedule(retryEvent, next_tick);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+void
+TimingHelperCPU::DcachePort::DTickEvent::process() {
+    cpu->completeDataAccess(pkt);
+}
+
+void
+TimingHelperCPU::DcachePort::recvRetry() {
+    DPRINTF(SimpleCPU,"recv retry\n");
+    // we shouldn't get a retry unless we have a packet that we're
+    // waiting to transmit
+    assert(cpu->dcache_pkt != NULL);
+    assert(cpu->_status == DcacheRetry);
+    PacketPtr tmp = cpu->dcache_pkt;
+    if (tmp->senderState) {
+        // This is a packet from a split access.
+        SplitFragmentSenderState * send_state =
+                dynamic_cast<SplitFragmentSenderState *> (tmp->senderState);
+        assert(send_state);
+        PacketPtr big_pkt = send_state->bigPkt;
+
+        SplitMainSenderState * main_send_state =
+                dynamic_cast<SplitMainSenderState *> (big_pkt->senderState);
+        assert(main_send_state);
+
+        if (sendTimingReq(tmp)) {
+            // If we were able to send without retrying, record that fact
+            // and try sending the other fragment.
+            send_state->clearFromParent();
+            int other_index = main_send_state->getPendingFragment();
+            if (other_index > 0) {
+                tmp = main_send_state->fragments[other_index];
+                cpu->dcache_pkt = tmp;
+                if ((big_pkt->isRead() && cpu->handleReadPacket(tmp)) ||
+                        (big_pkt->isWrite() && cpu->handleWritePacket())) {
+                    main_send_state->fragments[other_index] = NULL;
+                }
+            } else {
+                cpu->_status = DcacheWaitResponse;
+                // memory system takes ownership of packet
+                cpu->dcache_pkt = NULL;
+            }
+        }
+    } else if (sendTimingReq(tmp)) {
+        cpu->_status = DcacheWaitResponse;
+        // memory system takes ownership of packet
+        cpu->dcache_pkt = NULL;
+    }
+}
+
+TimingHelperCPU::IprEvent::IprEvent(Packet *_pkt, TimingHelperCPU *_cpu,
+        Tick t)
+: pkt(_pkt), cpu(_cpu) {
+    cpu->schedule(this, t);
+}
+
+void
+TimingHelperCPU::IprEvent::process() {
+    cpu->completeDataAccess(pkt);
+}
+
+const char *
+TimingHelperCPU::IprEvent::description() const {
+    return "Timing Simple CPU Delay IPR event";
+}
+
+void
+TimingHelperCPU::printAddr(Addr a) {
+    dcachePort.printAddr(a);
+}
+
+void
+TimingHelperCPU::IcachePort::ITickEvent::process() {
+    cpu->completeIfetch(pkt);
+}
+
+bool
+TimingHelperCPU::IcachePort::recvTimingResp(PacketPtr pkt) {
+    DPRINTF(SimpleCPU, "Received timing response %#x\n", pkt->getAddr());
+    // delay processing of returned data until next CPU clock edge
+    Tick next_tick = cpu->clockEdge();
+
+    if (next_tick == curTick())
+        cpu->completeIfetch(pkt);
+    else
+        tickEvent.schedule(pkt, next_tick);
+
+    return true;
+}
+
+void
+TimingHelperCPU::IcachePort::recvRetry() {
+    // we shouldn't get a retry unless we have a packet that we're
+    // waiting to transmit
+    assert(cpu->ifetch_pkt != NULL);
+    assert(cpu->_status == IcacheRetry);
+    PacketPtr tmp = cpu->ifetch_pkt;
+    if (sendTimingReq(tmp)) {
+        cpu->_status = IcacheWaitResponse;
+        cpu->ifetch_pkt = NULL;
+    }
+}
+
+
+
+
+////////////////////////////////////////////////////////////////////////
+//
+//  TimingHelperCPU Simulation Object
+//
+
+TimingHelperCPU *
+TimingHelperCPUParams::create() {
+    numThreads = 1;
+    if (!FullSystem && workload.size() != 1)
+        panic("only one workload allowed");
+    return new TimingHelperCPU(this);
+}
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/TimingHelperCPU.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/TimingHelperCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,42 @@
+# Copyright (c) 2007 The Regents of The University of Michigan
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+# Authors: Nathan Binkert
+
+from m5.params import *
+from BaseHelperCPU import BaseHelperCPU
+
+class TimingHelperCPU(BaseHelperCPU):
+    type = 'TimingHelperCPU'
+    cxx_header = "cpu/helper/timing.hh"
+
+    @classmethod
+    def memory_mode(cls):
+        return 'timing'
+
+    @classmethod
+    def support_take_over(cls):
+        return True
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/base.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/base.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,452 @@
+/*
+ * Copyright (c) 2010-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+#include "arch/kernel_stats.hh"
+#include "arch/stacktrace.hh"
+#include "arch/tlb.hh"
+#include "arch/utility.hh"
+#include "arch/vtophys.hh"
+#include "base/loader/symtab.hh"
+#include "base/cp_annotate.hh"
+#include "base/cprintf.hh"
+#include "base/inifile.hh"
+#include "base/misc.hh"
+#include "base/pollevent.hh"
+#include "base/trace.hh"
+#include "base/types.hh"
+#include "config/the_isa.hh"
+#include "cpu/checker/cpu.hh"
+#include "cpu/checker/thread_context.hh"
+#include "cpu/helper/base.hh"
+#include "cpu/base.hh"
+#include "cpu/exetrace.hh"
+#include "cpu/profile.hh"
+#include "cpu/simple_thread.hh"
+#include "cpu/smt.hh"
+#include "cpu/static_inst.hh"
+#include "cpu/thread_context.hh"
+#include "debug/Decode.hh"
+#include "debug/Fetch.hh"
+#include "debug/Squasher.hh"
+#include "debug/SimpleCPU.hh"
+#include "debug/Quiesce.hh"
+#include "mem/mem_object.hh"
+#include "mem/packet.hh"
+#include "mem/request.hh"
+#include "params/BaseHelperCPU.hh"
+#include "sim/byteswap.hh"
+#include "sim/debug.hh"
+#include "sim/faults.hh"
+#include "sim/full_system.hh"
+#include "sim/sim_events.hh"
+#include "sim/sim_object.hh"
+#include "sim/stats.hh"
+#include "sim/system.hh"
+
+using namespace std;
+using namespace TheISA;
+
+BaseHelperCPU::BaseHelperCPU(BaseHelperCPUParams *p)
+    : BaseCPU(p), traceData(NULL), thread(NULL)
+{
+    curCPU=0;
+    timeTaken=0;
+    if (FullSystem)
+        thread = new SimpleThread(this, 0, p->system, p->itb, p->dtb,
+                                  p->isa[0]);
+    else
+        thread = new SimpleThread(this, /* thread_num */ 0, p->system,
+                                  p->workload[0], p->itb, p->dtb, p->isa[0]);
+    locked=false;
+    thread->setStatus(ThreadContext::Halted);
+    delayTable[Enums::No_OpClass]=1; 
+    delayTable[Enums::IntAlu]=1;
+    delayTable[Enums::IntMult]=3;
+    delayTable[Enums::IntMult]=3;
+    delayTable[Enums::IprAccess]=3;
+    delayTable[Enums::SimdAdd] = 4;
+    delayTable[Enums::SimdAddAcc] = 4;
+    delayTable[Enums::SimdAlu] = 4;
+    delayTable[Enums::SimdCmp] = 4;
+    delayTable[Enums::SimdCvt] = 3;
+    delayTable[Enums::SimdMisc] = 3;
+    delayTable[Enums::SimdMult] = 5;
+    delayTable[Enums::SimdMultAcc] = 5;
+    delayTable[Enums::SimdShift] = 3;
+    delayTable[Enums::SimdShiftAcc] = 3;
+    delayTable[Enums::SimdSqrt] = 9;
+    delayTable[Enums::SimdFloatAdd] = 5;
+    delayTable[Enums::SimdFloatAlu] = 5;
+    delayTable[Enums::SimdFloatCmp] = 3;
+    delayTable[Enums::SimdFloatCvt] = 3;
+    delayTable[Enums::SimdFloatDiv] = 3;
+    delayTable[Enums::SimdFloatMisc] = 3;
+    delayTable[Enums::SimdFloatMult] = 3;
+    delayTable[Enums::SimdFloatMultAcc] = 1;
+    delayTable[Enums::SimdFloatSqrt] = 9;
+    delayTable[Enums::FloatAdd] = 5;
+    delayTable[Enums::FloatCmp] = 5;
+    delayTable[Enums::FloatCvt] = 5;
+    delayTable[Enums::FloatDiv] = 9;
+    delayTable[Enums::FloatSqrt] = 33;
+    delayTable[Enums::FloatMult] = 4;
+    delayTable[ Enums::MemRead]=2;
+    delayTable[ Enums::MemWrite]=2;
+
+
+
+    DPRINTF(Squasher,"IO Porthandler Requested\n");
+    tc = thread->getTC();
+    
+    if (p->checker) {
+        BaseCPU *temp_checker = p->checker;
+        checker = dynamic_cast<CheckerCPU *>(temp_checker);
+        checker->setSystem(p->system);
+        // Manipulate thread context
+        ThreadContext *cpu_tc = tc;
+        tc = new CheckerThreadContext<ThreadContext>(cpu_tc, this->checker);
+    } else {
+        checker = NULL;
+    }
+
+    numInst = 0;
+    startNumInst = 0;
+    numOp = 0;
+    startNumOp = 0;
+    numLoad = 0;
+    startNumLoad = 0;
+    lastIcacheStall = 0;
+    lastDcacheStall = 0;
+
+    threadContexts.push_back(tc);
+
+
+    fetchOffset = 0;
+    stayAtPC = false;
+}
+
+BaseHelperCPU::~BaseHelperCPU()
+{
+}
+
+void
+BaseHelperCPU::deallocateContext(ThreadID thread_num)
+{
+    // for now, these are equivalent
+    suspendContext(thread_num);
+}
+
+
+void
+BaseHelperCPU::haltContext(ThreadID thread_num)
+{
+    // for now, these are equivalent
+    suspendContext(thread_num);
+}
+
+
+void
+BaseHelperCPU::regStats()
+{
+    using namespace Stats;
+
+    BaseCPU::regStats();
+    cpuExecTime
+        .init(5)
+        .name(name()+".cpuRetryCycles")
+        .desc("Execution Time of each Processor")
+        .flags(total)
+        ;
+
+    cpuTime
+        .init(5)
+        .name(name()+".cpuHaltCycles")
+        .desc("Halt Time of each Processor")
+        .flags(total)
+        ;
+    idleRerunCycles
+        .name(name() + ".idleReRunCycles")
+        .desc("Total number of cycles that the CPU has spent on instruction execution here ");
+
+    numInsts
+        .name(name() + ".committedInsts")
+        .desc("Number of instructions committed")
+        ;
+
+    numOps
+        .name(name() + ".committedOps")
+        .desc("Number of ops (including micro ops) committed")
+        ;
+
+    numIntAluAccesses
+        .name(name() + ".num_int_alu_accesses")
+        .desc("Number of integer alu accesses")
+        ;
+
+    numFpAluAccesses
+        .name(name() + ".num_fp_alu_accesses")
+        .desc("Number of float alu accesses")
+        ;
+
+    numCallsReturns
+        .name(name() + ".num_func_calls")
+        .desc("number of times a function call or return occured")
+        ;
+
+    numCondCtrlInsts
+        .name(name() + ".num_conditional_control_insts")
+        .desc("number of instructions that are conditional controls")
+        ;
+
+    numIntInsts
+        .name(name() + ".num_int_insts")
+        .desc("number of integer instructions")
+        ;
+
+    numFpInsts
+        .name(name() + ".num_fp_insts")
+        .desc("number of float instructions")
+        ;
+
+    numIntRegReads
+        .name(name() + ".num_int_register_reads")
+        .desc("number of times the integer registers were read")
+        ;
+
+    numIntRegWrites
+        .name(name() + ".num_int_register_writes")
+        .desc("number of times the integer registers were written")
+        ;
+
+    numFpRegReads
+        .name(name() + ".num_fp_register_reads")
+        .desc("number of times the floating registers were read")
+        ;
+
+    numFpRegWrites
+        .name(name() + ".num_fp_register_writes")
+        .desc("number of times the floating registers were written")
+        ;
+
+    numMemRefs
+        .name(name()+".num_mem_refs")
+        .desc("number of memory refs")
+        ;
+
+    numStoreInsts
+        .name(name() + ".num_store_insts")
+        .desc("Number of store instructions")
+        ;
+
+    numLoadInsts
+        .name(name() + ".num_load_insts")
+        .desc("Number of load instructions")
+        ;
+
+    notIdleFraction
+        .name(name() + ".not_idle_fraction")
+        .desc("Percentage of non-idle cycles")
+        ;
+
+    idleFraction
+        .name(name() + ".idle_fraction")
+        .desc("Percentage of idle cycles")
+        ;
+
+    numBusyCycles
+        .name(name() + ".num_busy_cycles")
+        .desc("Number of busy cycles")
+        ;
+
+    numIdleCycles
+        .name(name()+".num_idle_cycles")
+        .desc("Number of idle cycles")
+        ;
+
+    icacheStallCycles
+        .name(name() + ".icache_stall_cycles")
+        .desc("ICache total stall cycles")
+        .prereq(icacheStallCycles)
+        ;
+
+    dcacheStallCycles
+        .name(name() + ".dcache_stall_cycles")
+        .desc("DCache total stall cycles")
+        .prereq(dcacheStallCycles)
+        ;
+
+    icacheRetryCycles
+        .name(name() + ".icache_retry_cycles")
+        .desc("ICache total retry cycles")
+        .prereq(icacheRetryCycles)
+        ;
+
+    dcacheRetryCycles
+        .name(name() + ".dcache_retry_cycles")
+        .desc("DCache total retry cycles")
+        .prereq(dcacheRetryCycles)
+        ;
+
+    idleFraction = constant(1.0) - notIdleFraction;
+    numIdleCycles = idleFraction * numCycles;
+    numBusyCycles = (notIdleFraction)*numCycles;
+}
+
+void
+BaseHelperCPU::resetStats()
+{
+//    startNumInst = numInst;
+     notIdleFraction = (_status != Idle);
+}
+
+void
+BaseHelperCPU::serializeThread(ostream &os, ThreadID tid)
+{
+    assert(_status == Idle || _status == Running);
+    assert(tid == 0);
+
+    thread->serialize(os);
+}
+
+void
+BaseHelperCPU::unserializeThread(Checkpoint *cp, const string &section,
+                                 ThreadID tid)
+{
+    if (tid != 0)
+        fatal("Trying to load more than one thread into a SimpleCPU\n");
+    thread->unserialize(cp, section);
+}
+
+
+Addr
+BaseHelperCPU::dbg_vtophys(Addr addr)
+{
+    return vtophys(tc, addr);
+}
+
+void
+BaseHelperCPU::wakeup()
+{
+    if (thread->status() != ThreadContext::Suspended)
+        return;
+
+    DPRINTF(Quiesce,"Suspended Processor awoke\n");
+    thread->activate();
+}
+
+void
+BaseHelperCPU::checkForInterrupts()
+{
+    if (checkInterrupts(tc)) {
+        Fault interrupt = interrupts->getInterrupt(tc);
+
+        if (interrupt != NoFault) {
+            fetchOffset = 0;
+            interrupts->updateIntrInfo(tc);
+            interrupt->invoke(tc);
+            thread->decoder.reset();
+        }
+    }
+}
+//#todo: fix this to porthandler
+
+void
+BaseHelperCPU::setupFetchRequest(Request *req)
+{
+    Addr instAddr = thread->instAddr();
+
+    // set up memory request for instruction fetch
+    DPRINTF(Fetch, "Fetch: PC:%08p\n", instAddr);
+
+    Addr fetchPC = (instAddr & PCMask) + fetchOffset;
+    req->setVirt(0, fetchPC, sizeof(MachInst), Request::INST_FETCH, instMasterId(),
+            instAddr);
+}
+
+
+void
+BaseHelperCPU::advancePC(Fault fault)
+{
+    //Since we're moving to a new pc, zero out the offset
+    fetchOffset = 0;
+    if (fault != NoFault) {
+        curMacroStaticInst = StaticInst::nullStaticInstPtr;
+        fault->invoke(tc, curStaticInst);
+        thread->decoder.reset();
+    } else {
+        if (curStaticInst) {
+            if (curStaticInst->isLastMicroop())
+                curMacroStaticInst = StaticInst::nullStaticInstPtr;
+            TheISA::PCState pcState = thread->pcState();
+            TheISA::advancePC(pcState, curStaticInst);
+            thread->pcState(pcState);
+        }
+    }
+}
+void
+BaseHelperCPU::resetStage(){
+	Tick completedTicks=curTick()-lastTick;
+//    printf("%lu\n",completedTicks);
+	idleRerunCycles+=completedTicks;
+	lastTick=curTick();
+
+    DPRINTF(SimpleCPU,"Resetting cpu\n");
+    locked=false;
+    dataRequested=false;
+    PortedData=NULL;
+    _status=Running;
+    inst=0;
+    curStaticInst=NULL;
+    curMacroStaticInst=NULL;
+    fetchOffset=0;
+    stayAtPC=true;
+    thread->clearArchRegs();
+    thread->decoder.reset();
+    
+}
+void
+BaseHelperCPU::startup()
+{
+    DPRINTF(SimpleCPU,"Starting the Base CPU\n");
+    BaseCPU::startup();
+    thread->startup();
+}
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/base.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/base.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,494 @@
+/*
+ * Copyright (c) 2011-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ *          Dave Greene
+ *          Nathan Binkert
+ */
+
+#ifndef __CPU_HELPER_BASE_HH__
+#define __CPU_HELPER_BASE_HH__
+
+#include "base/statistics.hh"
+#include "config/the_isa.hh"
+#include "cpu/checker/cpu.hh"
+#include "cpu/base.hh"
+#include "cpu/pc_event.hh"
+#include "cpu/simple_thread.hh"
+#include "cpu/static_inst.hh"
+#include "mem/packet.hh"
+#include "mem/port.hh"
+#include "mem/request.hh"
+#include "sim/eventq.hh"
+#include "sim/full_system.hh"
+#include "sim/system.hh"
+#include "cpu/PortManager.hh"
+#include "debug/PH.hh"
+#include<map>
+// forward declarations
+class Checkpoint;
+class Process;
+class Processor;
+class ThreadContext;
+
+namespace TheISA {
+    class DTB;
+    class ITB;
+}
+
+namespace Trace {
+    class InstRecord;
+}
+
+struct BaseHelperCPUParams;
+
+class BaseHelperCPU : public BaseCPU {
+protected:
+    typedef TheISA::MiscReg MiscReg;
+    typedef TheISA::FloatReg FloatReg;
+    typedef TheISA::FloatRegBits FloatRegBits;
+
+    uint64_t timeTaken;
+protected:
+    Trace::InstRecord *traceData;
+    CommPack * PortedData;
+    portInterface * helperPort;
+    InstrIOPortsHandler* portHandler;
+    int curCPU;
+
+    inline void checkPcEventQueue() {
+        Addr oldpc, pc = thread->instAddr();
+        do {
+            oldpc = pc;
+            system->pcEventQueue.service(tc);
+            pc = thread->instAddr();
+        } while (oldpc != pc);
+    }
+
+
+public:
+    bool locked,dataRequested;
+
+    bool isLocked() {
+        return locked;
+    }
+    
+    bool waitingData(CommPack *check){
+        if(dataRequested){
+            if(check==PortedData)
+                return true;                        
+        }else{
+            return false;
+        }
+        return false;
+    }
+    void wakeup();
+    std::map<OpClass, int> delayTable;
+
+    void zero_fill_64(Addr addr) {
+        static int warned = 0;
+        if (!warned) {
+            warn("WH64 is not implemented");
+            warned = 1;
+        }
+    };
+
+public:
+    BaseHelperCPU(BaseHelperCPUParams *params);
+    virtual ~BaseHelperCPU();
+
+public:
+    /** SimpleThread object, provides all the architectural state. */
+    SimpleThread *thread;
+
+    /** ThreadContext object, provides an interface for external
+     * objects to modify this thread's state.
+     */
+    ThreadContext *tc;
+
+    CheckerCPU *checker;
+
+protected:
+
+    enum Status {
+        Idle,
+        Running,
+        Faulting,
+        ITBWaitResponse,
+        IcacheRetry,
+        IcacheWaitResponse,
+        IcacheWaitSwitch,
+        DTBWaitResponse,
+        DcacheRetry,
+        DcacheWaitResponse,
+        DcacheWaitSwitch,
+    };
+
+    Status _status;
+
+public:
+
+    Addr dbg_vtophys(Addr addr);
+
+    bool interval_stats;
+
+    // current instruction
+    TheISA::MachInst inst;
+
+    StaticInstPtr curStaticInst;
+    StaticInstPtr curMacroStaticInst;
+
+    //This is the offset from the current pc that fetch should be performed at
+    Addr fetchOffset;
+    //This flag says to stay at the current pc. This is useful for
+    //instructions which go beyond MachInst boundaries.
+    bool stayAtPC;
+
+    void checkForInterrupts();
+    void setupFetchRequest(Request *req);
+
+    void advancePC(Fault fault);
+
+
+    virtual void deallocateContext(ThreadID thread_num);
+    virtual void haltContext(ThreadID thread_num);
+
+    // statistics
+    virtual void regStats();
+    virtual void resetStats();
+
+    virtual void startup();
+
+    Stats::Scalar idleRerunCycles;
+    // number of simulated instructions
+    Counter numInst;
+    Counter startNumInst;
+    Stats::Scalar numInsts;
+    Counter numOp;
+    Counter startNumOp;
+    Stats::Scalar numOps;
+
+    void countInst() {
+        if (!curStaticInst->isMicroop() || curStaticInst->isLastMicroop()) {
+            numInst++;
+            numInsts++;
+        }
+        numOp++;
+        numOps++;
+
+        system->totalNumInsts++;
+        thread->funcExeInst++;
+    }
+
+    virtual Counter totalInsts() const {
+        return numInst - startNumInst;
+    }
+
+    virtual Counter totalOps() const {
+        return numOp - startNumOp;
+    }
+
+    //number of integer alu accesses
+    Stats::Scalar numIntAluAccesses;
+
+    //number of float alu accesses
+    Stats::Scalar numFpAluAccesses;
+
+    //number of function calls/returns
+    Stats::Scalar numCallsReturns;
+
+    //conditional control instructions;
+    Stats::Scalar numCondCtrlInsts;
+
+    //number of int instructions
+    Stats::Scalar numIntInsts;
+
+    //number of float instructions
+    Stats::Scalar numFpInsts;
+
+    //number of integer register file accesses
+    Stats::Scalar numIntRegReads;
+    Stats::Scalar numIntRegWrites;
+
+    //number of float register file accesses
+    Stats::Scalar numFpRegReads;
+    Stats::Scalar numFpRegWrites;
+
+    // number of simulated memory references
+    Stats::Scalar numMemRefs;
+    Stats::Scalar numLoadInsts;
+    Stats::Scalar numStoreInsts;
+
+    // number of idle cycles
+    Stats::Formula numIdleCycles;
+
+    // number of busy cycles
+    Stats::Formula numBusyCycles;
+
+    // number of simulated loads
+    Counter numLoad;
+    Counter startNumLoad;
+
+    // number of idle cycles
+    Stats::Average notIdleFraction;
+    Stats::Formula idleFraction;
+
+    // number of cycles stalled for I-cache responses
+    Stats::Scalar icacheStallCycles;
+    Counter lastIcacheStall;
+
+    // number of cycles stalled for I-cache retries
+    Stats::Scalar icacheRetryCycles;
+    Counter lastIcacheRetry;
+
+    // number of cycles stalled for D-cache responses
+    Stats::Scalar dcacheStallCycles;
+    Counter lastDcacheStall;
+
+    // number of cycles stalled for D-cache retries
+    Stats::Scalar dcacheRetryCycles;
+    Counter lastDcacheRetry;
+
+    Stats::Vector cpuTime;
+    Stats::Vector cpuExecTime;
+
+    void serializeThread(std::ostream &os, ThreadID tid);
+    void unserializeThread(Checkpoint *cp, const std::string &section,
+            ThreadID tid);
+
+    // These functions are only used in CPU models that split
+    // effective address computation from the actual memory access.
+
+    void setEA(Addr EA) {
+        panic("BaseHelperCPU::setEA() not implemented\n");
+    }
+
+    Addr getEA() {
+        panic("BaseHelperCPU::getEA() not implemented\n");
+        M5_DUMMY_RETURN
+    }
+
+    // The register accessor methods provide the index of the
+    // instruction's operand (e.g., 0 or 1), not the architectural
+    // register index, to simplify the implementation of register
+    // renaming.  We find the architectural register index by indexing
+    // into the instruction's own operand index table.  Note that a
+    // raw pointer to the StaticInst is provided instead of a
+    // ref-counted StaticInstPtr to redice overhead.  This is fine as
+    // long as these methods don't copy the pointer into any long-term
+    // storage (which is pretty hard to imagine they would have reason
+    // to do).
+    uint64_t readDestIntRegOperand(const StaticInstPtr si, int idx) {
+        numIntRegReads++;
+        if (si->destRegIdx(idx) > TheISA::NumIntRegs) {
+            exit(-1);
+        }
+        return thread->readIntReg(si->destRegIdx(idx));
+    }
+
+    FloatReg readDestFloatRegOperand(const StaticInstPtr si, int idx) {
+        numFpRegReads++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatReg(reg_idx);
+    }
+
+    FloatRegBits readDestFloatRegOperandBits(const StaticInstPtr si, int idx) {
+        numFpRegReads++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatRegBits(reg_idx);
+    }
+
+    uint64_t readIntRegOperand(const StaticInst *si, int idx) {
+        numIntRegReads++;
+        if (si->srcRegIdx(idx) > TheISA::NumIntRegs) {
+            exit(-1);
+        }
+        return thread->readIntReg(si->srcRegIdx(idx));
+    }
+
+    FloatReg readFloatRegOperand(const StaticInst *si, int idx) {
+        numFpRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatReg(reg_idx);
+    }
+
+    FloatRegBits readFloatRegOperandBits(const StaticInst *si, int idx) {
+        numFpRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::FP_Base_DepTag;
+        return thread->readFloatRegBits(reg_idx);
+    }
+
+    void setIntRegOperand(const StaticInst *si, int idx, uint64_t val) {
+        numIntRegWrites++;
+        thread->setIntReg(si->destRegIdx(idx), val);
+    }
+
+    void setFloatRegOperand(const StaticInst *si, int idx, FloatReg val) {
+        numFpRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        thread->setFloatReg(reg_idx, val);
+    }
+
+    void setFloatRegOperandBits(const StaticInst *si, int idx,
+            FloatRegBits val) {
+        numFpRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::FP_Base_DepTag;
+        thread->setFloatRegBits(reg_idx, val);
+    }
+
+    bool readPredicate() {
+        return thread->readPredicate();
+    }
+
+    void setPredicate(bool val) {
+        thread->setPredicate(val);
+        if (traceData) {
+            traceData->setPredicate(val);
+        }
+    }
+
+    TheISA::PCState pcState() {
+        return thread->pcState();
+    }
+
+    void pcState(const TheISA::PCState &val) {
+        thread->pcState(val);
+    }
+
+    Addr instAddr() {
+        return thread->instAddr();
+    }
+
+    Addr nextInstAddr() {
+        return thread->nextInstAddr();
+    }
+
+    MicroPC microPC() {
+        return thread->microPC();
+    }
+
+    MiscReg readMiscRegNoEffect(int misc_reg) {
+        return thread->readMiscRegNoEffect(misc_reg);
+    }
+
+    MiscReg readMiscReg(int misc_reg) {
+        numIntRegReads++;
+        return thread->readMiscReg(misc_reg);
+    }
+
+    void setMiscReg(int misc_reg, const MiscReg &val) {
+        numIntRegWrites++;
+        return thread->setMiscReg(misc_reg, val);
+    }
+
+    MiscReg readMiscRegOperand(const StaticInst *si, int idx) {
+        numIntRegReads++;
+        int reg_idx = si->srcRegIdx(idx) - TheISA::Ctrl_Base_DepTag;
+        return thread->readMiscReg(reg_idx);
+    }
+
+    void setMiscRegOperand(
+            const StaticInst *si, int idx, const MiscReg &val) {
+        numIntRegWrites++;
+        int reg_idx = si->destRegIdx(idx) - TheISA::Ctrl_Base_DepTag;
+        return thread->setMiscReg(reg_idx, val);
+    }
+
+    void demapPage(Addr vaddr, uint64_t asn) {
+        thread->demapPage(vaddr, asn);
+    }
+
+    void demapInstPage(Addr vaddr, uint64_t asn) {
+        thread->demapInstPage(vaddr, asn);
+    }
+
+    void demapDataPage(Addr vaddr, uint64_t asn) {
+        thread->demapDataPage(vaddr, asn);
+    }
+
+    unsigned readStCondFailures() {
+        return thread->readStCondFailures();
+    }
+
+    void setStCondFailures(unsigned sc_failures) {
+        thread->setStCondFailures(sc_failures);
+    }
+
+    MiscReg readRegOtherThread(int regIdx, ThreadID tid = InvalidThreadID) {
+        panic("Simple CPU models do not support multithreaded "
+                "register access.\n");
+    }
+
+    void setRegOtherThread(int regIdx, const MiscReg &val,
+            ThreadID tid = InvalidThreadID) {
+        panic("Simple CPU models do not support multithreaded "
+                "register access.\n");
+    }
+
+    //Fault CacheOp(uint8_t Op, Addr EA);
+
+    Fault hwrei() {
+        return thread->hwrei();
+    }
+
+    bool simPalCheck(int palFunc) {
+        return thread->simPalCheck(palFunc);
+    }
+
+    void
+    syscall(int64_t callnum) {
+        if (FullSystem)
+            panic("Syscall emulation isn't available in FS mode.\n");
+
+        thread->syscall(callnum);
+    }
+
+    bool misspeculating() {
+        return thread->misspeculating();
+    }
+
+    ThreadContext *tcBase() {
+        return tc;
+    }
+
+    Tick lastTick;	
+    void resetStage();
+};
+
+#endif // __CPU_SIMPLE_BASE_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/repair.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/repair.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,664 @@
+/*
+ * Copyright (c) 2010-2012 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+#include "arch/locked_mem.hh"
+#include "arch/mmapped_ipr.hh"
+#include "arch/utility.hh"
+#include "base/bigint.hh"
+#include "config/the_isa.hh"
+#include "cpu/helper/timing.hh"
+#include "cpu/helper/THelper.hh"
+#include "cpu/exetrace.hh"
+#include "debug/Config.hh"
+#include "debug/Drain.hh"
+#include "debug/ExecFaulting.hh"
+#include "debug/SimpleCPU.hh"
+#include "debug/Decode.hh"
+#include "mem/packet.hh"
+#include "mem/packet_access.hh"
+#include "params/TimingHelperCPU.hh"
+#include "sim/faults.hh"
+#include "sim/full_system.hh"
+#include "sim/system.hh"
+
+using namespace std;
+using namespace TheISA;
+
+/*
+ * decodes the instruction. Ideally should only be called by fetchP. Somehow the other 
+ * cases also exist. 
+ */
+void TimingHelperCPU::cpuDecode() {
+    DPRINTF(SimpleCPU,"cpuDecode\n");
+    switch (curPhase) {
+        case fetchP:
+            preExecute();
+            if (curMacroStaticInst) {
+                DPRINTF(SimpleCPU, "Pre Executed the Instruction, Now requesting Data\n");
+                //                cout << "Pre executed" << endl;
+                dataRequested = true;
+                if (curStaticInst->isLastMicroop()) {
+                    curMacroStaticInst = NULL;
+                }
+                cpuRequestData(curStaticInst);
+            } else {
+                DPRINTF(SimpleCPU, "Pre Executed the Instruction, Now sending the instruction\n");
+                sendInstruction(curStaticInst);
+                resetStage();
+            }
+            break;
+        case decodeP:
+            preExecute();
+            DPRINTF(SimpleCPU, "Pre Executed the Instruction, Now sending the instruction\n");
+            cout << "Pre executed" << endl;
+            cpuRequestData(curStaticInst);
+            break;
+        case executeP:
+            //IfetchHelper();
+            cout << "Not supposed to come here" << endl;
+            //            cpuSend();
+            break;
+        case fullP:
+            //IfetchHelper();
+            cout << "Not supposed to reach here" << endl;
+            break;
+        default:
+            break;
+            ;
+    }
+}
+
+/*
+ * Execute the instruction either sent in from the other cpu or fetched by the cpu.
+ * Need to clean up code to make sure they happen independently of each other.
+ */
+void TimingHelperCPU::cpuExecute() {
+    DPRINTF(SimpleCPU,"cpuExecute\n");
+    locked = true;
+    _status = TimingHelperCPU::Running;
+    dataRequested = true;
+    cpuRequestData(curStaticInst);
+}
+
+/*
+ This will fetch the instruction and store it in the curStaticInst.
+ * Iteration happens through execute hopefully.
+ 
+ */
+void TimingHelperCPU::cpuFetch() {
+    DPRINTF(SimpleCPU,"cpuFetch\n");
+    CommPack* packet = helperPort->getData();
+    DPRINTF(SimpleCPU,"Fetching started with packet %i\n",packet);
+    TheISA::PCState thisPC = packet->getPC();
+    Addr fetchAddr = thisPC.instAddr() & PCMask;
+    thread->pcState(thisPC);
+    DPRINTF(SimpleCPU, "This PC is thumb? %s\n", thisPC.thumb() ? "True" : "False");
+    DPRINTF(SimpleCPU, "Fetch\n");
+    _status = TimingHelperCPU::Running;
+    Request *ifetch_req = new Request();
+    ifetch_req->setThreadContext(_cpuId, /* thread ID */ 0);
+    ifetch_req->setVirt(0, fetchAddr, sizeof (MachInst), Request::INST_FETCH, instMasterId(), fetchAddr);
+    //    setupFetchRequest(ifetch_req);
+    DPRINTF(SimpleCPU, "Translating address %#x\n", ifetch_req->getVaddr());
+    thread->itb->translateTiming(ifetch_req, tc, &fetchTranslation,
+            BaseTLB::Execute);
+    //translateTimingResp sends this to cpuDecode.
+}
+
+/*
+ Not sure why I need a cpuMemory function, it is being handled by the execution
+ *
+
+ */
+
+/*
+ Here we switch between different stages. If the phase is fetch, we send it to
+ * cpufetch, decode to cpuDecode etc. We have the following design: iterations
+ * are being handled a bit carelessly. Need to read the code and fix it today.
+ * cpuFetch also needs to handle a full execution if it is a macroop or in fullexec
+ * mode
+ */
+
+void TimingHelperCPU::phaseSwitcher(dataPhase pPhase) {
+    DPRINTF(SimpleCPU,"phaseSwitcher\n");
+    StaticInstPtr instPtr = NULL;
+    switch (pPhase) {
+        case fetchP:
+            cpuFetch();
+            break;
+        case decodeP:
+            cpuDecode();
+            break;
+        case executeP:
+            DPRINTF(SimpleCPU,"Executan Executing Instruction\n");
+            if (sampleIOPort()) {
+                thread->pcState(pullData(instPtr));
+            }
+            curStaticInst = instPtr;
+            cpuExecute();
+            break;
+        case fullP:
+            cpuFetch();
+        default:
+            DPRINTF(SimpleCPU,"Failed switching\n");
+            break;
+    }
+    return;
+}
+
+/*
+ * Add the event with the appropriate delay into the event queue
+ */
+void TimingHelperCPU::addCorrectorEvent() {
+	lastTick=curTick();
+        cpuTime[helperPort->readData()->getCPUid()]+=curTick()-helperPort->readData()->getTick();
+        curCPU=helperPort->readData()->getCPUid();
+        dSend = true;
+        locked = true;
+        DPRINTF(SimpleCPU, "New Request from CPU %d added in with Delay %d with current cycle as %lu\n", helperPort->readData()->getCPUid() , queryDelay(), curCycle());
+        schedule(cEvent, clockEdge(Cycles(queryDelay())));
+    
+}
+
+/*
+ * Function to start the cpu. Works in iteration. End of each scheduled event should start this 
+ * event.   
+ */
+void TimingHelperCPU::correctorTrigger() {
+    DPRINTF(SimpleCPU,"coorrectorTrigger\n");
+    PortedData = helperPort->readData();
+    if (PortedData == NULL) {
+        printf("Wrong data read\n");
+        exit(-1);
+    }
+    if (dataRequested) {
+        DPRINTF(SimpleCPU, "Returning from Data Request\n");
+        dataRequested = false;
+        if(getData()){
+                execution();
+        }else{
+            this->resetStage();
+            if (!isPortEmpty()) {
+                DPRINTF(SimpleCPU,"Requesting for the next instruction from the port \n");
+                addCorrectorEvent();
+                locked = true;
+            }else{
+                DPRINTF(SimpleCPU,"No instructions in que exiting\n");
+            }
+
+        }
+        DPRINTF(SimpleCPU, "Exiting after completion\n");
+        return;
+    }
+    DPRINTF(SimpleCPU, "New Request added\n");
+    curPhase = PortedData->getPhase();
+    phaseSwitcher(PortedData->getPhase());
+}
+
+/*
+ * Is this function being called? 
+ */
+void
+TimingHelperCPU::fetch() {
+    DPRINTF(SimpleCPU, "Fetch\n");
+
+    if (!curStaticInst || !curStaticInst->isDelayedCommit())
+        checkForInterrupts();
+
+    checkPcEventQueue();
+
+    // We must have just got suspended by a PC event
+    if (_status == Idle)
+        return;
+
+    TheISA::PCState pcState = thread->pcState();
+    bool needToFetch = !isRomMicroPC(pcState.microPC()) && !curMacroStaticInst;
+
+    if (needToFetch) {
+        _status = TimingHelperCPU::Running;
+        Request *ifetch_req = new Request();
+        ifetch_req->setThreadContext(_cpuId, /* thread ID */ 0);
+        setupFetchRequest(ifetch_req);
+        DPRINTF(SimpleCPU, "Translating address %#x\n", ifetch_req->getVaddr());
+        thread->itb->translateTiming(ifetch_req, tc, &fetchTranslation,
+                BaseTLB::Execute);
+    } else {
+        _status = IcacheWaitResponse;
+        completeIfetch(NULL);
+
+        numCycles += curCycle() - previousCycle;
+        previousCycle = curCycle();
+    }
+}
+
+void
+TimingHelperCPU::sendFetch(Fault fault, RequestPtr req, ThreadContext *tc) {
+    DPRINTF(SimpleCPU,"send fetch\n");
+    if (fault == NoFault) {
+        DPRINTF(SimpleCPU, "Sending fetch for addr %#x(pa: %#x)\n",
+                req->getVaddr(), req->getPaddr());
+        ifetch_pkt = new Packet(req, MemCmd::ReadReq);
+        ifetch_pkt->dataStatic(&inst);
+        DPRINTF(SimpleCPU, " -- pkt addr: %#x\n", ifetch_pkt->getAddr());
+
+        if (!icachePort.sendTimingReq(ifetch_pkt)) {
+            // Need to wait for retry
+            _status = IcacheRetry;
+        } else {
+            // Need to wait for cache to respond
+            _status = IcacheWaitResponse;
+            // ownership of packet transferred to memory system
+            ifetch_pkt = NULL;
+        }
+    } else {
+        DPRINTF(SimpleCPU, "Translation of addr %#x faulted\n", req->getVaddr());
+        delete req;
+        // fetch fault: advance directly to hell!!!
+
+        exit(-1);
+
+    }
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+}
+
+void
+TimingHelperCPU::advanceInst(Fault fault) {
+    DPRINTF(SimpleCPU,"Advancing Instruction\n");
+    if (curStaticInst->isMicroop()) {
+        if (!stayAtPC)
+            advancePC(fault);
+        if (!curStaticInst->isLastMicroop()&&curPhase!=executeP) {
+            DPRINTF(SimpleCPU, "Was not last Microop, request further data and execute \n");
+            IfetchHelper();
+            return;
+        }
+    }
+    if (_status == TimingHelperCPU::Running && locked) {
+        if (dSend) {
+            DPRINTF(SimpleCPU, "Pushing data to main cpu with locked as %s\n", locked ? "true" : "false");
+            pushData();
+        }
+        locked = false;
+        dSend = false;
+        resetStage();
+        DPRINTF(SimpleCPU,"Trying to find next packet\n");
+        if (!isPortEmpty()) {
+            DPRINTF(SimpleCPU,"Requesting for the next instruction from the port \n");
+            addCorrectorEvent();
+            locked = true;
+        }else{
+            DPRINTF(SimpleCPU,"No instructions in que exiting\n");
+        }
+    }
+}
+
+void
+TimingHelperCPU::completeIfetch(PacketPtr pkt) {
+    DPRINTF(SimpleCPU, "Complete ICache Fetch for addr %#x\n", pkt ?
+            pkt->getAddr() : 0);
+
+    // received a response from the icache: execute the received
+    // instruction
+    assert(!pkt || !pkt->isError());
+    cpuDecode();
+
+    //    IfetchHelper();
+
+    if (pkt) {
+        delete pkt->req;
+        delete pkt;
+    }
+}
+
+/*
+ * Works in scenarios where the  
+ */
+void
+TimingHelperCPU::IfetchHelper() {
+
+    DPRINTF(SimpleCPU,"IfetchHelper\n");
+
+    _status = TimingHelperCPU::Running;
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    preExecute();
+
+    if (curMacroStaticInst) {
+        DPRINTF(SimpleCPU, "Is a macroop \n");
+        dataRequested = true;
+        cpuRequestData(curStaticInst);
+
+    }else{
+        cout<<"Not supposed to reach here"<<endl;
+        exit(-1);
+    }
+}
+
+void
+TimingHelperCPU::execution() {
+    _status = TimingHelperCPU::Running;
+    DPRINTF(SimpleCPU, "Executing Instruction \n");
+    assert(curStaticInst);
+    if (curStaticInst && curStaticInst->isMemRef()) {
+            assert(curStaticInst);
+        // load or store: just send to dcache
+        DPRINTF(SimpleCPU, "Executing Instruction now\n");
+        Fault fault =NoFault;
+//        curStaticInst->initiateAcc(this, traceData);
+        
+        DPRINTF(SimpleCPU, "Executing Memory Instruction \n");
+        // If we're not running now the instruction will complete in a dcache
+        // response callback or the instruction faulted and has started an
+        // ifetch
+        if (_status == TimingHelperCPU::Running) {
+            if (fault != NoFault && traceData) {
+                // If there was a fault, we shouldn't trace this instruction.
+                delete traceData;
+                traceData = NULL;
+                DPRINTF(SimpleCPU, "Fault detected, deleting trace data\n");
+            }
+            DPRINTF(SimpleCPU, "Completed Executing Memory Instruction \n");
+           postExecute();
+            // @todo remove me after debugging with legion done
+            if (curStaticInst && (!curStaticInst->isMicroop() ||
+                    curStaticInst->isFirstMicroop()))
+                instCnt++;
+            advanceInst(fault);
+        }
+    } else if (curStaticInst) {
+        // non-memory instruction: execute completely now
+        Fault fault = curStaticInst->execute(this, traceData);
+
+        
+
+        DPRINTF(SimpleCPU, "Executed Instruction %s \n",getValueString(curStaticInst));
+
+        // keep an instruction count
+        if (fault == NoFault)
+            countInst();
+        else if (traceData && !DTRACE(ExecFaulting)) {
+            delete traceData;
+            traceData = NULL;
+        }
+
+        postExecute();
+        // @todo remove me after debugging with legion done
+        if (curStaticInst && (!curStaticInst->isMicroop() ||
+                curStaticInst->isFirstMicroop()))
+            instCnt++;
+        advanceInst(fault);
+    } else {
+        cout << "We are not supposed to reach this point" << endl;
+        exit(-1);
+    }
+
+}
+
+void
+TimingHelperCPU::completeDataAccess(PacketPtr pkt) {
+    // received a response from the dcache: complete the load or store
+    // instruction
+    DPRINTF(SimpleCPU,"Returning from a data access\n");
+    assert(!pkt->isError());
+    assert(_status == DcacheWaitResponse || _status == DTBWaitResponse ||
+            pkt->req->getFlags().isSet(Request::NO_ACCESS));
+
+    numCycles += curCycle() - previousCycle;
+    previousCycle = curCycle();
+
+    if (pkt->senderState) {
+        SplitFragmentSenderState * send_state =
+                dynamic_cast<SplitFragmentSenderState *> (pkt->senderState);
+        assert(send_state);
+        delete pkt->req;
+        delete pkt;
+        PacketPtr big_pkt = send_state->bigPkt;
+        delete send_state;
+
+        SplitMainSenderState * main_send_state =
+                dynamic_cast<SplitMainSenderState *> (big_pkt->senderState);
+        assert(main_send_state);
+        // Record the fact that this packet is no longer outstanding.
+        assert(main_send_state->outstanding != 0);
+        main_send_state->outstanding--;
+
+        if (main_send_state->outstanding) {
+            cout<<"Something unexpected happened here"<<endl;
+            return;
+        } else {
+            delete main_send_state;
+            big_pkt->senderState = NULL;
+            pkt = big_pkt;
+        }
+    }
+
+    _status = TimingHelperCPU::Running;
+
+    Fault fault = curStaticInst->completeAcc(pkt, this, traceData);
+
+    // keep an instruction count
+    if (fault == NoFault)
+        countInst();
+    else if (traceData) {
+        // If there was a fault, we shouldn't trace this instruction.
+        delete traceData;
+        traceData = NULL;
+    }
+
+    // the locked flag may be cleared on the response packet, so check
+    // pkt->req and not pkt to see if it was a load-locked
+    if (pkt->isRead() && pkt->req->isLLSC()) {
+        TheISA::handleLockedRead(thread, pkt->req);
+    }
+
+    delete pkt->req;
+    delete pkt;
+
+    postExecute();
+
+    advanceInst(fault);
+}
+
+void
+TimingHelperCPU::preExecute() {
+    DPRINTF(SimpleCPU,"pre-execute \n");
+    // maintain $r0 semantics
+    thread->setIntReg(ZeroReg, 0);
+#if THE_ISA == ALPHA_ISA
+    thread->setFloatReg(ZeroReg, 0.0);
+#endif // ALPHA_ISA
+
+    // check for instruction-count-based events
+    comInstEventQueue[0]->serviceEvents(numInst);
+    system->instEventQueue.serviceEvents(system->totalNumInsts);
+
+    // decode the instruction
+    DPRINTF(SimpleCPU,"Error due to fetch, refetched %x\n",inst);
+    
+    inst = gtoh(inst);
+
+    TheISA::PCState pcState = thread->pcState();
+
+    if (isRomMicroPC(pcState.microPC())) {
+        stayAtPC = false;
+        curStaticInst = microcodeRom.fetchMicroop(pcState.microPC(),
+                curMacroStaticInst);
+        DPRINTF(SimpleCPU, "Getting new microop from rom\n");
+    } else if (!curMacroStaticInst) {
+        //We're not in the middle of a macro instruction
+        StaticInstPtr instPtr = NULL;
+
+
+        TheISA::Decoder *decoder = &(thread->decoder);
+
+        //Predecode, ie bundle up an ExtMachInst
+        //If more fetch data is needed, pass it in.
+        Addr fetchPC = (pcState.instAddr() & PCMask) + fetchOffset;
+        DPRINTF(SimpleCPU, "This PC is thumb? %s\n", pcState.thumb() ? "True" : "False");
+        //if(decoder->needMoreBytes())
+        decoder->moreBytes(pcState, fetchPC, inst);
+        //else
+        //    decoder->process();
+        if (decoder->instReady()) {
+            DPRINTF(SimpleCPU, "Instruction is ready\n");
+        }
+        //Decode an instruction if one is ready. Otherwise, we'll have to
+        //fetch beyond the MachInst at the current pc.
+        instPtr = decoder->decode(pcState);
+        if (instPtr) {
+            DPRINTF(SimpleCPU, "Fetched Instruction is correct\n");
+            stayAtPC = false;
+            thread->pcState(pcState);
+        } else {
+            DPRINTF(SimpleCPU, "Fetched Instruction is not complete\n");
+            stayAtPC = true;
+            fetchOffset += sizeof (MachInst);
+        }
+
+        //If we decoded an instruction and it's microcoded, start pulling
+        //out micro ops
+        if (instPtr && instPtr->isMacroop()) {
+            DPRINTF(SimpleCPU, "Fetched Instruction is Macroop\n");
+            curMacroStaticInst = instPtr;
+            curStaticInst = curMacroStaticInst->fetchMicroop(pcState.microPC());
+        } else {
+            DPRINTF(SimpleCPU, "Fetched Instruction is not Macroop\n");
+            curStaticInst = instPtr;
+        }
+    } else {
+        DPRINTF(SimpleCPU, "Getting new microop from Macroop\n");
+        //Read the next micro op from the macro op
+        curStaticInst = curMacroStaticInst->fetchMicroop(pcState.microPC());
+
+    }
+
+    //If we decoded an instruction this "tick", record information about it.
+    if (curStaticInst) {
+#if TRACING_ON
+        traceData = tracer->getInstRecord(curTick(), tc,
+                curStaticInst, thread->pcState(), curMacroStaticInst);
+
+        DPRINTF(Decode, "Decode: Decoded %s instruction: %#x\n",
+                curStaticInst->getName(), curStaticInst->machInst);
+#endif // TRACING_ON
+    }
+    DPRINTF(SimpleCPU, "Error due Instruction is: %s\n",
+            curStaticInst->
+            disassemble(pcState.instAddr()));
+    DPRINTF(SimpleCPU, "Decode: Decoded %s instruction: %#x\n",
+            curStaticInst->getName(), curStaticInst->machInst);
+
+}
+
+void
+TimingHelperCPU::postExecute() {
+    DPRINTF(SimpleCPU,"postExecute\n");
+    assert(curStaticInst);
+    fillData(curStaticInst);
+    TheISA::PCState pc = tc->pcState();
+    Addr instAddr = pc.instAddr();
+    if (FullSystem && thread->profile) {
+        bool usermode = TheISA::inUserMode(tc);
+        thread->profilePC = usermode ? 1 : instAddr;
+        ProfileNode *node = thread->profile->consume(tc, curStaticInst);
+        if (node)
+            thread->profileNode = node;
+    }
+
+    if (curStaticInst->isMemRef()) {
+        numMemRefs++;
+    }
+
+    if (curStaticInst->isLoad()) {
+        ++numLoad;
+        comLoadEventQueue[0]->serviceEvents(numLoad);
+    }
+
+
+    /* Power model statistics */
+    //integer alu accesses
+    if (curStaticInst->isInteger()) {
+        numIntAluAccesses++;
+        numIntInsts++;
+    }
+
+    //float alu accesses
+    if (curStaticInst->isFloating()) {
+        numFpAluAccesses++;
+        numFpInsts++;
+    }
+
+    //number of function calls/returns to get window accesses
+    if (curStaticInst->isCall() || curStaticInst->isReturn()) {
+        numCallsReturns++;
+    }
+
+    //the number of branch predictions that will be made
+    if (curStaticInst->isCondCtrl()) {
+        numCondCtrlInsts++;
+    }
+
+    //result bus acceses
+    if (curStaticInst->isLoad()) {
+        numLoadInsts++;
+    }
+
+    if (curStaticInst->isStore()) {
+        numStoreInsts++;
+    }
+    /* End power model statistics */
+
+    if (FullSystem)
+        traceFunctions(instAddr);
+
+    if (traceData) {
+        traceData->dump();
+        delete traceData;
+        traceData = NULL;
+    }
+}
+
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/helper/timing.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/helper/timing.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,605 @@
+/*
+ * Copyright (c) 2012-2013 ARM Limited
+ * All rights reserved
+ *
+ * The license below extends only to copyright in the software and shall
+ * not be construed as granting a license to any other intellectual
+ * property including but not limited to intellectual property relating
+ * to a hardware implementation of the functionality of the software
+ * licensed hereunder.  You may use the software subject to the license
+ * terms below provided that you ensure that this notice is replicated
+ * unmodified and in its entirety in all distributions of the software,
+ * modified or unmodified, in source code or in binary form.
+ *
+ * Copyright (c) 2002-2005 The Regents of The University of Michigan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Steve Reinhardt
+ */
+
+
+#include "cpu/helper/base.hh"
+#include"debug/SimpleCPU.hh"
+#include "cpu/translation.hh"
+#include "params/TimingHelperCPU.hh"
+#include<map>
+
+class TimingHelperCPU : public BaseHelperCPU {
+public:
+
+    TimingHelperCPU(TimingHelperCPUParams * params);
+    virtual ~TimingHelperCPU();
+
+    virtual void init();
+
+private:
+//    std::map<OpClass, int> delayTable;
+
+    /*
+     * If an access needs to be broken into fragments, currently at most two,
+     * the the following two classes are used as the sender state of the
+     * packets so the CPU can keep track of everything. In the main packet
+     * sender state, there's an array with a spot for each fragment. If a
+     * fragment has already been accepted by the CPU, aka isn't waiting for
+     * a retry, it's pointer is NULL. After each fragment has successfully
+     * been processed, the "outstanding" counter is decremented. Once the
+     * count is zero, the entire larger access is complete.
+     */
+    class SplitMainSenderState : public Packet::SenderState {
+    public:
+        int outstanding;
+        PacketPtr fragments[2];
+
+        int
+        getPendingFragment() {
+            if (fragments[0]) {
+                return 0;
+            } else if (fragments[1]) {
+                return 1;
+            } else {
+                return -1;
+            }
+        }
+    };
+
+    class SplitFragmentSenderState : public Packet::SenderState {
+    public:
+
+        SplitFragmentSenderState(PacketPtr _bigPkt, int _index) :
+        bigPkt(_bigPkt), index(_index) {
+        }
+        PacketPtr bigPkt;
+        int index;
+
+        void
+        clearFromParent() {
+            SplitMainSenderState * main_send_state =
+                    dynamic_cast<SplitMainSenderState *> (bigPkt->senderState);
+            main_send_state->fragments[index] = NULL;
+        }
+    };
+
+    class FetchTranslation : public BaseTLB::Translation {
+    protected:
+        TimingHelperCPU *cpu;
+
+    public:
+
+        FetchTranslation(TimingHelperCPU *_cpu)
+        : cpu(_cpu) {
+        }
+
+        void
+        markDelayed() {
+            assert(cpu->_status == BaseHelperCPU::Running);
+            cpu->_status = ITBWaitResponse;
+        }
+
+        void
+        finish(Fault fault, RequestPtr req, ThreadContext *tc,
+                BaseTLB::Mode mode) {
+            cpu->sendFetch(fault, req, tc);
+        }
+    };
+
+    FetchTranslation fetchTranslation;
+
+    void sendData(RequestPtr req, uint8_t *data, uint64_t *res, bool read);
+    void sendSplitData(RequestPtr req1, RequestPtr req2, RequestPtr req,
+            uint8_t *data, bool read);
+
+    void translationFault(Fault fault);
+
+    void buildPacket(PacketPtr &pkt, RequestPtr req, bool read);
+    void buildSplitPacket(PacketPtr &pkt1, PacketPtr &pkt2,
+            RequestPtr req1, RequestPtr req2, RequestPtr req,
+            uint8_t *data, bool read);
+
+    bool handleReadPacket(PacketPtr pkt);
+    // This function always implicitly uses dcache_pkt.
+    bool handleWritePacket();
+
+    /**
+     * A TimingCPUPort overrides the default behaviour of the
+     * recvTiming and recvRetry and implements events for the
+     * scheduling of handling of incoming packets in the following
+     * cycle.
+     */
+    class TimingCPUPort : public MasterPort {
+    public:
+
+        TimingCPUPort(const std::string& _name, TimingHelperCPU* _cpu)
+        : MasterPort(_name, _cpu), cpu(_cpu), retryEvent(this) {
+        }
+
+    protected:
+
+        /**
+         * Snooping a coherence request, do nothing.
+         */
+        virtual void recvTimingSnoopReq(PacketPtr pkt) {
+        }
+
+        TimingHelperCPU* cpu;
+
+        struct TickEvent : public Event {
+            PacketPtr pkt;
+            TimingHelperCPU *cpu;
+
+            TickEvent(TimingHelperCPU *_cpu) : pkt(NULL), cpu(_cpu) {
+            }
+
+            const char *description() const {
+                return "Timing CPU tick";
+            }
+            void schedule(PacketPtr _pkt, Tick t);
+        };
+
+        EventWrapper<MasterPort, &MasterPort::sendRetry> retryEvent;
+    };
+
+    class IcachePort : public TimingCPUPort {
+    public:
+
+        IcachePort(TimingHelperCPU *_cpu)
+        : TimingCPUPort(_cpu->name() + ".icache_port", _cpu),
+        tickEvent(_cpu) {
+        }
+
+    protected:
+
+        virtual bool recvTimingResp(PacketPtr pkt);
+
+        virtual void recvRetry();
+
+        struct ITickEvent : public TickEvent {
+
+            ITickEvent(TimingHelperCPU *_cpu)
+            : TickEvent(_cpu) {
+            }
+            void process();
+
+            const char *description() const {
+                return "Timing CPU icache tick";
+            }
+        };
+
+        ITickEvent tickEvent;
+
+    };
+
+    class DcachePort : public TimingCPUPort {
+    public:
+
+        DcachePort(TimingHelperCPU *_cpu)
+        : TimingCPUPort(_cpu->name() + ".dcache_port", _cpu),
+        tickEvent(_cpu) {
+        }
+
+    protected:
+
+        virtual bool recvTimingResp(PacketPtr pkt);
+
+        virtual void recvRetry();
+
+        struct DTickEvent : public TickEvent {
+
+            DTickEvent(TimingHelperCPU *_cpu)
+            : TickEvent(_cpu) {
+            }
+            void process();
+
+            const char *description() const {
+                return "Timing CPU dcache tick";
+            }
+        };
+
+        DTickEvent tickEvent;
+
+    };
+
+    IcachePort icachePort;
+    DcachePort dcachePort;
+
+    PacketPtr ifetch_pkt;
+    PacketPtr dcache_pkt;
+
+    Tick previousCycle;
+
+protected:
+
+    /** Return a reference to the data port. */
+    virtual MasterPort &getDataPort() {
+        return dcachePort;
+    }
+
+    /** Return a reference to the instruction port. */
+    virtual MasterPort &getInstPort() {
+        return icachePort;
+    }
+
+
+    dataPhase curPhase;
+
+public:
+
+    unsigned int drain(DrainManager *drain_manager);
+    void drainResume();
+
+    void switchOut();
+
+    void takeOverFrom(BaseCPU *oldCPU);
+
+    void verifyMemoryMode() const;
+
+    virtual void activateContext(ThreadID thread_num, Cycles delay);
+
+    virtual void suspendContext(ThreadID thread_num);
+
+    Fault readMem(Addr addr, uint8_t *data, unsigned size, unsigned flags);
+
+    Fault writeMem(uint8_t *data, unsigned size,
+            Addr addr, unsigned flags, uint64_t *res);
+    void cpuDecode();
+
+    void cpuFetch();
+
+    void cpuExecute();
+
+
+
+    void phaseSwitcher(dataPhase pPhase);
+
+
+    void correctorTrigger();
+
+    void fetch();
+    void sendFetch(Fault fault, RequestPtr req, ThreadContext *tc);
+    void completeIfetch(PacketPtr);
+
+    void IfetchHelper();
+
+    void execution();
+
+    void completeDataAccess(PacketPtr pkt);
+    void advanceInst(Fault fault);
+
+    void addCorrectorEvent();
+
+    /** This function is used by the page table walker to determine if it could
+     * translate the a pending request or if the underlying request has been
+     * squashed. This always returns false for the simple timing CPU as it never
+     * executes any instructions speculatively.
+     * @ return Is the current instruction squashed?
+     */
+    bool isSquashed() const {
+        return false;
+    }
+
+    /**
+     * Print state of address in memory system via PrintReq (for
+     * debugging).
+     */
+    void printAddr(Addr a);
+
+    /**
+     * Finish a DTB translation.
+     * @param state The DTB translation state.
+     */
+    void finishTranslation(WholeTranslationState *state);
+
+private:
+    typedef EventWrapper<TimingHelperCPU, &TimingHelperCPU::fetch> FetchEvent;
+
+    FetchEvent fetchEvent;
+
+    typedef EventWrapper<TimingHelperCPU, &TimingHelperCPU::correctorTrigger> CorrectorEvent;
+
+    CorrectorEvent cEvent;
+
+    struct IprEvent : Event {
+        Packet *pkt;
+        TimingHelperCPU *cpu;
+        IprEvent(Packet *_pkt, TimingHelperCPU *_cpu, Tick t);
+        virtual void process();
+        virtual const char *description() const;
+    };
+
+    /**
+     * Check if a system is in a drained state.
+     *
+     * We need to drain if:
+     * <ul>
+     * <li>We are in the middle of a microcode sequence as some CPUs
+     *     (e.g., HW accelerated CPUs) can't be started in the middle
+     *     of a gem5 microcode sequence.
+     *
+     * <li>Stay at PC is true.
+     * </ul>
+     */
+    bool isDrained() {
+        printf("Asked for Drain here\n");
+        return microPC() == 0 &&
+                !stayAtPC;
+    }
+
+    /**
+     * Try to complete a drain request.
+     *
+     * @returns true if the CPU is drained, false otherwise.
+     */
+    bool tryCompleteDrain();
+
+    /**
+     * Drain manager to use when signaling drain completion
+     *
+     * This pointer is non-NULL when draining and NULL otherwise.
+     */
+    DrainManager *drainManager;
+    bool dSend;
+public:
+    void preExecute();
+    void postExecute();
+
+    std::string getValueString(StaticInstPtr & inst){
+    ostringstream os;
+    os<<"Dests ";
+    for(int8_t i=0;i<inst->numDestRegs();i++){
+        RegIndex src_reg = inst->destRegIdx(i);
+        os<<inst->destRegIdx(i)<<"#";
+//        os<<inst->renamedDestRegIdx(i)<<":";
+        if (src_reg < TheISA::FP_Base_DepTag) {
+            os<<this->readDestIntRegOperand(inst,i)<<" ";
+        } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+            os<<this->readDestFloatRegOperand(inst,i)<<" ";
+        } else if (src_reg < TheISA::Max_DepTag) {
+            os<<this->readMiscReg(src_reg-TheISA::Max_DepTag)<<" ";
+        }
+        os<<";";
+    }
+    os<<"Srcs ";
+/*    for(int8_t i=0;i<inst->numSrcRegs();i++){
+        RegIndex src_reg = inst->srcRegIdx(i);
+        os<<inst->srcRegIdx(i)<<"#";
+//        os<<inst->renamedDestRegIdx(i)<<":";
+         if (src_reg < TheISA::FP_Base_DepTag) {
+            os<<this->readIntRegOperand(inst,i)<<" ";
+        } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+            os<<this->readFloatRegOperand(inst,i)<<" ";
+        } else if (src_reg < TheISA::Max_DepTag) {
+            os<<this->readMiscReg(src_reg-TheISA::Max_DepTag)<<" ";
+        }
+         os<<";";
+    }
+*/    return os.str();
+
+
+    }
+
+    InstrIOPortsHandler* getPortHandler() {
+        return this->ioh;
+    }
+
+    void setIOPort(portInterface* ioport) {
+        helperPort = ioport;
+    }
+
+    portInterface* getIOPort() {
+        getPortHandler()->addMasterConnection(helperPort = new portInterface(true));
+        return helperPort;
+    }
+
+    bool sampleIOPort() {
+        return helperPort->isAvailable();
+    }
+
+    void pullData() {
+        PortedData = helperPort->getData();
+        this->curStaticInst = PortedData->getInstPtr();
+        thread->setDTBPtr(PortedData->getDTLB());
+        thread->setITBPtr(PortedData->getITLB());
+        thread->pcState(PortedData->getPC());
+    }
+
+    bool isPortEmpty() {
+        return helperPort->isEmpty();
+    }
+
+    TheISA::PCState pullData(StaticInstPtr& instPtr) {
+        timeTaken = uint64_t();
+
+        PortedData = helperPort->getData();
+        DPRINTF(SimpleCPU, "The packet Read is :%i\n", PortedData);
+        if (PortedData == NULL) {
+            printf("Wrong data read\n");
+            exit(-1);
+        }
+        instPtr = PortedData->getInstPtr();
+
+        thread->setDTBPtr(PortedData->getDTLB());
+        thread->setITBPtr(PortedData->getITLB());
+
+        thread->setProcessPtr(PortedData->getProcess());
+        for (int i = 0; i < PortedData->getNumSrcRegs(); i++) {
+            if (PortedData->getSrcType(i) == enInt) {
+                thread->setIntReg(PortedData->getSrcData(i).index, PortedData->getSrcData(i).data.i);
+            }
+
+
+            if (PortedData->getSrcType(i) == enFloat) {
+                thread->setFloatReg(PortedData->getSrcData(i).index, (FloatReg) PortedData->getSrcData(i).data.f);
+            }
+
+            if (PortedData->getSrcType(i) == enMisc) {
+                thread->setMiscReg(PortedData->getSrcData(i).index, (const MiscReg) PortedData->getSrcData(i).data.i);
+            }
+        }
+
+        return PortedData->getPC();
+    }
+
+    bool getData() {
+        PortedData = helperPort->getData();
+        DPRINTF(SimpleCPU, "The packet Read is :%i\n", PortedData);
+        if (PortedData == NULL) {
+            printf("Wrong data read\n");
+            exit(-1);
+        }
+        if(PortedData->getPhase()==completedP){
+
+        DPRINTF(SimpleCPU, "The packet is completedP :%i\n", PortedData);
+            delete PortedData;
+            return false;
+        }
+        for (int i = 0; i < PortedData->getNumSrcRegs(); i++) {
+            if (PortedData->getSrcType(i) == enInt) {
+                thread->setIntReg(PortedData->getSrcData(i).index, PortedData->getSrcData(i).data.i);
+            }
+
+
+            if (PortedData->getSrcType(i) == enFloat) {
+                thread->setFloatReg(PortedData->getSrcData(i).index, (FloatReg) PortedData->getSrcData(i).data.f);
+            }
+
+            if (PortedData->getSrcType(i) == enMisc) {
+                thread->setMiscReg(PortedData->getSrcData(i).index, (const MiscReg) PortedData->getSrcData(i).data.i);
+            }
+        }
+        return true;
+    }
+
+    bool locallyAvailable(RegIndex index, CommPack* pkt,dataChar dc,int &indd){
+        indd=-1;
+        for(int i=0;i<pkt->getNumDestRegs();i++){
+            if((pkt->getDestData(i).index==index)&&(dc==pkt->getDestType(i))){
+                indd=i;
+                DPRINTF(Squasher,"Register was locally available\n");
+                return true;
+            }
+        }
+        return false;;
+    }
+    
+    void fillData(StaticInstPtr instPtr){
+        PortedData->setNumDestRegs(instPtr->numDestRegs()+PortedData->getNumDestRegs());
+        
+        for (int i = 0; i < instPtr->numDestRegs(); i++) {
+            int indd;
+            RegIndex dest_reg = instPtr->destRegIdx(i);
+            if (dest_reg < TheISA::FP_Base_DepTag) {
+                if(locallyAvailable(dest_reg,PortedData,enInt,indd)){
+                    cout<<"t1"<<endl;
+                    PortedData->modifyDestData(thread->readIntReg(instPtr->destRegIdx(i)),indd);
+                }else{
+                    PortedData->setDestType(enInt, i);
+                    PortedData->setDestData(thread->readIntReg(instPtr->destRegIdx(i)), instPtr->destRegIdx(i));
+                }
+            } else if (dest_reg < TheISA::Ctrl_Base_DepTag) {
+                if(locallyAvailable(dest_reg- TheISA::FP_Base_DepTag,PortedData,enFloat,indd)){
+                    cout<<"t2"<<endl;
+                    PortedData->modifyDestData(thread->readFloatReg(instPtr->destRegIdx(i) - TheISA::FP_Base_DepTag),indd);
+                }else{
+                    PortedData->setDestType(enFloat, i);
+                    PortedData->setDestData(thread->readFloatReg(instPtr->destRegIdx(i) - TheISA::FP_Base_DepTag), instPtr->destRegIdx(i)- TheISA::FP_Base_DepTag);
+                }
+            } else if (dest_reg < TheISA::Max_DepTag) {
+                if(locallyAvailable(dest_reg - TheISA::Ctrl_Base_DepTag,PortedData,enMisc,indd)){
+                    cout<<"t3"<<endl;
+//                    PortedData->modifyDestData(thread->readMiscReg(instPtr->destRegIdx(i)- TheISA::Ctrl_Base_DepTag),indd);
+                }else{
+                    PortedData->setDestType(enMisc, i);
+//                    PortedData->setDestData(thread->readMiscReg(instPtr->destRegIdx(i)- TheISA::Ctrl_Base_DepTag), instPtr->destRegIdx(i)- TheISA::Ctrl_Base_DepTag);
+                }
+            }
+        }           
+    }
+
+    void pushData() {
+        timeTaken = uint64_t() - timeTaken;
+        idleRerunCycles += timeTaken;
+        cpuExecTime[curCPU]+=timeTaken;
+         PortedData->setPhase(fetchP);
+        StaticInstPtr instPtr = PortedData->getInstPtr();
+        fillData(instPtr);
+        DPRINTF(Squasher, "Pushing packet %i to faulty cpu\n", PortedData);
+        helperPort->setData(PortedData);
+    }
+
+    void cpuRequestData(StaticInstPtr& instPtr) {
+        DPRINTF(Squasher, "Requesting data using %i from faulty cpu\n", PortedData);
+        PortedData->setInstPtr(instPtr);
+        PortedData->setPhase(dataRequest);
+        helperPort->setData(PortedData);
+    }
+
+    void sendInstruction(StaticInstPtr& instPtr) {
+        DPRINTF(Squasher, "Sending instruction as data using %i from faulty cpu\n", PortedData);
+        PortedData->setInstPtr(instPtr);
+        PortedData->setPhase(fetchP);
+        helperPort->setData(PortedData);
+    }
+
+    int queryDelay() {
+        PortedData = helperPort->readData();
+
+        if (PortedData == NULL) {
+            printf("Wrong data read\n");
+            exit(-1);
+        }
+//        int val=(int)PortedData->getInstPtr()->opClass();
+        DPRINTF(SimpleCPU,"Delay is %lu for opClass %d\n",delayTable[PortedData->getInstPtr()->opClass()],PortedData->getInstPtr()->opClass());
+        if (!locked) {
+            return delayTable[PortedData->getInstPtr()->opClass()]+1;
+        } else {
+            return delayTable[PortedData->getInstPtr()->opClass()]+1;
+        }
+    }
+
+    void clearData() {
+    }
+
+};
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/O3CPU.py
--- a/src/cpu/o3/O3CPU.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/O3CPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -90,7 +90,7 @@
                "delay")
     renameToROBDelay = Param.Cycles(1, "Rename to reorder buffer delay")
     commitWidth = Param.Unsigned(8, "Commit width")
-    squashWidth = Param.Unsigned(8, "Squash width")
+    squashWidth = Param.Unsigned(40, "Squash width")
     trapLatency = Param.Cycles(13, "Trap latency")
     fetchTrapLatency = Param.Cycles(1, "Fetch trap latency")
 
@@ -125,10 +125,13 @@
     smtROBThreshold = Param.Int(100, "SMT ROB Threshold Sharing Parameter")
     smtCommitPolicy = Param.String('RoundRobin', "SMT Commit Policy")
 
+
     branchPred = BranchPredictor(numThreads = Parent.numThreads)
     needsTSO = Param.Bool(buildEnv['TARGET_ISA'] == 'x86',
                           "Enable TSO Memory model")
 
+
+
     def addCheckerCpu(self):
         if buildEnv['TARGET_ISA'] in ['arm']:
             from ArmTLB import ArmTLB
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/SConscript
--- a/src/cpu/o3/SConscript	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/SConscript	Wed Aug 05 11:39:08 2015 +0100
@@ -62,6 +62,8 @@
     Source('scoreboard.cc')
     Source('store_set.cc')
     Source('thread_context.cc')
+    Source('convertor.cc')
+    Source('detector.cc')
 
     DebugFlag('LSQ')
     DebugFlag('LSQUnit')
@@ -74,7 +76,7 @@
     DebugFlag('Writeback')
 
     CompoundFlag('O3CPUAll', [ 'Fetch', 'Decode', 'Rename', 'IEW', 'Commit',
-        'IQ', 'ROB', 'FreeList', 'LSQ', 'LSQUnit', 'StoreSet', 'MemDepUnit',
+        'IQ', 'ROB', 'FreeList', 'LSQ', 'LSQUnit', 'StoreSet', 'MemDepUnit', 'Squasher',
         'DynInst', 'O3CPU', 'Activity', 'Scoreboard', 'Writeback' ])
 
     SimObject('O3Checker.py')
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/comm.hh
--- a/src/cpu/o3/comm.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/comm.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -68,6 +68,30 @@
     bool clearFetchFault;
 };
 
+
+template<class Impl>
+struct DetectorsStruct {
+    typedef typename Impl::DynInstPtr DynInstPtr;
+
+    int instrSize;
+
+    int statSize;
+    
+    int pcSize;
+
+    
+    
+    TheISA::PCState pcState[Impl::MaxWidth];
+
+    DynInstPtr insts[Impl::MaxWidth];
+    StaticInstPtr statInsts[Impl::MaxWidth];
+    int seqQue[Impl::MaxWidth];
+    ThreadID tids[Impl::MaxWidth];
+    Fault fetchFault;
+    InstSeqNum fetchFaultSN;
+    
+};
+
 /** Struct that defines the information passed from decode to rename. */
 template<class Impl>
 struct DefaultDecodeDefaultRename {
@@ -125,15 +149,28 @@
         DynInstPtr mispredictInst;
         DynInstPtr squashInst;
         InstSeqNum doneSeqNum;
-        Addr mispredPC;
-        uint64_t branchAddr;
-        unsigned branchCount;
         bool squash;
         bool predIncorrect;
         bool branchMispredict;
         bool branchTaken;
     };
 
+    struct detectorComm {
+        bool working;
+        typedef enum{
+            fetchStage,
+            renameStage,
+            commitStage
+        }repairStage;
+        repairStage stage;
+        bool isMacroinst;
+        bool isReady;
+        StaticInstPtr instr[Impl::MaxMicro];
+        bool clearFetchFault;
+    };
+    
+    detectorComm detectorInfo;
+
     decodeComm decodeInfo[Impl::MaxThreads];
 
     struct renameComm {
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/commit.hh
--- a/src/cpu/o3/commit.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/commit.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -94,6 +94,7 @@
     typedef typename CPUPol::FetchStruct FetchStruct;
     typedef typename CPUPol::IEWStruct IEWStruct;
     typedef typename CPUPol::RenameStruct RenameStruct;
+    typedef typename CPUPol::DetectorStruct DetectorStruct;
 
     typedef typename CPUPol::Fetch Fetch;
     typedef typename CPUPol::IEW IEW;
@@ -131,6 +132,8 @@
         TrapPending,
         FetchTrapPending,
         SquashAfterPending, //< Committing instructions before a squash.
+        waitValue,
+        waitInstruction
     };
 
     /** Commit policy for SMT mode. */
@@ -151,6 +154,9 @@
     CommitPolicy commitPolicy;
 
   public:
+      bool isHalted(ThreadID tid){
+          return (commitStatus[tid]==Idle||_status==Inactive);
+      }
     /** Construct a DefaultCommit with the given parameters. */
     DefaultCommit(O3CPU *_cpu, DerivO3CPUParams *params);
 
@@ -170,6 +176,8 @@
 
     /** Sets the pointer to the queue coming from rename. */
     void setRenameQueue(TimeBuffer<RenameStruct> *rq_ptr);
+    
+    void setDetectorQueue(TimeBuffer<DetectorStruct> *detq_ptr);
 
     /** Sets the pointer to the queue coming from IEW. */
     void setIEWQueue(TimeBuffer<IEWStruct> *iq_ptr);
@@ -253,7 +261,10 @@
      * to be sent back to previous stages.
      */
     bool changedROBEntries();
+    
 
+    void squashRerun(ThreadID tid);
+    void squashRerun2(ThreadID tid);
     /** Squashes all in flight instructions. */
     void squashAll(ThreadID tid);
 
@@ -367,9 +378,21 @@
 
     /** Rename instruction queue interface, for ROB. */
     TimeBuffer<RenameStruct> *renameQueue;
+     
+    TimeBuffer<DetectorStruct> *detectorQueue;
 
     /** Wire to read information from rename queue. */
     typename TimeBuffer<RenameStruct>::wire fromRename;
+    
+    typename TimeBuffer<DetectorStruct>::wire toDetector;
+
+    InstSeqNum localSqN[Impl::MaxThreads];
+
+    InstSeqNum invalidSeqNum[Impl::MaxThreads];
+
+    bool validState[Impl::MaxThreads]; 
+    
+    TheISA::PCState invalidPcState[Impl::MaxThreads];
 
   public:
     /** ROB interface. */
@@ -409,6 +432,7 @@
      * stage once squashing starts.
      */
     DynInstPtr squashAfterInst[Impl::MaxThreads];
+    DynInstPtr RerunInst[Impl::MaxThreads];
 
     /** Priority List used for Commit Policy */
     std::list<ThreadID> priority_list;
@@ -488,6 +512,8 @@
     /** Updates commit stats based on this instruction. */
     void updateComInstStats(DynInstPtr &inst);
 
+    std::string getRegValueString(DynInstPtr& inst);
+
     /** Stat for the total number of squashed instructions discarded by commit.
      */
     Stats::Scalar commitSquashedInsts;
@@ -529,6 +555,8 @@
     Stats::Scalar commitEligibleSamples;
     /** Number of instructions not committed due to bandwidth limits. */
     Stats::Vector commitEligible;
+
+    Stats::Scalar commitReSquashes;
 };
 
 #endif // __CPU_O3_COMMIT_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/commit_impl.hh
--- a/src/cpu/o3/commit_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/commit_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -59,6 +59,8 @@
 #include "debug/Commit.hh"
 #include "debug/CommitRate.hh"
 #include "debug/Drain.hh"
+#include "debug/Squasher.hh"
+#include "debug/Decoder.hh"
 #include "debug/ExecFaulting.hh"
 #include "debug/O3PipeView.hh"
 #include "params/DerivO3CPU.hh"
@@ -83,6 +85,7 @@
     commit->trapSquash[tid] = true;
 }
 
+
 template <class Impl>
 const char *
 DefaultCommit<Impl>::TrapEvent::description() const
@@ -148,6 +151,10 @@
         pc[tid].set(0);
         lastCommitedSeqNum[tid] = 0;
         squashAfterInst[tid] = NULL;
+        localSqN[tid] = -1;
+        validState[tid]=true;
+        invalidSeqNum[tid]=-1;
+        invalidPcState[tid]=-1;
     }
     interrupt = NoFault;
 }
@@ -168,6 +175,9 @@
         .name(name() + ".commitSquashedInsts")
         .desc("The number of squashed insts skipped by commit")
         .prereq(commitSquashedInsts);
+    commitReSquashes
+            .name(name() + ".commitReSquashedCount")
+        .desc("The number of squashed insts rerun by commit");
     commitSquashEvents
         .name(name() + ".commitSquashEvents")
         .desc("The number of times commit is told to squash")
@@ -300,6 +310,16 @@
     // Setup wire to get instructions from rename (for the ROB).
     fromFetch = fetchQueue->getWire(-fetchToCommitDelay);
 }
+template<class Impl>
+void
+DefaultCommit<Impl>::setDetectorQueue(TimeBuffer<DetectorStruct> *dq_ptr)
+{
+    detectorQueue = dq_ptr;
+
+    // Create wire to write information to proper place in fetch queue.
+    toDetector = detectorQueue->getWire(1);
+}
+
 
 template <class Impl>
 void
@@ -543,6 +563,100 @@
     tcSquash[tid] = true;
 }
 
+
+
+template <class Impl>
+void
+DefaultCommit<Impl>::squashRerun(ThreadID tid)
+{
+    // If we want to include the squashing instruction in the squash,
+    // then use one older sequence number.
+    // Hopefully this doesn't mess things up.  Basically I want to squash
+    // all instructions of this thread.
+    DPRINTF(Squasher,"Placing Instruction on Helper\n");
+//    bool ret=cpu->placeInstHelper(RerunInst[tid],tid);
+//    toDetector->insts[toDetector->instrSize]= RerunInst[tid];
+//    toDetector->tids[toDetector->instrSize]= tid;
+//
+//    toDetector->instrSize++;
+//    
+//    DPRINTF(Squasher,"Current buffer size is %d allowed width is %d\n",toDetector->instrSize,Impl::MaxWidth);
+
+//    bool ret=(toDetector->instrSize>=Impl::MaxWidth);
+//
+//    if(ret){
+//        DPRINTF(Squasher,"Could not place instruction on the ioi, exiting\n");
+//        exit(-1);
+//   }
+    commitReSquashes++;
+    InstSeqNum squashed_inst = invalidSeqNum[tid];
+    // All younger instructions will be squashed. Set the sequence
+    // number as the youngest instruction in the ROB (0 in this case.
+    // Hopefully nothing breaks.)
+    youngestSeqNum[tid] = lastCommitedSeqNum[tid];
+
+    commitStatus[tid] = ROBSquashing;
+    rob->squash(squashed_inst, tid);
+    changedROBNumEntries[tid] = true;
+
+    // Send back the sequence number of the squashed instruction.
+    toIEW->commitInfo[tid].doneSeqNum = squashed_inst;
+
+    // Send back the squash signal to tell stages that they should
+    // squash.
+    toIEW->commitInfo[tid].squash = true;
+
+    // Send back the rob squashing signal so other stages know that
+    // the ROB is in the process of squashing.
+    toIEW->commitInfo[tid].robSquashing = true;
+
+    toIEW->commitInfo[tid].mispredictInst = NULL;
+    toIEW->commitInfo[tid].squashInst = NULL;
+
+    toIEW->commitInfo[tid].pc = invalidPcState[tid];
+    
+    DPRINTF(Squasher, "The PC for rerun is %s %d %d\n",invalidPcState[tid], invalidPcState[tid].instAddr(),invalidPcState[tid].nextInstAddr() );
+}
+
+
+template <class Impl>
+void
+DefaultCommit<Impl>::squashRerun2(ThreadID tid)
+{
+    // If we want to include the squashing instruction in the squash,
+    // then use one older sequence number.
+    // Hopefully this doesn't mess things up.  Basically I want to squash
+    // all instructions of this thread.
+    InstSeqNum squashed_inst = invalidSeqNum[tid];
+    // All younger instructions will be squashed. Set the sequence
+    // number as the youngest instruction in the ROB (0 in this case.
+    // Hopefully nothing breaks.)
+    youngestSeqNum[tid] = lastCommitedSeqNum[tid];
+
+    commitStatus[tid] = ROBSquashing;
+    rob->squash(squashed_inst, tid);
+    changedROBNumEntries[tid] = true;
+
+    // Send back the sequence number of the squashed instruction.
+//    toIEW->commitInfo[tid].doneSeqNum = squashed_inst;
+
+    // Send back the squash signal to tell stages that they should
+    // squash.
+//    toIEW->commitInfo[tid].squash = true;
+
+    // Send back the rob squashing signal so other stages know that
+    // the ROB is in the process of squashing.
+//    toIEW->commitInfo[tid].robSquashing = true;
+
+//    toIEW->commitInfo[tid].mispredictInst = NULL;
+//    toIEW->commitInfo[tid].squashInst = NULL;
+
+//    toIEW->commitInfo[tid].pc = invalidPcState[tid];
+    
+    DPRINTF(Squasher, "The [sn:%d]  PC for rerun is %s %d %d\n",squashed_inst, invalidPcState[tid], invalidPcState[tid].instAddr(),invalidPcState[tid].nextInstAddr() );
+}
+
+
 template <class Impl>
 void
 DefaultCommit<Impl>::squashAll(ThreadID tid)
@@ -585,7 +699,7 @@
 {
     squashAll(tid);
 
-    DPRINTF(Commit, "Squashing from trap, restarting at PC %s\n", pc[tid]);
+    DPRINTF(Commit, "Squashing from trap, restarting at PC %s with instAddr as  %d\n", pc[tid],pc[tid].instAddr());
 
     thread[tid]->trapPending = false;
     thread[tid]->noSquashFromTC = false;
@@ -604,6 +718,7 @@
     squashAll(tid);
 
     DPRINTF(Commit, "Squashing from TC, restarting at PC %s\n", pc[tid]);
+    DPRINTF(Commit, "Instruction Address at PC is %d\n",pc[tid].instAddr());
 
     thread[tid]->noSquashFromTC = false;
     assert(!thread[tid]->trapPending);
@@ -619,7 +734,7 @@
 DefaultCommit<Impl>::squashFromSquashAfter(ThreadID tid)
 {
     DPRINTF(Commit, "Squashing after squash after request, "
-            "restarting at PC %s\n", pc[tid]);
+            "restarting at PC %s with inst Addr %d \n", pc[tid],pc[tid].instAddr());
 
     squashAll(tid);
     // Make sure to inform the fetch stage of which instruction caused
@@ -830,7 +945,7 @@
             // thread now.
             squashFromSquashAfter(tid);
         }
-
+        
         // Squashed sequence number must be older than youngest valid
         // instruction in the ROB. This prevents squashes from younger
         // instructions overriding squashes from older instructions.
@@ -853,6 +968,7 @@
             DPRINTF(Commit, "[tid:%i]: Redirecting to PC %#x\n",
                     tid,
                     fromIEW->pc[tid].nextInstAddr());
+    DPRINTF(Commit, "Instruction Address at PC is %d\n",pc[tid].instAddr());
 
             commitStatus[tid] = ROBSquashing;
 
@@ -892,12 +1008,19 @@
             }
 
             toIEW->commitInfo[tid].pc = fromIEW->pc[tid];
+    DPRINTF(Commit, "Instruction Address at PC is %d \n",pc[tid].instAddr());
 
             if (toIEW->commitInfo[tid].mispredictInst) {
                 ++branchMispredicts;
             }
         }
-
+//        else{
+//            if (!validState[tid]) {
+//                squashRerun2(tid);                
+//                validState[tid] = true;
+//                wroteToTimeBuffer = true;
+//            }
+//        }
     }
 
     setNextStatus();
@@ -960,7 +1083,7 @@
     ////////////////////////////////////
 
     DPRINTF(Commit, "Trying to commit instructions in the ROB.\n");
-
+//    static int cntj=0;
     unsigned num_committed = 0;
 
     DynInstPtr head_inst;
@@ -984,6 +1107,14 @@
 
         assert(tid == commit_thread);
 
+        
+        if(head_inst->erronous()){
+            DPRINTF(Squasher,"Faulty Instruction \n");
+//            toDetector->insts[toDetector->instrSize] = RerunInst[tid];
+//            toDetector->tids[toDetector->instrSize] = tid;
+//            toDetector->instrSize++;
+        }
+        
         DPRINTF(Commit, "Trying to commit head instruction, [sn:%i] [tid:%i]\n",
                 head_inst->seqNum, tid);
 
@@ -1000,8 +1131,31 @@
 
             // Record that the number of ROB entries has changed.
             changedROBNumEntries[tid] = true;
-        } else {
+        
+        }
+//        else if(head_inst->erronous()&&!head_inst->isControl()&&!cpu->isRerun()){
+//            DPRINTF(Squasher, "Squashing head instruction due to damaged usage and will be reran [sn:%i] [tid:%i] [pc: %s]\n",
+//                    head_inst->seqNum, tid,  head_inst->pcState());
+//            validState[tid]=false;
+//            InstSeqNum squashed_inst=head_inst->seqNum;
+//            
+//            RerunInst[tid]=head_inst;
+//            
+////            DPRINTF(Commit, "Squashing head instruction due to damaged usage and will be reran [sn:%i] [tid:%i] [pc: %s]\n",
+////                    head_inst->seqNum, tid,  head_inst->pcState());
+//            squashed_inst--;
+//            invalidSeqNum[tid]=squashed_inst;
+//
+//            changedROBNumEntries[tid] = true;
+//
+//            invalidPcState[tid]= head_inst->pcState();
+//            rob->retireHead(commit_thread);
+////            squashAfter(tid, head_inst);
+//            squashRerun(tid);
+//        }
+        else {
             pc[tid] = head_inst->pcState();
+    DPRINTF(Commit, "Instruction Address at PC is %d\n",pc[tid].instAddr());
 
             // Increment the total number of non-speculative instructions
             // executed.
@@ -1033,14 +1187,17 @@
                 cpu->traceFunctions(pc[tid].instAddr());
 
                 TheISA::advancePC(pc[tid], head_inst->staticInst);
+    DPRINTF(Commit, "Instruction Address at PC is %d\n",pc[tid].instAddr());
 
                 // Keep track of the last sequence number commited
                 lastCommitedSeqNum[tid] = head_inst->seqNum;
 
                 // If this is an instruction that doesn't play nicely with
                 // others squash everything and restart fetch
-                if (head_inst->isSquashAfter())
+                if (head_inst->isSquashAfter()||head_inst->erronous()){
+                    DPRINTF(Squasher,"Faulty Instruction \n");
                     squashAfter(tid, head_inst);
+                }
 
                 if (drainPending) {
                     DPRINTF(Drain, "Draining: %i:%s\n", tid, pc[tid]);
@@ -1095,6 +1252,43 @@
 }
 
 template <class Impl>
+std::string
+DefaultCommit<Impl>::getRegValueString(DynInstPtr& inst)
+{
+    ostringstream os;
+    os<<"Dests ";
+    for(int8_t i=0;i<inst->numDestRegs();i++){
+        RegIndex src_reg = inst->destRegIdx(i);
+        os<<inst->destRegIdx(i)<<"#";
+//        os<<inst->renamedDestRegIdx(i)<<":";
+        if (src_reg < TheISA::FP_Base_DepTag) {
+            os<<cpu->readIntReg(inst->renamedDestRegIdx(i))<<" ";
+        } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+            os<<cpu->readFloatRegBits(inst->renamedDestRegIdx(i))<<" ";
+        } else if (src_reg < TheISA::Max_DepTag) {
+            os<<cpu->readMiscReg(inst->renamedDestRegIdx(i)- TheISA::Ctrl_Base_DepTag,inst->threadNumber)<<" ";
+        }
+        os<<";";
+    }
+    os<<"Srcs ";
+    for(int8_t i=0;i<inst->numSrcRegs();i++){
+        RegIndex src_reg = inst->srcRegIdx(i);
+        os<<inst->srcRegIdx(i)<<"#";
+//        os<<inst->renamedDestRegIdx(i)<<":";
+        if (src_reg < TheISA::FP_Base_DepTag) {
+            os<<cpu->readIntReg(inst->renamedSrcRegIdx(i))<<" ";
+        } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+            os<<cpu->readFloatRegBits(inst->renamedSrcRegIdx(i))<<" ";
+        } else if (src_reg < TheISA::Max_DepTag) {
+            os<<cpu->readMiscReg(inst->renamedSrcRegIdx(i)- TheISA::Ctrl_Base_DepTag,inst->threadNumber)<<" ";
+        }
+        os<<";";
+    }
+    return os.str();
+}
+
+
+template <class Impl>
 bool
 DefaultCommit<Impl>::commitHead(DynInstPtr &head_inst, unsigned inst_num)
 {
@@ -1248,6 +1442,14 @@
     }
     DPRINTF(Commit, "Committing instruction with [sn:%lli] PC %s\n",
             head_inst->seqNum, head_inst->pcState());
+//    DPRINTF(Commit,"Special %s instruction: %#x\n",
+//                head_inst->staticInst->getName(), head_inst->staticInst->machInst);
+    DPRINTF(Commit, "Gayo [tid:%i]: [sn:%lli] Instruction is: %s, registers are %s %x\n", tid,head_inst->seqNum,
+            head_inst->staticInst->
+            disassemble(head_inst->pcState().instAddr()),getRegValueString(head_inst),head_inst->staticInst->machInst.opcode);
+//    if(head_inst->staticInst->opClass()==IntAluOp){            
+//        DPRINTF(Commit, "Gayo %x::%s \n", head_inst->staticInst->machInst.opcode,head_inst->staticInst->getName());
+//    }
     if (head_inst->traceData) {
         head_inst->traceData->setFetchSeq(head_inst->seqNum);
         head_inst->traceData->setCPSeq(thread[tid]->numOp);
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/convertor.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/o3/convertor.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,279 @@
+#include"convertor.hh"
+#include <iterator>
+using namespace std;
+ 
+std::vector<std::string> aluList{
+"adc",//add with carry 
+"adcs",//add with carry and flag update 
+"add",//Add
+"addi_uop",
+"adds",//add with flag update
+"add_uop",
+"adr",//Form PC-relative Address
+"adrs",//Form PC-relative Address with flag update
+"and",//Bitwise AND
+"ands",//Bitwise AND with flag update
+"qadd16",//Saturating Add 16
+"qadd8",//Saturating Add 8
+"qadds",//Saturating Add
+"qasx",//saturating add and subtract with exchange
+"qdadds",//Saturating Double and Add
+"qdsubs",//Saturating Double and Subtract
+"qsax",//Saturating subtract and add with exchange
+"qsub",//Saturating Subtract
+"qsub16",//saturating subtract, two halfwords
+"qsub8",//saturating subtract, four words
+"qsubs",//saturating subtract
+"rsb",//Reverse Subtract
+"rsbs",//Reverse Subtract with flag update
+"rsc",//Reverse Subtract with carry
+"rscs",//Reverse Subtract with carr with flag update
+"sadd16s",//signed add, two halfwords
+"sadd8s",//signed add, four words
+"sasx",//signed add and subtract with exchange
+"sasxs",// signed add and subtract with exchange
+"sbc",//Subtract with Carry
+"sbcs",//Subtract with Carry with flag update
+"shadd16",//signed halving  add, two halfwords
+"shadd8",//signed halving add, four words
+"shasx",//signed halving add and subtract with exchange
+"shasxs",//signed halving 
+"shsax",//signed halving subtract and add with exchange
+"shsaxs",//signed halving
+"shsub16",//signed halving  subtract, two halfwords
+"shsub8",//signed halving subtract, four words
+"ssub16s",//signed subtract, two halfwords
+"ssub8s",//signed subtract, four words
+"sub",//Subtract with Carry
+"subi_uop",
+"subs",//Subtract with Carry with flag update
+"sxtab",//Signed Extend and Add Byte
+"sxtab16",//Signed Extend and Add Byte 16
+"sxtah",//Signed Extend and Add Halfword
+"uadd16s",//unsigned add, two halfwords
+"uadd8s",//unsigned add, four words
+"uasxs",//unsigned add and subtract with exchange
+"uhadd16",//unsigned halving  add, two halfwords           
+"uhadd8",//unsigned halving add, four words                
+"uhasx",//unsigned halving add and subtract with exchange  
+"uhsax",//unsigned halving  subtract and add with exchange 
+"uhsub16",//unsigned halving  subtract, two halfwords      
+"uhsub8",//unsigned halving  subtract, four words  
+"uqadd16",//unsigned saturating  add, two halfwords
+"uqadd8",//unsigned saturating add, four words
+"uqasx",//unsigned saturating add and subtract with exchange
+"uqsax",//unsigned saturating  subtract and add with exchange
+"uqsub16",//unsigned saturating  subtract, two halfwords
+"uqsub8",//unsigned saturating  subtract, four words
+"usad8",//Unsigned Sum of Absolute Differences
+"usada8",//Unsigned Sum of Absolute Differences and Accumulate
+"usaxs",// unsigned  subtract and add with exchange
+"ssax",//Signed subtract and add with exchange
+"ssaxs",//Signed subtract and add with exchange with flag update
+"usub16s",//unsigned subtract, two halfwords
+"usub8s",//unsigned subtract, four words
+"uxtab",//Unsigned Extend and Add Byte
+"uxtab16",//Unsigned Extend and Add Byte 16
+"uxtah",//Unsigned Extend and Add Halfword
+};
+
+std::vector<std::string> shiftList{
+"ssat",//Signed Saturate
+"ssat16",//Signed Saturate 16
+"sxtb",//Signed Extend Byte
+"sxtb16",//Signed Extend Byte 16
+"sxth",//Signed Extend Halfword
+"usat",//Unsigned Saturate
+"usat16",//Unsigned Saturate 16
+"uxtb",//Unsigned Extend Byte
+"uxtb16",//Unsigned Extend Byte 16
+"uxth",//Unsigned Extend Halfword
+"pkhbt",//combine half words 
+"pkhtb",//combine half words
+"rev",//Byte-Reverse Word
+"rev16",//Byte-Reverse Packed Halfword
+"revsh",//Byte-Reverse Signed Halfword
+};
+
+std::vector<std::string> noList{
+"nop",//No Operation
+"b",//branch to address
+"bkpt",//breakpoint
+"bl",//Call a subroutine
+"blx",//Call a subroutine, change instruction set
+"bx",//Branch to target address, change instruction set
+"cps",//change processor state
+"dbg",//Debug Hint
+"dmb",//Data Memory Barrier
+"dsb",//Data Synchronization Barrier
+"enterx",//change from Thumb state to ThumbEE state 
+"hdrsh",
+"isb",//Instruction Synchronization Barrier
+"it",//If-Then 
+"ldmstm",//
+"ldr",//load 32-bit word 
+"ldrb",//load  8-bit unsigned byte
+"ldrbt",//load unpriviledged 8-bit unsigned byte
+"ldrd",//load Two 32-bit words
+"ldrh",//load 16-bit unsigned halfword
+"ldrht",//load unpriviledged 16-bit unsigned halfword
+"ldrsb",//load 8-bit signed byte
+"ldrsbt",//load unprivileged 8-bit signed byte
+"ldrsht",//load unprivileged 16-bit signed halfword
+"ldrt",//load unprivileged 32-bit word
+"leavex",//change from ThumbEE state to Thumb state
+"mcr",//coprocessor instruction
+"mov",//Copy operand to destination
+"movret_uop",
+"movs",//Copy operand to destination with flag update
+"movt",//move top
+"movts",//move top with flag update
+"mrc",//coprocessor instruction
+"mrs",//value from the APSR into an ARM core register.
+"msr",//value to the corresponding bits in the APSR.
+"rfe",
+"setend",//Set Endianness
+"sev",//Send Event
+"str",//store 32-bit word 
+"strb",//store  8-bit byte
+"strbt",//store unprivileged 8-bit byte
+"strd",//store Two 32-bit words
+"strh",//store 16-bit halfword
+"strht",//store unprivileged 16-bit halfword
+"strt",//store unprivileged 32-bit word
+"sub_uop",
+"svc",//supervisor call
+"unknown",
+"uopReg_uop",
+"uopSet_uop",
+"vldmstm",
+"vldmult",
+"vldsingle",
+"vstmult",
+"vstsingle",
+"wfe",//wait for event
+"wfi",//wait for interrupt 
+"yield",//yield
+"srs",//store return state
+};
+
+std::vector<std::string> logicList{
+"bfc",//bitfield clear
+"bfi",//bit field insert
+"bic",//Bitwise Bit Clear
+"bics",//Bitwise Bit Clear with flag update
+"cbnz",//conditionally branch on non zero
+"cbz",//Compare and Branch on Zero
+"clrex",//Clear-Exclusive
+"clz",//clear leading zeroes
+"cmn",//Compare Negative
+"cmns",//Compare Negative with flag update
+"cmp",//Compare 
+"cmps",//Compare with flag update
+"eor",//Bitwise Exclusive OR
+"eors",//Bitwise Exclusive OR with flag update
+"mvn",//Bitwise NOT
+"mvns",//Bitwise NOT with flag update
+"orn",//Bitwise OR NOT
+"orns",//Bitwise OR NOT with flag update
+"orr",//Bitwise OR
+"orrs",//Bitwise OR with flag update
+"sbfx",//Signed Bit Field Extract
+"sel",//Select Bytes using GE flags
+"ubfx",//Unsigned Bit Field Extract
+"rbit",//reverse bit
+"teq",//Test Equivalence
+"teqs",//Test Equivalence with flag update
+"tst",//Test
+"tsts",//Test with flag update
+};
+
+std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
+    std::stringstream ss(s);
+    std::string item;
+    while (std::getline(ss, item, delim)) {
+        elems.push_back(item);
+    }
+    return elems;
+}
+
+std::vector<std::string> split(const std::string &s, char delim) {
+    std::vector<std::string> elems;
+    split(s, delim, elems);
+    return elems;
+}
+
+void errorMap(string estr,bool* faults, int* emap,int nelems, int elemsize)
+{
+    std::vector<string> elems=split(estr,';');
+    for(int i=0;i<elems.size();i++){
+        vector<string> e2 =split(elems[i],':');
+        int x,y;
+        x=atoi(e2.at(0).c_str());
+        y=atoi(e2.at(1).c_str());
+//        std::cout<<x<<y<<std::endl;
+        if(x<nelems){
+            if(y<elemsize){
+                emap[x]|=1<<y;
+                faults[x]=true;
+                std::cout<<x<<" "<<y<<std::endl;
+            } 
+        }
+    }
+}
+
+void errorMap(string estr,bool* faults,short int* emap,int nelems, int elemsize){
+    std::vector<string> elems=split(estr,';');
+    for(int i=0;i<elems.size();i++){
+        vector<string> e2 =split(elems[i],':');
+        int x,y;
+        x=atoi(e2.at(0).c_str());
+        y=atoi(e2.at(1).c_str());
+        if(x<nelems){
+            if(y<elemsize){
+                emap[x]|=1<<y;
+                faults[x]=true;
+            }
+        }
+    }
+}
+
+bool isInList(std::vector<string> mlist,std::string val){
+    if (std::find(mlist.begin(),mlist.end(), val) != mlist.end()){
+        return true;
+    }
+    return false;
+}
+
+aluOpClasses_t getAluClass(std::string opname){
+//    std::cout<<opname<<" ";
+ //   opname=opname.substr(0,3);
+   if(isInList(aluList,opname)){
+//      std::cout<<"alu op"<<endl;
+       return aluOp;
+   }
+   if(isInList(shiftList,opname)){
+ //     std::cout<<"shift op"<<endl;
+       return aluOp;
+
+   }
+   if(isInList(logicList,opname)){
+  //    std::cout<<"logic op"<<endl;
+       return aluOp;
+   }
+
+//    std::cout<<"other op"<<endl;
+   return otherOp;
+}
+
+std::string getModeString(stageModes_t fm){
+    switch(fm){
+        case regularM:
+            return std::string("regular mode");
+        case squashM:
+            return std::string("squashing mode");
+        case haltM:
+            return std::string("halt mode");
+    }
+    return std::string("Unclear mode");
+}
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/convertor.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/o3/convertor.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,25 @@
+#include<cstdio>
+#include<cstdlib>
+#include<iostream>
+#include<algorithm>
+#include<string>
+#include <vector>
+#include<sstream>
+#ifndef _CONVERTOR_HH
+#define _CONVERTOR_HH
+using namespace std;
+typedef enum {fetchHalt, renameHalt, commitHalt, noHalt }cpuHaltStatus_t;    
+typedef enum {regularM,squashM,haltM}    stageModes_t;
+std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems);
+std::vector<std::string> split(const std::string &s, char delim) ;
+void errorMap(string estr,bool* faults, int* emap,int nelems, int elemsize);
+void errorMap(string estr,bool* faults,short int* emap,int nelems, int elemsize);
+
+std::string getModeString(stageModes_t fm);
+
+bool isInList(std::vector<string> mlist,std::string val);
+typedef enum{aluOp,shiftOp,logicOp,otherOp} aluOpClasses_t;
+
+aluOpClasses_t getAluClass(std::string name);
+
+#endif
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/cpu.cc
--- a/src/cpu/o3/cpu.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/cpu.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -58,12 +58,16 @@
 #include "debug/Drain.hh"
 #include "debug/O3CPU.hh"
 #include "debug/Quiesce.hh"
+#include "debug/SimpleCPU.hh"
+#include "debug/Squasher.hh"
 #include "enums/MemoryMode.hh"
 #include "sim/core.hh"
 #include "sim/full_system.hh"
 #include "sim/process.hh"
 #include "sim/stat_control.hh"
 #include "sim/system.hh"
+#include"cpu/simple/atomic.hh"
+
 
 #if THE_ISA == ALPHA_ISA
 #include "arch/alpha/osfpal.hh"
@@ -71,6 +75,7 @@
 #endif
 
 struct BaseCPUParams;
+class AtomicSimpleCPU;
 
 using namespace TheISA;
 using namespace std;
@@ -212,6 +217,7 @@
     : BaseO3CPU(params),
       itb(params->itb),
       dtb(params->dtb),
+        cpuHS(noHalt),
       tickEvent(this),
 #ifndef NDEBUG
       instcount(0),
@@ -220,6 +226,7 @@
       fetch(this, params),
       decode(this, params),
       rename(this, params),
+      detector(this, params),
       iew(this, params),
       commit(this, params),
 
@@ -248,6 +255,11 @@
 
       timeBuffer(params->backComSize, params->forwardComSize),
       fetchQueue(params->backComSize, params->forwardComSize),
+      fdetectorQueue(params->backComSize, params->forwardComSize),
+      dfQueue(params->backComSize, params->forwardComSize),
+      rdetectorQueue(params->backComSize, params->forwardComSize),
+      cdetectorQueue(params->backComSize, params->forwardComSize),
+      dcQueue(params->backComSize, params->forwardComSize),
       decodeQueue(params->backComSize, params->forwardComSize),
       renameQueue(params->backComSize, params->forwardComSize),
       iewQueue(params->backComSize, params->forwardComSize),
@@ -258,8 +270,11 @@
       globalSeqNum(1),
       system(params->system),
       drainManager(NULL),
-      lastRunningCycle(curCycle())
+      lastRunningCycle(curCycle()),
+      rerun(false)
 {
+     ioi=new portInterface(false);
+     ioh->addConnection(_cpuId,ioi );
     if (!params->switched_out) {
         _status = Running;
     } else {
@@ -290,6 +305,7 @@
     rename.setActiveThreads(&activeThreads);
     iew.setActiveThreads(&activeThreads);
     commit.setActiveThreads(&activeThreads);
+    detector.setActiveThreads(&activeThreads);
 
     // Give each of the stages the time buffer they will use.
     fetch.setTimeBuffer(&timeBuffer);
@@ -297,22 +313,35 @@
     rename.setTimeBuffer(&timeBuffer);
     iew.setTimeBuffer(&timeBuffer);
     commit.setTimeBuffer(&timeBuffer);
+    detector.setTimeBuffer(&timeBuffer);
 
     // Also setup each of the stages' queues.
     fetch.setFetchQueue(&fetchQueue);
+    fetch.setDetectorQueue(&fdetectorQueue);
     decode.setFetchQueue(&fetchQueue);
-    commit.setFetchQueue(&fetchQueue);
+//    commit.setFetchQueue(&fetchQueue);
     decode.setDecodeQueue(&decodeQueue);
     rename.setDecodeQueue(&decodeQueue);
     rename.setRenameQueue(&renameQueue);
+    rename.setDetectorQueue(&rdetectorQueue);
+    detector.setRenameQueue(&rdetectorQueue);
+    detector.setCommitQueue(&cdetectorQueue);
+    detector.setFetchQueue(&fdetectorQueue);
+    detector.setSendCommitQueue(&timeBuffer);
+    detector.setSendFetchQueue(&timeBuffer);
+
     iew.setRenameQueue(&renameQueue);
     iew.setIEWQueue(&iewQueue);
     commit.setIEWQueue(&iewQueue);
     commit.setRenameQueue(&renameQueue);
+    commit.setDetectorQueue(&cdetectorQueue);
 
     commit.setIEWStage(&iew);
     rename.setIEWStage(&iew);
     rename.setCommitStage(&commit);
+    detector.setIEWStage(&iew);
+    detector.setCommitStage(&commit);
+    detector.setRenameStage(&rename);
 
     ThreadID active_threads;
     if (FullSystem) {
@@ -358,7 +387,7 @@
 
                                   tid,
                                   false);
-
+        
         renameMap[tid].init(TheISA::NumIntRegs,
                             params->numPhysIntRegs,
                             lreg_idx,                  //Index for Logical. Regs
@@ -373,7 +402,8 @@
                             TheISA::ZeroReg,
 
                             tid,
-                            bindRegs);
+                            bindRegs                     
+                );
 
         activateThreadEvent[tid].init(tid, this);
         deallocateContextEvent[tid].init(tid, this);
@@ -389,6 +419,8 @@
 
     // Setup the ROB for whichever stages need it.
     commit.setROB(&rob);
+    detector.setROB(&rob);
+    
 
     lastActivatedCycle = 0;
 #if 0
@@ -492,6 +524,11 @@
         .desc("Total number of cycles that the CPU has spent unscheduled due "
               "to idling")
         .prereq(idleCycles);
+    idleRerunCycles
+        .name(name() + ".idleReRunCycles")
+        .desc("Total number of cycles that the CPU has spent unscheduled due "
+              "to a rerun being in process")
+        .prereq(idleCycles);
 
     quiesceCycles
         .name(name() + ".quiesceCycles")
@@ -544,6 +581,7 @@
     this->fetch.regStats();
     this->decode.regStats();
     this->rename.regStats();
+    this->detector.regStats();
     this->iew.regStats();
     this->commit.regStats();
     this->rob.regStats();
@@ -588,10 +626,56 @@
     assert(getDrainState() != Drainable::Drained);
 
     ++numCycles;
+    
 
-//    activity = false;
 
+
+    static int counter=0;
+    detector.tick();
+    if(isRerun()){
+        switch(getHaltStatus()){
+            case fetchHalt:
+            case renameHalt:
+            case commitHalt:
+                fetch.tick();
+                decode.tick();
+                rename.tick();
+                iew.tick();
+                commit.tick();
+                timeBuffer.advance();
+
+                fetchQueue.advance();
+                fdetectorQueue.advance();
+                decodeQueue.advance();
+                rdetectorQueue.advance();
+                renameQueue.advance();
+                cdetectorQueue.advance();
+                dfQueue.advance();
+                dcQueue.advance();
+                iewQueue.advance();
+
+                activityRec.advance();
+
+                break;
+            case  noHalt:
+                setRerun(false);
+                break;
+            default:
+                break;
+        }
+        counter++;     
+        schedule(tickEvent, clockEdge(Cycles(1)));
+        DPRINTF(O3CPU, "Scheduling next tick!\n");
+        if (removeInstsThisCycle) {
+            cleanUpRemovedInsts();
+        }
+
+        return;
+    }else{
+        counter=0;
+    }
     //Tick each of the stages
+    
     fetch.tick();
 
     decode.tick();
@@ -609,8 +693,13 @@
     timeBuffer.advance();
 
     fetchQueue.advance();
+    fdetectorQueue.advance();
     decodeQueue.advance();
+    rdetectorQueue.advance();
     renameQueue.advance();
+    cdetectorQueue.advance();
+    dfQueue.advance();
+    dcQueue.advance();
     iewQueue.advance();
 
     activityRec.advance();
@@ -936,6 +1025,17 @@
 */
 }
 
+template <class Impl>
+void
+FullO3CPU<Impl>::SquashBrute(ThreadID tid){
+    DynInstPtr inst = commit.rob->readHeadInst(tid);
+    InstSeqNum squash_seq_num = inst->seqNum-1;
+    decode.squash(tid);
+    rename.squash(squash_seq_num, tid);
+    iew.squash(tid);
+    iew.ldstQueue.squash(squash_seq_num, tid);
+    commit.rob->squash(squash_seq_num, tid);
+}
 
 template <class Impl>
 void
@@ -1236,7 +1336,9 @@
         DPRINTF(Drain, "Commit not drained.\n");
         drained = false;
     }
-
+    if(!detector.isDrained()){
+        DPRINTF(Drain,"Detector not drained.\n");
+    }
     return drained;
 }
 
@@ -1305,8 +1407,15 @@
     assert(!tickEvent.scheduled());
 
     FullO3CPU<Impl> *oldO3CPU = dynamic_cast<FullO3CPU<Impl>*>(oldCPU);
-    if (oldO3CPU)
+
+ //   AtomicSimpleCPU* oldAtomicCPU = dynamic_cast<AtomicSimpleCPU*>(oldCPU);
+//    if (oldAtomicCPU){
+//        fetch.branchPred=oldAtomicCPU->branchPred;
+//    }
+    
+    if (oldO3CPU){
         globalSeqNum = oldO3CPU->globalSeqNum;
+    }
 
     lastRunningCycle = curCycle();
     _status = Idle;
@@ -1408,7 +1517,7 @@
 {
     intRegfileReads++;
     PhysRegIndex phys_reg = commitRenameMap[tid].lookup(reg_idx);
-
+    DPRINTF(O3CPU,"Register renaming for %d is %d\n",reg_idx,phys_reg);
     return regFile.readIntReg(phys_reg);
 }
 
@@ -1548,7 +1657,9 @@
             inst->threadNumber, inst->pcState(), inst->seqNum);
 
     removeInstsThisCycle = true;
-
+    DPRINTF(O3CPU, "Adding to remove list [tid:%i] PC %s "
+            "[sn:%lli], size is %d\n",
+            inst->threadNumber, inst->pcState(), inst->seqNum,removeList.size());
     // Remove the front instruction.
     removeList.push(inst->getInstListIt());
 }
@@ -1625,6 +1736,12 @@
         if (break_loop)
             break;
     }
+    inst_iter = instList.end();
+    inst_iter--;
+    DPRINTF(O3CPU, "Deleted instructions from instruction "
+            "list that are from [tid:%i] and above [sn:%lli] (end=%lli).\n",
+            tid, seq_num, (*inst_iter)->seqNum);
+
 }
 
 template <class Impl>
@@ -1640,7 +1757,12 @@
 
         // Mark it as squashed.
         (*instIt)->setSquashed();
-
+        DPRINTF(O3CPU, "Adding to remove list "
+               "[tid:%i] PC %s "
+            "[sn:%lli], size is %d\n",
+                (*instIt)->threadNumber,(*instIt)->pcState(),
+                (*instIt)->seqNum,removeList.size()
+                );
         // @todo: Formulate a consistent method for deleting
         // instructions from the instruction list
         // Remove the instruction from the list.
@@ -1666,14 +1788,7 @@
 
     removeInstsThisCycle = false;
 }
-/*
-template <class Impl>
-void
-FullO3CPU<Impl>::removeAllInsts()
-{
-    instList.clear();
-}
-*/
+
 template <class Impl>
 void
 FullO3CPU<Impl>::dumpInsts()
@@ -1694,14 +1809,7 @@
         ++num;
     }
 }
-/*
-template <class Impl>
-void
-FullO3CPU<Impl>::wakeDependents(DynInstPtr &inst)
-{
-    iew.wakeDependents(inst);
-}
-*/
+
 template <class Impl>
 void
 FullO3CPU<Impl>::wakeCPU()
@@ -1784,6 +1892,35 @@
         activeThreads.push_back(high_thread);
     }
 }
+    template <class Impl>
+bool FullO3CPU<Impl>::isRerun()
+{
+    return rerun;
+}
+
+    template <class Impl>
+bool FullO3CPU<Impl>::pipelineClean(ThreadID tid)
+{
+        std::string  haltedStages("");
+        if(!this->fetch.isHalted(tid)){
+            haltedStages=haltedStages+" fetch";
+        }
+        if(!this->decode.isHalted(tid)){
+            haltedStages=haltedStages+" decode";
+        }
+        if(!this->rename.isHalted(tid)){
+            haltedStages=haltedStages+" rename";
+        }
+        if(!this->iew.isHalted(tid)){
+            haltedStages=haltedStages+" iew";
+        }  
+      
+//           bool ret= (this->fetch.isHalted(tid)&&this->decode.isHalted(tid)&&this->rename.isHalted(tid)&&this->iew.isHalted(tid)&&this->commit.isHalted(tid));
+          DPRINTF(Squasher,"Requesting for a pipeline clear Request %s \n",haltedStages); 
+    return (this->fetch.isHalted(tid)&&this->decode.isHalted(tid)&&this->rename.isHalted(tid)&&this->iew.isHalted(tid));
+}
+
+
 
 // Forward declaration of FullO3CPU.
 template class FullO3CPU<O3CPUImpl>;
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/cpu.hh
--- a/src/cpu/o3/cpu.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/cpu.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -63,9 +63,11 @@
 #include "cpu/base.hh"
 #include "cpu/simple_thread.hh"
 #include "cpu/timebuf.hh"
-//#include "cpu/o3/thread_context.hh"
 #include "params/DerivO3CPU.hh"
 #include "sim/process.hh"
+#include<debug/Squasher.hh>
+#include <debug/PH.hh>
+#include"cpu/o3/convertor.hh"
 
 template <class>
 class Checker;
@@ -109,6 +111,8 @@
 
     friend class O3ThreadContext<Impl>;
 
+     InstrIOPortsHandler* ph;
+
   public:
     enum Status {
         Running,
@@ -117,7 +121,7 @@
         Blocked,
         SwitchedOut
     };
-
+    
     TheISA::TLB * itb;
     TheISA::TLB * dtb;
 
@@ -125,7 +129,7 @@
     Status _status;
 
   private:
-
+    cpuHaltStatus_t cpuHS;   
     /**
      * IcachePort class for instruction fetch.
      */
@@ -581,6 +585,9 @@
      * thread.  The source of the squash is an external update of
      * state through the TC.
      */
+    
+    void SquashBrute(ThreadID tid);
+    
     void squashFromTC(ThreadID tid);
 
     /** Function to add instruction onto the head of the list of the
@@ -647,6 +654,9 @@
 
     /** The dispatch stage. */
     typename CPUPolicy::Rename rename;
+    
+    
+    typename CPUPolicy::Detector detector;
 
     /** The issue/execute/writeback stages. */
     typename CPUPolicy::IEW iew;
@@ -702,6 +712,8 @@
     typedef typename CPUPolicy::TimeStruct TimeStruct;
 
     typedef typename CPUPolicy::FetchStruct FetchStruct;
+    
+     typedef typename CPUPolicy::DetectorStruct DetectorStruct;
 
     typedef typename CPUPolicy::DecodeStruct DecodeStruct;
 
@@ -709,11 +721,25 @@
 
     typedef typename CPUPolicy::IEWStruct IEWStruct;
 
+
     /** The main time buffer to do backwards communication. */
+    
     TimeBuffer<TimeStruct> timeBuffer;
 
     /** The fetch stage's instruction queue. */
     TimeBuffer<FetchStruct> fetchQueue;
+    
+    TimeBuffer<DetectorStruct> fdetectorQueue;
+    
+    TimeBuffer<DetectorStruct> dfQueue;
+    
+    TimeBuffer<DetectorStruct> rdetectorQueue;
+    
+    
+    TimeBuffer<DetectorStruct> cdetectorQueue;
+
+
+    TimeBuffer<DetectorStruct> dcQueue;
 
     /** The decode stage's instruction queue. */
     TimeBuffer<DecodeStruct> decodeQueue;
@@ -821,6 +847,7 @@
     Stats::Scalar timesIdled;
     /** Stat for total number of cycles the CPU spends descheduled. */
     Stats::Scalar idleCycles;
+    Stats::Scalar idleRerunCycles;
     /** Stat for total number of cycles the CPU spends descheduled due to a
      * quiesce operation or waiting for an interrupt. */
     Stats::Scalar quiesceCycles;
@@ -838,7 +865,6 @@
     Stats::Formula ipc;
     /** Stat for the total IPC. */
     Stats::Formula totalIpc;
-
     //number of integer register file accesses
     Stats::Scalar intRegfileReads;
     Stats::Scalar intRegfileWrites;
@@ -848,6 +874,36 @@
     //number of misc
     Stats::Scalar miscRegfileReads;
     Stats::Scalar miscRegfileWrites;
+    bool rerun;
+  protected:
+    portInterface* ioi;
+
+   // boolean to specify if the detector has called a squash whole machine wide
+
+    
+
+
+public:
+    bool pipelineClean(ThreadID tid);
+    
+    cpuHaltStatus_t getHaltStatus(){
+        return cpuHS;
+    }
+
+    void setHaltStatus( cpuHaltStatus_t cpuHSIn){
+        cpuHS=cpuHSIn;
+    }
+
+
+    bool isRerun();
+
+    void setRerun(bool val){
+        rerun=val;
+    }
+    
+    portInterface* getPortInterface(){
+        return ioi;
+    }
 };
 
 #endif // __CPU_O3_CPU_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/cpu_policy.hh
--- a/src/cpu/o3/cpu_policy.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/cpu_policy.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -46,6 +46,7 @@
 #include "cpu/o3/rename_map.hh"
 #include "cpu/o3/rob.hh"
 #include "cpu/o3/store_set.hh"
+#include "cpu/o3/detector.hh"
 
 /**
  * Struct that defines the key classes to be used by the CPU.  All
@@ -89,9 +90,14 @@
     /** Typedef for commit. */
     typedef DefaultCommit<Impl> Commit;
 
+    typedef DefaultDetector<Impl> Detector;
+
     /** The struct for communication between fetch and decode. */
     typedef DefaultFetchDefaultDecode<Impl> FetchStruct;
 
+    
+    typedef DetectorsStruct<Impl> DetectorStruct;
+     
     /** The struct for communication between decode and rename. */
     typedef DefaultDecodeDefaultRename<Impl> DecodeStruct;
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/decode.hh
--- a/src/cpu/o3/decode.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/decode.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -87,9 +87,29 @@
         StartSquash,
         Squashing,
         Blocked,
-        Unblocking
+        Unblocking,
+        waitInstruction,
     };
+    std::string getStatusString(ThreadStatus st){
+        switch(st){
+            case Running:
+                return std::string("Running");
+            case Idle:
+                return std::string("Idle");
+            case StartSquash:
+                return std::string("Start Squash");
+            case Squashing:
+                return std::string("Squashing");
+            case Blocked:
+                return std::string("Blocked");
+            case Unblocking:
+                return std::string("Unblocking");
+            case waitInstruction:
+                return std::string("waitInstruction");
 
+        }
+        return std::string("");
+    }
   private:
     /** Decode status. */
     DecodeStatus _status;
@@ -98,6 +118,11 @@
     ThreadStatus decodeStatus[Impl::MaxThreads];
 
   public:
+      bool isHalted(ThreadID tid){
+          return (decodeStatus[tid]==Idle)||(decodeStatus[tid]==Blocked);
+      }
+    bool * faulty;
+    int *emap;
     /** DefaultDecode constructor. */
     DefaultDecode(O3CPU *_cpu, DerivO3CPUParams *params);
 
@@ -130,12 +155,14 @@
 
     /** Takes over from another CPU's thread. */
     void takeOverFrom() { resetStage(); }
+    
+    bool checkHalt();
 
     /** Ticks decode, processing all input signals and decoding as many
      * instructions as possible.
      */
     void tick();
-
+    void killBuffer();
     /** Determines what to do based on decode's current status.
      * @param status_change decode() sets this variable if there was a status
      * change (ie switching from from blocking to unblocking).
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/decode_impl.hh
--- a/src/cpu/o3/decode_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/decode_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -50,6 +50,7 @@
 #include "debug/O3PipeView.hh"
 #include "params/DerivO3CPU.hh"
 #include "sim/full_system.hh"
+#include "convertor.hh"
 
 // clang complains about std::set being overloaded with Packet::set if
 // we open up the entire namespace std
@@ -65,8 +66,18 @@
       decodeWidth(params->decodeWidth),
       numThreads(params->numThreads)
 {
-    // @todo: Make into a parameter
+    faulty=new bool[decodeWidth];
+
+    emap= new int[decodeWidth];
+
+   for(int i=0;i<decodeWidth;i++) {
+       faulty[i]=false;
+       emap[i]=0;
+   }
+
+   // @todo: Make into a parameter
     skidBufferMax = (fetchToDecodeDelay + 1) *  params->fetchWidth;
+
 }
 
 template<class Impl>
@@ -182,7 +193,7 @@
 }
 
 template<class Impl>
-void
+    void
 DefaultDecode<Impl>::setActiveThreads(std::list<ThreadID> *at_ptr)
 {
     activeThreads = at_ptr;
@@ -205,13 +216,13 @@
     bool ret_val = false;
 
     if (stalls[tid].rename) {
-        DPRINTF(Decode,"[tid:%i]: Stall fom Rename stage detected.\n", tid);
+        DPRINTF(Decode,"[tid:%i]: Stall from Rename stage detected.\n", tid);
         ret_val = true;
     } else if (stalls[tid].iew) {
-        DPRINTF(Decode,"[tid:%i]: Stall fom IEW stage detected.\n", tid);
+        DPRINTF(Decode,"[tid:%i]: Stall from IEW stage detected.\n", tid);
         ret_val = true;
     } else if (stalls[tid].commit) {
-        DPRINTF(Decode,"[tid:%i]: Stall fom Commit stage detected.\n", tid);
+        DPRINTF(Decode,"[tid:%i]: Stall from Commit stage detected.\n", tid);
         ret_val = true;
     }
 
@@ -458,6 +469,7 @@
 DefaultDecode<Impl>::sortInsts()
 {
     int insts_from_fetch = fromFetch->size;
+    DPRINTF(Decode,"Instructions recieved from Fetch are %d\n",insts_from_fetch);
     for (int i = 0; i < insts_from_fetch; ++i) {
         insts[fromFetch->insts[i]->threadNumber].push(fromFetch->insts[i]);
     }
@@ -561,6 +573,28 @@
     // cause decode to change its status.  Decode remains the same as before.
     return false;
 }
+template<class Impl>
+bool
+DefaultDecode<Impl>::checkHalt(){
+    bool retV=false;
+    switch (cpu->getHaltStatus()){
+        case(fetchHalt):
+            retV=false;
+            break;
+        case(renameHalt):
+            retV=false;
+            break;
+        case(commitHalt):
+            retV=true;
+            break;
+       case (noHalt):
+            retV=false;
+            break;
+        default:break;
+    }
+    return retV;
+}
+
 
 template<class Impl>
 void
@@ -596,6 +630,14 @@
 
         cpu->activityThisCycle();
     }
+    
+    DPRINTF(Decode,"Decode is sending %d instructions to Rename\n",toRenameIndex);
+}
+
+template <class Impl>
+void DefaultDecode<Impl>::killBuffer()
+{
+//    toDecode->size=0;
 }
 
 template<class Impl>
@@ -643,6 +685,7 @@
     }
 }
 
+
 template <class Impl>
 void
 DefaultDecode<Impl>::decodeInsts(ThreadID tid)
@@ -655,6 +698,7 @@
     if (insts_available == 0) {
         DPRINTF(Decode, "[tid:%u] Nothing to do, breaking out"
                 " early.\n",tid);
+        decodeStatus[tid]=Idle;
         // Should I change the status to idle?
         ++decodeIdleCycles;
         return;
@@ -667,7 +711,7 @@
     }
 
     DynInstPtr inst;
-
+    DPRINTF(Decode,"Decode Status is %s \n",getStatusString(decodeStatus[tid]));
     std::queue<DynInstPtr>
         &insts_to_decode = decodeStatus[tid] == Unblocking ?
         skidBuffer[tid] : insts[tid];
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/detector.cc
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/o3/detector.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,6 @@
+#include "cpu/o3/isa_specific.hh"
+#include "cpu/o3/detector_impl.hh"
+
+
+
+template class DefaultDetector<O3CPUImpl>;
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/detector.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/o3/detector.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,380 @@
+#include <list>
+
+#include "arch/isa_traits.hh"
+#include "arch/registers.hh"
+#include "config/the_isa.hh"
+#include "debug/O3PipeView.hh"
+#include "debug/Fetch.hh"
+#include "params/DerivO3CPU.hh"
+#include "base/statistics.hh"
+#include "config/the_isa.hh"
+#include "cpu/timebuf.hh"
+#include "cpu/PortManager.hh"
+
+
+using namespace std;
+
+struct DerivO3CPUParams;
+#ifndef _DETECTOR_HH
+#define _DETECTOR_HH
+
+template<class Impl>
+class DefaultDetector
+{
+  public:
+    // Typedefs from the Impl.
+    typedef typename Impl::CPUPol CPUPol;
+    typedef typename Impl::DynInstPtr DynInstPtr;
+    typedef typename Impl::O3CPU O3CPU;
+
+    // Typedefs from the CPUPol
+    typedef typename CPUPol::DecodeStruct DecodeStruct;
+     typedef typename CPUPol::DetectorStruct DetectorStruct;
+    typedef typename CPUPol::RenameStruct RenameStruct;
+    typedef typename CPUPol::TimeStruct TimeStruct;
+    typedef typename CPUPol::FreeList FreeList;
+    typedef typename CPUPol::RenameMap RenameMap;
+    // These are used only for initialization.
+    typedef typename CPUPol::IEW IEW;
+    typedef typename CPUPol::Commit Commit;
+    typedef typename CPUPol::Rename Rename;
+    typedef typename CPUPol::ROB ROB;
+
+    // Typedefs from the ISA.
+    typedef TheISA::RegIndex RegIndex;
+
+    // A list is used to queue the instructions.  Barrier insts must
+    // be added to the front of the list, which is the only reason for
+    // using a list instead of a queue. (Most other stages use a
+    // queue)
+    typedef std::list<DynInstPtr> InstQueue;
+    typedef typename std::list<DynInstPtr>::iterator ListIt;
+
+    enum FetchStatus {
+        fetchBroke,
+        fetchMacro,
+        decoder
+    };
+    
+    enum ThreadState{
+        waitRepair,
+        waitPipeline,
+        noWork        
+    };
+    ThreadState tState[Impl::MaxThreads];
+
+    FetchStatus detectorStatus;
+    ThreadID numThreads;
+
+  public:
+    /** DefaultDetector constructor. */
+    DefaultDetector(O3CPU *_cpu, DerivO3CPUParams *params);
+
+    /** Returns the name of rename. */
+    std::string name() const;
+
+    /** Registers statistics. */
+    void regStats();
+
+    /** Sets the main backwards communication time buffer pointer. */
+    void setTimeBuffer(TimeBuffer<TimeStruct> *tb_ptr);
+
+    /** Sets pointer to time buffer used to communicate to the next stage. */
+    void setFetchQueue(TimeBuffer<DetectorStruct> *fq_ptr);
+    
+    void setRenameQueue(TimeBuffer<DetectorStruct> *rq_ptr);
+    
+    void setCommitQueue(TimeBuffer<DetectorStruct> *rq_ptr);
+    
+    void setSendFetchQueue(TimeBuffer<TimeStruct> *fq_ptr);
+    
+    void setSendCommitQueue(TimeBuffer<TimeStruct> *rq_ptr);
+   
+    void setRenameStage(Rename * ren_stage)
+    {
+        rename_ptr=ren_stage;
+    }
+
+    /** Sets pointer to IEW stage. Used only for initialization. */
+    void setIEWStage(IEW *iew_stage)
+    { iew_ptr = iew_stage; }
+
+    /** Sets pointer to commit stage. Used only for initialization. */
+    void setCommitStage(Commit *commit_stage)
+    { commit_ptr = commit_stage; }
+
+  private:
+    /** Pointer to IEW stage. Used only for initialization. */
+    IEW *iew_ptr;
+
+    /** Pointer to commit stage. Used only for initialization. */
+    Commit *commit_ptr;
+
+    Rename *rename_ptr;
+
+    ROB *rob;
+  public:
+    /** Initializes variables for the stage. */
+    void startupStage();
+
+    /** Sets pointer to list of active threads. */
+    void setActiveThreads(std::list<ThreadID> *at_ptr);
+
+    /** Squashes all instructions in a thread. */
+    void squash(const InstSeqNum &squash_seq_num, ThreadID tid);
+
+    /** Ticks rename, which processes all input signals and attempts to rename
+     * as many instructions as possible.
+     */
+    void tick();
+    
+    void tick2();
+    
+    void setROB(ROB *rob_ptr);
+    
+    bool  isDrained()const;
+
+  private:
+    /** Reset this pipeline stage */
+    void resetStage();
+    /** Separates instructions from decode into individual lists of instructions
+     * sorted by thread.
+     */
+    void sortInsts();
+
+
+    /** Updates overall rename status based on all of the threads' statuses. */
+    void updateStatus();
+
+
+    /** Returns the number of valid instructions coming from decode. */
+    unsigned validInsts();
+
+
+    /** Checks the signals and updates the status. */
+    bool checkSignalsAndUpdate(ThreadID tid);
+
+    /** Pointer to CPU. */
+    O3CPU *cpu;
+
+    /** Pointer to main time buffer used for backwards communication. */
+    TimeBuffer<TimeStruct> *timeBuffer;
+
+    /** Wire to get IEW's output from backwards time buffer. */
+
+    /** Wire to get commit's output from backwards time buffer. */
+
+    /** Wire to write infromation heading to previous stages. */
+
+    /** Rename instruction queue. */
+    TimeBuffer<DetectorStruct> *renameQueue;
+    TimeBuffer<DetectorStruct> *fetchQueue;
+    TimeBuffer<DetectorStruct> *commitQueue;
+    TimeBuffer<TimeStruct> *fetchSendQueue;
+    TimeBuffer<TimeStruct> *commitSendQueue;
+
+    typename TimeBuffer<DetectorStruct>::wire fromFetch;
+    typename TimeBuffer<DetectorStruct>::wire fromCommit;;
+
+    typename TimeBuffer<TimeStruct>::wire toFetch;
+    typename TimeBuffer<TimeStruct>::wire toCommit;;
+
+    /** Wire to get decode's output from decode queue. */
+    typename TimeBuffer<DetectorStruct>::wire fromRename;
+
+    /** Pointer to the list of active threads. */
+    std::list<ThreadID> *activeThreads;
+
+    /** Pointer to the scoreboard. */
+    Scoreboard *scoreboard;
+
+    /** Records if the ROB is empty. In SMT mode the ROB may be dynamically
+     * partitioned between threads, so the ROB must tell rename when it is
+     * empty.
+     */
+    bool emptyROB[Impl::MaxThreads];
+
+    /** Source of possible stalls. */
+
+    struct Stalls {
+        bool fetch;
+        bool rename;
+        bool commit;
+    };
+
+    /** Tracks which stages are telling decode to stall. */
+    Stalls stalls;
+
+    bool activeSquash;
+    
+    int lrqc;
+
+    bool checkStalls();
+    
+    void clearStalls();
+    
+    bool sampleQueue(typename TimeBuffer<DetectorStruct>::wire que,ThreadID tid){
+        if(que->instrSize>0||que->pcSize>0||que->statSize>0){
+            int maxid=que->instrSize+que->pcSize+que->statSize;
+            for(int i=0;i<maxid;i++){
+                if(que->tids[i]==tid){
+                    return true;                                        
+                }
+            }
+        }
+        return false;
+    }
+    
+    bool sampleQueue(typename TimeBuffer<DetectorStruct>::wire que){
+        return (que->instrSize>0||que->pcSize>0||que->statSize>0);
+    }
+    
+    bool commitFaultHandler(){
+        if(sampleQueue(fromCommit)){
+            return placeInstHelper(fromCommit->insts[0],fromCommit->tids[0]);
+        }
+        return false;
+    }
+
+    bool commitFaultPush(){
+        if(sampleQueue(fromCommit)){
+            storageWrap t;
+            t.setDinst(fromCommit->insts[0],fromCommit->tids[0]);
+            storageList.push_back(t);
+            return true;
+        }
+        return false;
+    }
+    
+    bool renameFaultHandler(){
+        if(sampleQueue(fromRename)){
+            return placeInstHelper(fromRename->insts[0],fromRename->tids[0]);
+        }
+        return false;
+    }
+    
+    bool renameFaultPush(){
+        if(sampleQueue(fromRename)){
+            storageWrap t;
+            t.setDinst(fromRename->insts[0],fromRename->tids[0]);
+            storageList.push_back(t);
+            return true;
+        }
+        return false;
+    }
+    
+    bool fetchFaultHandler();
+
+    bool fetchFaultPush(){
+        if(sampleQueue(fromRename)){
+            storageWrap t;
+            t.setDinst(fromRename->insts[0],fromRename->tids[0]);
+            storageList.push_back(t);
+            return true;
+        }
+        return false;
+    }
+    
+ /*   {
+        if(sampleQueue(fromFetch)){
+                      
+            if(fromFetch->instrSize>0){
+            return placeInstHelper(fromFetch->insts[0],fromFetch->tids[0]);
+            }
+            else if (fromFetch->statSize>0){
+                return placeInstHelper(fromFetch->statInsts[0],fromFetch->tids[0]);
+            } else if(fromFetch->pcSize>0){
+                DPRINTF(Fetch,"In Detector, PC is , PC is thumb? %s\n",fromFetch->pcState[0].thumb()?"True":"False");
+
+                return placeInstHelper(fromFetch->pcState[0],fromFetch->tids[0]);
+            }
+        }
+        return false;
+    }
+*/
+    class storageWrap{
+        DynInstPtr dinst;
+        TheISA::PCState pcs;
+        StaticInstPtr sinst;
+        ThreadID tid;
+        int seqNum;
+    public:
+        storageWrap(){
+            dinst=NULL;
+            pcs=0;
+            sinst=NULL;
+            tid=-1;
+        }
+        void setDinst(DynInstPtr& dinst,ThreadID tid){
+            this->dinst=dinst;
+            seqNum=dinst->seqNum;
+            this->tid=tid;
+        }
+        void setPC(TheISA::PCState pcs,ThreadID tid){
+            this->pcs=pcs;
+            this->tid=tid;
+            this->seqNum=-1;
+        }
+        void setSinst(StaticInstPtr& sinst,ThreadID tid){
+            this->sinst=sinst;            
+            this->tid=tid;
+        }
+        ThreadID gettid(){
+            return tid;
+        }
+        int getSeq(){
+            return seqNum;
+        }
+        DynInstPtr& getdinptr(){
+            return dinst;
+        }
+        TheISA::PCState getpcs(){
+            return pcs;
+        }
+        StaticInstPtr& getsinptr(){
+            return sinst;
+        }
+        void setSeq(int seqNum){
+            this->seqNum=seqNum;
+        }
+        static bool compare_seqNum(storageWrap & first, storageWrap & second){
+                if(first.getSeq()<second.getSeq())
+                        return true;
+                return false;
+        }
+    };
+    
+    
+    void sortList(){
+        storageList.sort(storageWrap::compare_seqNum);
+    }
+    
+    std::list<storageWrap> storageList;
+     
+    bool placeInstHelper(DynInstPtr& dynInst, ThreadID tid) ;
+    
+    bool placeInstHelper(TheISA::PCState pct, ThreadID tid) ;
+    
+    bool placeInstHelper(StaticInstPtr& dynInst, ThreadID tid) ;
+    
+    bool placeInstHelper(storageWrap sw) ;
+
+    bool queryHelper() ;
+    
+    void sendRegisterData();
+    
+    bool locallyAvailable(RegIndex index, CommPack* pkt,dataChar dc, int & indd);
+
+    CommPack* readDataHelper();
+
+    void clearDataHelper();
+
+    void getDataHelper() ;
+    
+    
+    
+    Stats::Distribution runStats;
+
+};
+
+#endif
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/detector_impl.hh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/o3/detector_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -0,0 +1,668 @@
+#include <list>
+
+#include "arch/isa_traits.hh"
+#include "arch/registers.hh"
+#include "config/the_isa.hh"
+#include "cpu/o3/detector.hh"
+#include "cpu/o3/convertor.hh"
+#include "debug/Activity.hh"
+#include "debug/Squasher.hh"
+#include "debug/SimpleCPU.hh"
+#include "debug/O3PipeView.hh"
+#include "params/DerivO3CPU.hh"
+
+
+using namespace std;
+
+template<class Impl>
+DefaultDetector<Impl>::DefaultDetector(O3CPU * _cpu, DerivO3CPUParams *params)
+: cpu(_cpu) {
+    activeSquash = false;
+    stalls.commit = false;
+    stalls.fetch = false;
+    stalls.rename = false;
+    this->numThreads=cpu->numThreads;
+    for(int i=0;i<numThreads;i++){
+         tState[i]=noWork;
+    }
+}
+
+
+
+template<class Impl>
+std::string
+DefaultDetector<Impl>::name() const {
+    return cpu->name() + ".detector";
+}
+
+template<class Impl>
+void
+DefaultDetector<Impl>::regStats() {
+    runStats
+        .init(0,50,1)
+        .name(name() + ".time_per_rerun")
+        .desc("Time per rerun")
+        .flags(Stats::pdf)
+        ;
+}
+
+template<class Impl>
+void
+DefaultDetector<Impl>::setTimeBuffer(TimeBuffer<TimeStruct> *tb_ptr) {
+    timeBuffer = tb_ptr;
+
+    // Setup wire to read information from time buffer, from IEW stage.
+
+    // Setup wire to read infromation from time buffer, from commit stage.
+
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setRenameQueue(TimeBuffer<DetectorStruct> *rq_ptr) {
+    renameQueue = rq_ptr;
+
+    // Setup wire to write information to future stages.
+    //    toIEW = renameQueue->getWire(0);
+    fromRename = renameQueue->getWire(0);
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setFetchQueue(TimeBuffer<DetectorStruct> *rq_ptr) {
+    fetchQueue = rq_ptr;
+
+    // Setup wire to write information to future stages.
+    //    toIEW = renameQueue->getWire(0);
+    fromFetch = fetchQueue->getWire(0);
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setCommitQueue(TimeBuffer<DetectorStruct> *rq_ptr) {
+    commitQueue = rq_ptr;
+
+    // Setup wire to write information to future stages.
+    //    toIEW = renameQueue->getWire(0);
+    fromCommit = commitQueue->getWire(0);
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setSendFetchQueue(TimeBuffer<TimeStruct> *rq_ptr) {
+    fetchSendQueue = rq_ptr;
+
+    // Setup wire to write information to future stages.
+    //    toIEW = renameQueue->getWire(0);
+    toFetch = fetchSendQueue->getWire(0);
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setSendCommitQueue(TimeBuffer<TimeStruct> *rq_ptr) {
+    commitSendQueue = rq_ptr;
+
+    // Setup wire to write information to future stages.
+    //    toIEW = renameQueue->getWire(0);
+    toCommit = commitSendQueue->getWire(1);
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::startupStage() {
+
+}
+
+template<class Impl>
+void
+DefaultDetector<Impl>::setActiveThreads(list<ThreadID> *at_ptr) {
+    activeThreads = at_ptr;
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::clearStalls() {
+    stalls.commit = false;
+    stalls.fetch = false;
+    stalls.rename = false;
+    activeSquash=false;
+}
+
+template <class Impl>
+bool
+DefaultDetector<Impl>::checkStalls() {
+    return stalls.commit | stalls.fetch | stalls.rename;
+}
+
+template <class Impl>
+void
+DefaultDetector<Impl>::tick() {
+    tick2();
+    return;
+    static int counter = 0;
+    static int stalledCycles=0;
+    toFetch->detectorInfo.working = false;
+    toFetch->detectorInfo.isReady=false;
+    if (checkStalls()) {
+        stalledCycles++;
+        toFetch->detectorInfo.working = true;
+        cpu->activityThisCycle();
+        if (queryHelper()) {
+            runStats.sample(stalledCycles);
+            stalledCycles=0;
+            if (readDataHelper()->getPhase() == dataRequest) {
+                DPRINTF(SimpleCPU,"Request for data received\n");
+                if (cpu->pipelineClean(readDataHelper()->getTID())){
+                    DPRINTF(Squasher,"Pipeline is clear\n");
+                    sendRegisterData();
+                }
+                return;
+            }
+            counter--;
+            DPRINTF(Squasher,"Returned from repair, with counter as %d \n", counter);            
+            if (stalls.commit) {
+                clearDataHelper();
+                //                getDataHelper();
+                cpu->setHaltStatus(noHalt);
+                clearStalls();
+            } else if (stalls.fetch) {
+                CommPack* packet=readDataHelper();
+                switch(detectorStatus){
+                    case fetchBroke:
+                        toFetch->detectorInfo.isReady=true;
+                        toFetch->detectorInfo.instr[0]=packet->getInstPtr();
+
+                        DPRINTF(Squasher,"Adding Instruction to fetch \n", counter);            
+                        break;
+                    case fetchMacro:
+                        break;
+                    case decoder:
+                        break;
+                }
+
+                clearDataHelper();
+                cpu->setHaltStatus(noHalt);
+                clearStalls();
+            } else if (stalls.rename) {
+                clearDataHelper();
+                cpu->setHaltStatus(noHalt);
+                clearStalls();
+            }
+            toFetch->detectorInfo.working = false;
+           DPRINTF(Squasher, "Re execution completed\n" );
+        }
+        return;
+    }
+
+    if (sampleQueue(fromCommit)) {
+        toFetch->detectorInfo.working = true;
+        cout<<"Incoming from Commit"<<endl;
+        counter++;
+        DPRINTF(Squasher, "Commit Faulted with counter as %d \n", counter);
+        if (commitFaultHandler()) {
+            cpu->setHaltStatus(commitHalt);
+            stalls.commit = true;
+        }
+    } else if (sampleQueue(fromRename)) {
+        toFetch->detectorInfo.working = true;
+        counter++;
+        if (renameFaultHandler()) {
+            cpu->setHaltStatus(renameHalt);
+            stalls.rename = true;
+            DPRINTF(Squasher, "Rename Faulted with counter as %d\n", counter);
+        }
+    } else if (sampleQueue(fromFetch)) {
+        toFetch->detectorInfo.working = true;
+        counter++;
+        DPRINTF(Squasher, "Fetch Faulted with counter as %d \n",counter);
+        if (fetchFaultHandler()) {            
+            cpu->setHaltStatus(fetchHalt);
+            stalls.fetch = true;
+        }
+    }
+    return;    
+}
+
+
+
+
+template <class Impl>
+void
+DefaultDetector<Impl>::tick2(){
+    toFetch->detectorInfo.working = false;
+    toFetch->detectorInfo.isReady=false;
+    static int stalledCycles=0;
+    for(ThreadID i=0;i<numThreads;i++) {
+        static int counter = 0;
+        if (tState[i]==noWork || tState[i]==waitPipeline) {
+            if (sampleQueue(fromCommit,i)) {
+                tState[i]=waitPipeline;
+                //                cout<<"Waiting for pipeline to clear"<<endl;
+                toFetch->detectorInfo.working = true;
+                counter++;
+                DPRINTF(Squasher, "Commit Faulted with counter as %d \n", counter);
+                if (commitFaultPush()) {
+                    cpu->setHaltStatus(commitHalt);
+                    stalls.commit = true;
+                }
+            } else if (sampleQueue(fromRename,i)) {
+                tState[i]=waitPipeline;
+                //                 cout<<"Waiting for pipeline to clear"<<endl;
+                toFetch->detectorInfo.working = true;
+                counter++;
+                if (renameFaultPush()) {
+                    cpu->setHaltStatus(renameHalt);
+                    stalls.rename = true;
+                    DPRINTF(Squasher, "Rename Faulted with counter as %d\n", counter);
+                }
+            } else if (sampleQueue(fromFetch,i)) {
+                tState[i]=waitPipeline;
+                //                 cout<<"Waiting for pipeline to clear"<<endl;
+                toFetch->detectorInfo.working = true;
+                counter++;
+                DPRINTF(Squasher, "Fetch Faulted with counter as %d \n", counter);
+                if (fetchFaultPush()) {
+                    cpu->setHaltStatus(fetchHalt);
+                    stalls.fetch = true;
+                }
+            }
+        }
+
+        if (tState[i]!=noWork) {
+            cpu->activityThisCycle();
+            //            DPRINTF(Squasher,"Detector is working\n");
+            toFetch->detectorInfo.working = true;
+            //             cout<<"Waiting post error"<<endl;
+            if (tState[i]==waitRepair) {
+        		stalledCycles++;
+                if (checkStalls()) {
+                    toFetch->detectorInfo.working = true;
+                    cpu->activityThisCycle();
+                    if (queryHelper()) {
+                        if (readDataHelper()->getPhase() == dataRequest) {
+                            DPRINTF(SimpleCPU, "Request for data received\n");
+                            if (cpu->pipelineClean(readDataHelper()->getTID())){
+                                DPRINTF(SimpleCPU,"Pipeline clean\n");
+                                sendRegisterData();                            
+                                if(cpu->getHaltStatus()==noHalt){
+                                    tState[i]=noWork;
+                                    clearStalls();
+                                    toFetch->detectorInfo.working = false;
+                                }
+                            }
+                            return;
+                        }
+                	runStats.sample(stalledCycles);
+            			stalledCycles=0;
+                        counter--;
+                        DPRINTF(Squasher, "Returned from repair, with counter as %d \n", counter);
+                        if (stalls.commit) {
+                            clearDataHelper();
+                            cpu->setHaltStatus(noHalt);
+                            clearStalls();
+                        } else if (stalls.fetch) {
+                            CommPack* packet = readDataHelper();
+                            switch (detectorStatus) {
+                                case fetchBroke:
+                                    toFetch->detectorInfo.isReady = true;
+                                    toFetch->detectorInfo.instr[0] = packet->getInstPtr();
+                                    DPRINTF(Squasher, "Adding Instruction to fetch \n", counter);
+                                    break;
+                                case fetchMacro:
+                                    break;
+                                case decoder:
+                                    break;
+                            }
+
+                            clearDataHelper();
+                            cpu->setHaltStatus(noHalt);
+                            clearStalls();
+                        } else if (stalls.rename) {
+                            clearDataHelper();
+                            cpu->setHaltStatus(noHalt);
+                            clearStalls();
+                        }
+                        tState[i]=noWork;
+                        toFetch->detectorInfo.working = false;
+                        DPRINTF(Squasher, "Re execution completed\n");
+                    }
+
+                    return;
+                }
+
+            } else {
+                DPRINTF(Squasher,"Current Pipeline state is %s\n",cpu->pipelineClean(i)?"Clean":"working");
+                if (cpu->pipelineClean(i) || cpu->getHaltStatus() == noHalt) {
+                    if (cpu->getHaltStatus() == noHalt) {
+                        DPRINTF(Squasher, "Resetting due to CPU being in no Halt status\n");
+                        tState[i] = noWork;
+                        stalledCycles=0;
+                        toFetch->detectorInfo.working = false;
+
+                        while (storageList.size() > 0) {
+                            counter--;
+                            storageList.pop_front();
+                        }
+                    } else {
+                        DPRINTF(Squasher, "Pipeline clean\n");
+                        //Send to repair and wait
+                        // Find lowest valued seqnumber and send it to the repair cpu.
+                        tState[i] = waitRepair;
+                        sortList();
+                        storageWrap elem = storageList.front();
+                        storageList.pop_front();
+                        while (elem.getSeq() < 0 && storageList.size() > 0) {
+                            elem = storageList.front();
+                            storageList.pop_front();
+                            counter--;
+                        }
+                        placeInstHelper(elem);
+                        while (storageList.size() > 0) {
+                            counter--;
+                            storageList.pop_front();
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+    
+
+
+
+template <class Impl>
+void
+DefaultDetector<Impl>::setROB(ROB *rob_ptr) {
+    rob = rob_ptr;
+}
+
+template<class Impl>
+bool 
+DefaultDetector<Impl>::isDrained()const{
+    bool ret=true;
+    for(ThreadID i=0;i<numThreads;i++) {
+        if (tState[i]!=noWork ){
+            ret=false;
+        }
+    }
+    return ret;
+}
+
+
+template <class Impl>
+void
+DefaultDetector<Impl>::sortInsts() {
+    /*  int insts_from_rename = fromRename->size;
+      for (int i = 0; i < insts_from_rename; ++i) {
+      DynInstPtr inst=fromRename->insts[i];
+          if(inst){
+          }
+      }
+     */
+}
+
+template <class Impl>bool DefaultDetector<Impl>::fetchFaultHandler(){
+        if(sampleQueue(fromFetch)){
+                      
+            if(fromFetch->instrSize>0){detectorStatus=fetchMacro;
+                return placeInstHelper(fromFetch->insts[0],fromFetch->tids[0]);
+            }
+            else if (fromFetch->statSize>0){detectorStatus=decoder;
+                return placeInstHelper(fromFetch->statInsts[0],fromFetch->tids[0]);
+            } else if(fromFetch->pcSize>0){detectorStatus=fetchBroke;
+                return placeInstHelper(fromFetch->pcState[0],fromFetch->tids[0]);
+            }
+        }
+        return false;
+    }
+
+template <class Impl>
+bool DefaultDetector<Impl>::placeInstHelper(TheISA::PCState pc, ThreadID tid) {
+    if (activeSquash) {
+         DPRINTF(Squasher,"Squash active \n");
+        return false;
+    }
+    activeSquash = true;
+    CommPack* packet;
+    packet = new CommPack(cpu->cpuId());
+    packet->setTick(curTick());
+    DPRINTF(Squasher, "The packet being placed is %i\n", packet);
+    packet->setProcess(cpu->thread[tid]->getProcessPtr());
+    packet->setDTLB(cpu->dtb);
+    packet->setITLB(cpu->itb);
+    packet->setPhase(fetchP);
+    packet->setTID(tid);
+
+    packet->setPC(pc);
+    {
+        cpu->setRerun(cpu->getPortInterface()->setData(packet));
+        if (!cpu->isRerun()) {
+            printf("Input buffer unable to allow any more inputs, system will hang now.....\n");
+            exit(1);
+        }
+    }
+    return cpu->isRerun();
+}
+
+template <class Impl>
+bool DefaultDetector<Impl>::placeInstHelper(StaticInstPtr& statInst, ThreadID tid) {
+    if (activeSquash) {
+         DPRINTF(Squasher,"Squash active \n");
+        return false;
+    }
+    activeSquash = true;
+    CommPack* packet;
+    packet = new CommPack(statInst, cpu->cpuId());
+    packet->setTick(curTick());
+    DPRINTF(Squasher, "The packet being placed is %i\n", packet);
+    packet->setProcess(cpu->thread[tid]->getProcessPtr());
+    packet->setDTLB(cpu->dtb);
+    packet->setITLB(cpu->itb);
+    packet->setPhase(fetchP);
+    packet->setTID(tid);
+
+    packet->setPC(cpu->pcState(tid));
+    {
+        cpu->setRerun(cpu->getPortInterface()->setData(packet));
+        if (!cpu->isRerun()) {
+            printf("Input buffer unable to allow any more inputs, system will hang now.....\n");
+            exit(1);
+        }
+    }
+    return cpu->isRerun();
+}
+template <class Impl>
+bool DefaultDetector<Impl>::placeInstHelper(storageWrap elem) {
+    if(elem.getdinptr()!=0){
+        placeInstHelper(elem.getdinptr(),elem.gettid());
+    }else if(elem.getsinptr()!=0){
+        placeInstHelper(elem.getsinptr(),elem.gettid());
+    }else if(elem.getpcs()!=0){
+        placeInstHelper(elem.getpcs(),elem.gettid());
+    }
+    return false;
+}
+
+
+template <class Impl>
+bool DefaultDetector<Impl>::placeInstHelper(DynInstPtr& dynInst, ThreadID tid) {
+    if (activeSquash) {
+         DPRINTF(Squasher,"Squash active \n");
+        return false;
+    }
+    activeSquash = true;
+    CommPack* packet;
+    packet = new CommPack(dynInst.get()->staticInst, cpu->cpuId());
+    packet->setTick(curTick());
+    DPRINTF(Squasher, "The packet being placed is %i\n", packet);
+    packet->setProcess(cpu->thread[tid]->getProcessPtr());
+    packet->setDTLB(cpu->dtb);
+    packet->setITLB(cpu->itb);
+    packet->setPhase(executeP);
+    packet->setTID(tid);
+    DPRINTF(Squasher, "Setting number of registers as %d\n", packet->getNumSrcRegs());
+    for (int i = 0; i < dynInst->numSrcRegs(); i++) {
+        RegIndex src_reg = dynInst->srcRegIdx(i);
+        if (src_reg < TheISA::FP_Base_DepTag) {
+            packet->setSrcType(enInt, i);
+            packet->setSrcData(cpu->readIntReg(dynInst->renamedSrcRegIdx((i))), src_reg);
+        } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+            packet->setSrcType(enFloat, i);
+            packet->setSrcData(cpu->readFloatReg(dynInst->renamedSrcRegIdx(i)), src_reg - TheISA::FP_Base_DepTag);
+        } else if (src_reg < TheISA::Max_DepTag) {
+            packet->setSrcType(enMisc, i);
+            packet->setSrcData(dynInst->readMiscRegOperand(dynInst->staticInst.get(), i), src_reg - TheISA::Ctrl_Base_DepTag);
+        }
+    }
+
+    lrqc = dynInst->numDestRegs();
+    packet->initDest(lrqc);
+    for (int i = 0; i < dynInst->numDestRegs(); i++) {
+        RegIndex dest_Reg = dynInst->destRegIdx(i);
+        {
+            if (dest_Reg < TheISA::FP_Base_DepTag)
+                packet->setDestType(enInt, i);
+            else if (dest_Reg < TheISA::Ctrl_Base_DepTag)
+                packet->setDestType(enFloat, i);
+            else if (dest_Reg < TheISA::Max_DepTag)
+                packet->setDestType(enMisc, i);
+        }
+    }
+    packet->setPC(cpu->pcState(tid));
+    StaticInstPtr curStaticInst=dynInst->staticInst.get();
+    {
+        cpu->setRerun(cpu->getPortInterface()->setData(packet));
+        if (!cpu->isRerun()) {
+            printf("Input buffer unable to allow any more inputs, system will hang now.....\n");
+            exit(1);
+        }
+    }
+    DPRINTF(Squasher, "Placing dynamic instruction on to port handler %i\n", dynInst->seqNum);
+    DPRINTF(Squasher, "Decode: Decoded %s instruction: %#x\n",
+                curStaticInst->getName(), curStaticInst->machInst);
+
+    return cpu->isRerun();
+}
+
+template <class Impl>
+bool DefaultDetector<Impl>::queryHelper() {
+    bool hrecvd;
+    hrecvd = cpu->getPortInterface()->isAvailable();
+    return hrecvd;
+}
+
+template <class Impl>
+CommPack* DefaultDetector<Impl>::readDataHelper() {
+    CommPack* packet = NULL;
+    if (queryHelper()) {
+        packet = cpu->getPortInterface()->readData();
+    }
+    return packet;
+
+}
+template <class Impl>
+bool DefaultDetector<Impl>::locallyAvailable(RegIndex index, CommPack* pkt,dataChar dc,int &indd){
+    indd=-1;
+    for(int i=0;i<pkt->getNumDestRegs();i++){
+        if((pkt->getDestData(i).index==index)&&(dc==pkt->getDestType(i))){
+            indd=i;
+             DPRINTF(Squasher,"Register was locally available\n");
+            return true;
+        }
+    }
+    return false;;
+}
+template <class Impl>
+void DefaultDetector<Impl>::sendRegisterData() {
+    CommPack* packet = cpu->getPortInterface()->getData();
+    if(cpu->getHaltStatus()==noHalt){
+        packet->setPhase(completedP);        
+        tState[packet->getTID()]=noWork;
+        cpu->getPortInterface()->setData(packet); 
+        clearStalls();
+        return;
+    }
+    if (packet != NULL) {
+        if(detectorStatus==fetchBroke)
+            detectorStatus=fetchMacro;
+        if (packet->getPhase() == dataRequest) {
+            StaticInstPtr ptr = packet->getInstPtr();
+            int numR = ptr->numSrcRegs();
+            packet->setNumSrcRegs(numR);
+            for (int i = 0; i < numR; i++) {
+                RegIndex src_reg = ptr->srcRegIdx(i);
+                      int indd;
+                if (src_reg < TheISA::FP_Base_DepTag) {                    
+                    packet->setSrcType(enInt, i);
+              
+                    if(locallyAvailable(src_reg,packet,enInt,indd)){
+                         packet->setSrcData(packet->getDestData(indd).data.ui, src_reg);       
+                    }else{
+                        DPRINTF(Squasher,"Register data for register %d being sent is %d\n",src_reg, cpu->readArchIntReg(src_reg, packet->getTID()));
+                        packet->setSrcData(cpu->readArchIntReg(src_reg, packet->getTID()), src_reg);
+                    }
+                } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
+                    packet->setSrcType(enFloat, i);
+                    if(locallyAvailable(src_reg- TheISA::FP_Base_DepTag,packet,enFloat,indd)){
+                         packet->setSrcData(packet->getDestData(indd).data.f, src_reg- TheISA::FP_Base_DepTag);       
+                    }else{ 
+                        DPRINTF(Squasher,"Register data for register %d being sent is %d\n",src_reg-TheISA::FP_Base_DepTag, cpu->readArchFloatReg(src_reg-TheISA::FP_Base_DepTag, packet->getTID()));
+                        packet->setSrcData(cpu->readArchFloatReg(src_reg-TheISA::FP_Base_DepTag, packet->getTID()), src_reg - TheISA::FP_Base_DepTag);
+                    }
+                } else if (src_reg < TheISA::Max_DepTag) {
+                    packet->setSrcType(enMisc, i);
+                    if(locallyAvailable(src_reg - TheISA::Ctrl_Base_DepTag,packet,enMisc,indd)){
+                         packet->setSrcData(packet->getDestData(indd).data.i, src_reg - TheISA::Ctrl_Base_DepTag);       
+                    }else{
+                         DPRINTF(Squasher,"Register data for register %d being sent is %d\n",src_reg,cpu->readMiscReg(src_reg-TheISA::Ctrl_Base_DepTag, packet->getTID()));
+                    packet->setSrcData(cpu->readMiscReg(src_reg-TheISA::Ctrl_Base_DepTag, packet->getTID()), src_reg - TheISA::Ctrl_Base_DepTag);
+                    }
+                }
+            }
+            DPRINTF(SimpleCPU,"Data packed in and sending\n");
+        }
+        cpu->getPortInterface()->setData(packet);
+    }else{
+        cpu->setRerun(false);
+        cpu->setHaltStatus(noHalt);
+    }
+}
+
+template <class Impl>
+void DefaultDetector<Impl>::clearDataHelper() {
+    if (queryHelper()) {
+        activeSquash = false;
+        cpu->setRerun(false);
+        CommPack* packet = cpu->getPortInterface()->getData();
+        delete packet;
+    }
+
+}
+
+template <class Impl>
+void DefaultDetector<Impl>::getDataHelper() {
+    StaticInstPtr ptr;
+
+    static int recvCount = 0;
+    if (queryHelper()) {
+        activeSquash = false;
+        cpu->setRerun(false);
+        CommPack* packet = cpu->getPortInterface()->getData();
+        recvCount++;
+        DPRINTF(Squasher, "The packet being read back is %i with recv count %d\n", packet, recvCount);
+        ptr = packet->getInstPtr();
+        for (int i = 0; i < lrqc; i++) {
+            if (packet->getDestType(i) == enInt) {
+                //                    this->setIntReg(lastRequest[i], packet->getData(i).data.ui);
+            }
+            if (packet->getDestType(i) == enFloat) {
+                //                    this->setFloatReg(lastRequest[i], packet->getData(i).data.f);
+            }
+        }
+        packet->setInstPtr(NULL);
+        delete packet;
+    }
+}
+
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/dyn_inst.hh
--- a/src/cpu/o3/dyn_inst.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/dyn_inst.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -62,6 +62,9 @@
 template <class Impl>
 class BaseO3DynInst : public BaseDynInst<Impl>
 {
+    protected:
+        bool errorReset;
+        bool errorIndicator;
   public:
     /** Typedef for the CPU. */
     typedef typename Impl::O3CPU O3CPU;
@@ -104,6 +107,26 @@
     /** Completes the access.  Only valid for memory operations. */
     Fault completeAcc(PacketPtr pkt);
 
+    bool erronous(){
+        return errorIndicator;
+    }
+    bool setError(){
+        if(!errorReset)
+            errorIndicator=true;
+        return errorIndicator;
+    }
+    bool resetError(){
+        errorIndicator=false;
+        errorReset=true;
+        return errorIndicator;
+    }
+
+    void updateError(bool err){
+        if(err&&!errorReset)
+            errorIndicator=err;
+        
+    }
+
   private:
     /** Initializes variables. */
     void initVars();
@@ -120,7 +143,7 @@
 
     /** Number of destination misc. registers. */
     uint8_t _numDestMiscRegs;
-
+    
 
   public:
 #if TRACING_ON
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/dyn_inst_impl.hh
--- a/src/cpu/o3/dyn_inst_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/dyn_inst_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -103,6 +103,8 @@
 void
 BaseO3DynInst<Impl>::initVars()
 {
+    errorIndicator=false;
+    errorReset=false;
     // Make sure to have the renamed register entries set to the same
     // as the normal register entries.  It will allow the IQ to work
     // without any modifications.
@@ -117,6 +119,7 @@
     this->_readySrcRegIdx.reset();
 
     _numDestMiscRegs = 0;
+    errorIndicator=false;
 
 #if TRACING_ON
     // Value -1 indicates that particular phase
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/fetch.hh
--- a/src/cpu/o3/fetch.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/fetch.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -55,9 +55,9 @@
 #include "mem/packet.hh"
 #include "mem/port.hh"
 #include "sim/eventq.hh"
+#include"convertor.hh"
 
 struct DerivO3CPUParams;
-
 /**
  * DefaultFetch class handles both single threaded and SMT fetch. Its
  * width is specified by the parameters; each cycle it tries to fetch
@@ -71,19 +71,21 @@
 {
   public:
     /** Typedefs from Impl. */
-    typedef typename Impl::CPUPol CPUPol;
-    typedef typename Impl::DynInst DynInst;
-    typedef typename Impl::DynInstPtr DynInstPtr;
-    typedef typename Impl::O3CPU O3CPU;
+      typedef typename Impl::CPUPol CPUPol;
+      typedef typename Impl::DynInst DynInst;
+      typedef typename Impl::DynInstPtr DynInstPtr;
+      typedef typename Impl::O3CPU O3CPU;
 
-    /** Typedefs from the CPU policy. */
-    typedef typename CPUPol::FetchStruct FetchStruct;
-    typedef typename CPUPol::TimeStruct TimeStruct;
+      /** Typedefs from the CPU policy. */
+      typedef typename CPUPol::FetchStruct FetchStruct;
+      typedef typename CPUPol::DetectorStruct DetectorStruct;
+      typedef typename CPUPol::TimeStruct TimeStruct;
 
     /** Typedefs from ISA. */
     typedef TheISA::MachInst MachInst;
     typedef TheISA::ExtMachInst ExtMachInst;
 
+
     class FetchTranslation : public BaseTLB::Translation
     {
       protected:
@@ -169,7 +171,8 @@
         IcacheWaitResponse,
         IcacheWaitRetry,
         IcacheAccessComplete,
-        NoGoodAddr
+        NoGoodAddr,
+        RepairWait
     };
 
     /** Fetching Policy, Add new policies here.*/
@@ -195,6 +198,9 @@
     std::list<ThreadID> priorityList;
 
   public:
+      
+      bool isHalted(ThreadID tid);
+
     /** DefaultFetch constructor. */
     DefaultFetch(O3CPU *_cpu, DerivO3CPUParams *params);
 
@@ -204,6 +210,8 @@
     /** Registers statistics. */
     void regStats();
 
+    bool checkError(ThreadID tid);
+
     /** Sets the main backwards communication time buffer pointer. */
     void setTimeBuffer(TimeBuffer<TimeStruct> *time_buffer);
 
@@ -212,6 +220,9 @@
 
     /** Sets pointer to time buffer used to communicate to the next stage. */
     void setFetchQueue(TimeBuffer<FetchStruct> *fq_ptr);
+    
+    
+    void setDetectorQueue(TimeBuffer<DetectorStruct> *detq_ptr);
 
     /** Initialize stage. */
     void startupStage();
@@ -247,8 +258,23 @@
 
     /** Tells fetch to wake up from a quiesce instruction. */
     void wakeFromQuiesce();
+    
+    
+    bool checkHalt();
+        
 
   private:
+
+    bool cleanRun;
+
+    stageModes_t currentM[Impl::MaxThreads];
+
+
+    stageModes_t checkFetchState(ThreadID tid);
+    
+    void setFetchState(stageModes_t fm,ThreadID tid);
+
+
     /** Reset this pipeline stage */
     void resetStage();
 
@@ -285,6 +311,7 @@
      * @return Any fault that occured.
      */
     bool fetchCacheLine(Addr vaddr, ThreadID tid, Addr pc);
+
     void finishTranslation(Fault fault, RequestPtr mem_req);
 
 
@@ -322,10 +349,17 @@
     void squash(const TheISA::PCState &newPC, const InstSeqNum seq_num,
                 DynInstPtr squashInst, ThreadID tid);
 
+    
     /** Ticks the fetch stage, processing all inputs signals and fetching
      * as many instructions as possible.
      */
     void tick();
+    
+    
+
+    void setBlocked(ThreadID tid);
+    
+    void unSetBlocked(ThreadID tid);
 
     /** Checks all input signals and updates the status as necessary.
      *  @return: Returns if the status has changed due to input signals.
@@ -339,6 +373,9 @@
      */
     void fetch(bool &status_change);
 
+
+    bool fetchDecode(TheISA::PCState thisPC, StaticInstPtr& curMacroop, ThreadID tid, Addr fetchAddr, bool& inRom, Addr& pcOffset, bool status_change);
+
     /** Align a PC to the start of an I-cache block. */
     Addr icacheBlockAlignPC(Addr addr)
     {
@@ -347,7 +384,9 @@
 
     /** The decoder. */
     TheISA::Decoder *decoder[Impl::MaxThreads];
-
+    
+    /** BPredUnit. */
+    BPredUnit *branchPred;
   private:
     DynInstPtr buildInst(ThreadID tid, StaticInstPtr staticInst,
                          StaticInstPtr curMacroop, TheISA::PCState thisPC,
@@ -375,6 +414,8 @@
     /** Profile the reasons of fetch stall. */
     void profileStall(ThreadID tid);
 
+
+    
   private:
     /** Pointer to the O3CPU. */
     O3CPU *cpu;
@@ -397,12 +438,20 @@
     /** Internal fetch instruction queue. */
     TimeBuffer<FetchStruct> *fetchQueue;
 
+    
+     TimeBuffer<DetectorStruct> *detectorQueue;
+     
+     TimeBuffer<DetectorStruct> *returnQueue;
+
     //Might be annoying how this name is different than the queue.
     /** Wire used to write any information heading to decode. */
     typename TimeBuffer<FetchStruct>::wire toDecode;
+    
+    typename TimeBuffer<DetectorStruct>::wire toDetector;
+    
+    typename TimeBuffer<TimeStruct>::wire fromDetector;
 
-    /** BPredUnit. */
-    BPredUnit *branchPred;
+
 
     TheISA::PCState pc[Impl::MaxThreads];
 
@@ -431,11 +480,14 @@
         bool iew;
         bool commit;
         bool drain;
+        bool repair;
     };
 
     /** Tracks which stages are telling fetch to stall. */
     Stalls stalls[Impl::MaxThreads];
 
+    unsigned addedOffset[Impl::MaxThreads];
+
     /** Decode to fetch delay. */
     Cycles decodeToFetchDelay;
 
@@ -498,6 +550,16 @@
      */
     bool interruptPending;
 
+    bool *faulty;
+    
+    bool *faultyZ;
+
+    int* eomap ;
+    
+    int *ezmap;
+
+    bool checkError(ThreadID tid,unsigned offset,unsigned off2,unsigned off3);
+
     /** Set to true if a pipelined I-cache request should be issued. */
     bool issuePipelinedIfetch[Impl::MaxThreads];
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/fetch_impl.hh
--- a/src/cpu/o3/fetch_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/fetch_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -60,6 +60,8 @@
 #include "debug/Activity.hh"
 #include "debug/Drain.hh"
 #include "debug/Fetch.hh"
+#include "debug/Squasher.hh"
+#include "debug/PH.hh"
 #include "debug/O3PipeView.hh"
 #include "mem/packet.hh"
 #include "params/DerivO3CPU.hh"
@@ -68,6 +70,7 @@
 #include "sim/eventq.hh"
 #include "sim/full_system.hh"
 #include "sim/system.hh"
+#include "cpu/o3/convertor.hh"
 
 using namespace std;
 
@@ -87,6 +90,30 @@
       numFetchingThreads(params->smtNumFetchingThreads),
       finishTranslationEvent(this)
 {
+    faulty=new bool[fetchWidth];
+    faultyZ=new bool[fetchWidth];
+
+    eomap= new int[fetchWidth];
+    ezmap= new int[fetchWidth];
+    for(int i=0;i<Impl::MaxThreads;i++)
+        currentM[i]=regularM;
+
+
+   for(int i=0;i<fetchWidth;i++) {
+       faulty[i]=false;
+       faultyZ[i]=false;
+       ezmap[i]=1;
+       eomap[i]=0;
+   }
+
+   if(params->efetch){
+        errorMap(params->efetchValue,faulty, eomap, fetchWidth, 32);
+    }
+
+   if(params->efetchZ){
+        errorMap(params->efetchZValue,faultyZ, ezmap, fetchWidth, 32);
+    }
+
     if (numThreads > Impl::MaxThreads)
         fatal("numThreads (%d) is larger than compiled limit (%d),\n"
               "\tincrease MaxThreads in src/cpu/o3/impl.hh\n",
@@ -129,6 +156,7 @@
 
     for (int i = 0; i < Impl::MaxThreads; i++) {
         decoder[i] = new TheISA::Decoder;
+        addedOffset[i]=0;
     }
 
     branchPred = params->branchPred;
@@ -282,6 +310,7 @@
     fromRename = timeBuffer->getWire(-renameToFetchDelay);
     fromIEW = timeBuffer->getWire(-iewToFetchDelay);
     fromCommit = timeBuffer->getWire(-commitToFetchDelay);
+    fromDetector=timeBuffer->getWire(0);
 }
 
 template<class Impl>
@@ -303,6 +332,17 @@
 
 template<class Impl>
 void
+DefaultFetch<Impl>::setDetectorQueue(TimeBuffer<DetectorStruct> *dq_ptr)
+{
+    detectorQueue = dq_ptr;
+
+    // Create wire to write information to proper place in fetch queue.
+    toDetector = detectorQueue->getWire(1);
+}
+
+
+template<class Impl>
+void
 DefaultFetch<Impl>::startupStage()
 {
     assert(priorityList.empty());
@@ -314,6 +354,19 @@
 }
 
 template<class Impl>
+void 
+DefaultFetch<Impl>::setFetchState(stageModes_t fm,ThreadID tid){
+    currentM[tid]=fm;
+}
+
+
+template<class Impl>
+stageModes_t
+DefaultFetch<Impl>::checkFetchState(ThreadID tid){
+    return currentM[tid];
+}
+
+template<class Impl>
 void
 DefaultFetch<Impl>::resetStage()
 {
@@ -338,6 +391,7 @@
         stalls[tid].iew = false;
         stalls[tid].commit = false;
         stalls[tid].drain = false;
+        stalls[tid].repair = false;
 
         priorityList.push_back(tid);
     }
@@ -367,7 +421,7 @@
 
     memcpy(cacheData[tid], pkt->getPtr<uint8_t>(), cacheBlkSize);
     cacheDataValid[tid] = true;
-
+    
     // Wake up the CPU (if it went to sleep and was waiting on
     // this completion event).
     cpu->wakeCPU();
@@ -734,13 +788,17 @@
 
     fetchStatus[tid] = Squashing;
 
-    // microops are being squashed, it is not known wheather the
+    // microops are being squashed, it is not known whether the
     // youngest non-squashed microop was  marked delayed commit
     // or not. Setting the flag to true ensures that the
     // interrupts are not handled when they cannot be, though
     // some opportunities to handle interrupts may be missed.
     delayedCommit[tid] = true;
 
+    stalls[tid].repair=false;
+    cpu->setHaltStatus(noHalt);
+    setFetchState(regularM,tid);
+
     ++fetchSquashCycles;
 }
 
@@ -784,8 +842,10 @@
     } else if (stalls[tid].commit) {
         DPRINTF(Fetch,"[tid:%i]: Stall from Commit stage detected.\n",tid);
         ret_val = true;
+    } else if (stalls[tid].repair){
+        DPRINTF(Fetch,"[tid:%i]: Stall due to repair detected.\n",tid);
+        ret_val = true;
     }
-
     return ret_val;
 }
 
@@ -836,6 +896,7 @@
                            ThreadID tid)
 {
     DPRINTF(Fetch, "[tid:%u]: Squash from commit.\n", tid);
+    DPRINTF(PH, "[tid:%u]: Squash from commit for seq number [sn:%d]\n", tid,seq_num);
 
     doSquash(newPC, squashInst, tid);
 
@@ -843,19 +904,112 @@
     cpu->removeInstsNotInROB(tid);
 }
 
+
+
+template <class Impl>
+bool
+DefaultFetch<Impl>::checkHalt()
+{
+    bool retV=false;
+    switch (cpu->getHaltStatus()){
+        case(fetchHalt):
+            retV=true;
+            break;
+        case(renameHalt):
+            retV=false;
+            break;
+        case(commitHalt):
+            retV=false;
+            break;
+        case (noHalt):
+            retV=false;
+            break;
+        default:break;
+    }
+    return retV;
+}
+
+template <class Impl>
+void 
+DefaultFetch<Impl>::setBlocked(ThreadID tid){
+    DPRINTF(Fetch,"Setting Stall due to Repair \n");
+    stalls[tid].repair = true;
+    fetchStatus[tid] =  RepairWait;
+}
+template <class Impl>
+void 
+DefaultFetch<Impl>::unSetBlocked(ThreadID tid){
+    if(stalls[tid].repair){
+        setFetchState(regularM,tid);
+        stalls[tid].repair = false;
+        fetchStatus[tid] = Running;
+    }
+}
+/*
+template <class Impl>
+bool
+DefaultFetch<Impl>::checkSquash()
+{
+    bool retV=false;
+    switch (cpu->getHaltStatus()){
+        case(fetchHalt):
+            retV=true;
+            break;
+        case(commitHalt):
+            retV=false;
+            break;
+        case(renameHalt):
+            retV=false;
+            break;
+        case (noHalt):
+            retV=false;
+            break;
+        default:break;
+    }
+    return retV;
+
+}
+*/
 template <class Impl>
 void
 DefaultFetch<Impl>::tick()
 {
+    //Fetch can be in three states: regular mode, squashing mode or halt mode. Squashing should lead to reset of the PC. 
+    //Should ask the CPU for the right PC, rewrite squash accordingly!!!
+    //check if there is a need to stop the fetch as a post process to a waiting squash.
+
     list<ThreadID>::iterator threads = activeThreads->begin();
     list<ThreadID>::iterator end = activeThreads->end();
     bool status_change = false;
-
+    while (threads != end) {
+        
+        ThreadID tid = *threads++;
+        DPRINTF(Fetch,"Fetch State for thread %d is %s\n",tid,getModeString(currentM[tid]));
+        switch(checkFetchState(tid)){
+            case squashM:
+                setBlocked(tid);
+                break;
+            case haltM:
+                setBlocked(tid);
+                break;
+            default:
+                if(stalls[tid].repair)
+                        unSetBlocked(tid);
+                break;
+            case regularM:
+                if(stalls[tid].repair)
+                        unSetBlocked(tid);
+                break;
+        }
+    }
+    
     wroteToTimeBuffer = false;
 
     for (ThreadID i = 0; i < Impl::MaxThreads; ++i) {
         issuePipelinedIfetch[i] = false;
     }
+    
+    threads = activeThreads->begin();
 
     while (threads != end) {
         ThreadID tid = *threads++;
@@ -863,7 +1017,7 @@
         // Check the signals for each thread to determine the proper status
         // for each thread.
         bool updated_status = checkSignalsAndUpdate(tid);
-        status_change =  status_change || updated_status;
+        status_change =  status_change || updated_status;           
     }
 
     DPRINTF(Fetch, "Running stage.\n");
@@ -903,7 +1057,7 @@
     for (ThreadID i = 0; i < Impl::MaxThreads; ++i) {
         if (issuePipelinedIfetch[i]) {
             pipelineIcacheAccesses(i);
-        }
+       }
     }
 
     // Reset the number of the instruction we've fetched.
@@ -957,14 +1111,13 @@
 
     // Check squash signals from commit.
     if (fromCommit->commitInfo[tid].squash) {
-
+        
         DPRINTF(Fetch, "[tid:%u]: Squashing instructions due to squash "
                 "from commit.\n",tid);
         // In any case, squash.
         squash(fromCommit->commitInfo[tid].pc,
                fromCommit->commitInfo[tid].doneSeqNum,
                fromCommit->commitInfo[tid].squashInst, tid);
-
         // If it was a branch mispredict on a control instruction, update the
         // branch predictor with that instruction, otherwise just kill the
         // invalid state we generated in after sequence number
@@ -978,6 +1131,7 @@
             branchPred->squash(fromCommit->commitInfo[tid].doneSeqNum,
                               tid);
         }
+        DPRINTF(Fetch,"Completed Squashing the Branch Predictor\n");
 
         return true;
     } else if (fromCommit->commitInfo[tid].doneSeqNum) {
@@ -1026,6 +1180,17 @@
         }
     }
 
+    if(!fromDetector->detectorInfo.working){
+        unSetBlocked(tid);
+
+        stalls[tid].repair=false;        
+    }
+/*    else{
+//        DPRINTF(Squasher,"[tid:%i]: Detectoro is Working\n",tid);
+        setBlocked(tid);
+        stalls[tid].repair=true;
+    }
+*/
     if (checkStall(tid) &&
         fetchStatus[tid] != IcacheWaitResponse &&
         fetchStatus[tid] != IcacheWaitRetry &&
@@ -1077,7 +1242,7 @@
             "[sn:%lli].\n", tid, thisPC.instAddr(),
             thisPC.microPC(), seq);
 
-    DPRINTF(Fetch, "[tid:%i]: Instruction is: %s\n", tid,
+    DPRINTF(Fetch, "[tid:%i]: [sn:%lli] Instruction is: %s\n", tid,instruction->seqNum,
             instruction->staticInst->
             disassemble(thisPC.instAddr()));
 
@@ -1105,6 +1270,46 @@
     return instruction;
 }
 
+
+template<class Impl>
+bool
+DefaultFetch<Impl>::checkError(ThreadID tid,unsigned blkOffset,unsigned statoffset,unsigned offset){
+    int *data;
+    bool fault=false;
+    static int val=0;
+
+    data=(int*)cacheData[tid];
+    int dv;
+    dv=data[blkOffset];
+    if(offset>0){
+        dv=dv>>(offset*8);
+        dv=dv<<16;
+        int v=data[blkOffset+1];
+        v=(v<<16)>>16;
+        dv=dv|v;
+    }
+    int index=blkOffset-statoffset;
+    index%=fetchWidth;
+    if(faulty[index]){
+        fault=eomap[index]&dv;
+    }
+    if (faultyZ[index]) {
+        fault |= ~(ezmap[index] & dv);
+    } 
+    if(fault){
+        val++;
+        if(val==2){
+            val=0;
+            fault=false;
+        }else{
+            DPRINTF(Fetch,"Thread is %d, index is %d \n",tid,index);
+        }
+
+    }
+    return fault;
+}
+
+
 template<class Impl>
 void
 DefaultFetch<Impl>::fetch(bool &status_change)
@@ -1119,7 +1324,7 @@
     if (tid == InvalidThreadID) {
         // Breaks looping condition in tick()
         threadFetched = numFetchingThreads;
-
+        DPRINTF(Fetch, "Invalid Tid at [tid:%i]\n", tid);
         if (numThreads == 1) {  // @todo Per-thread stats
             profileStall(0);
         }
@@ -1131,24 +1336,25 @@
 
     // The current PC.
     TheISA::PCState thisPC = pc[tid];
-
+//    Addr pcm= BaseCPU::PCMask;
     Addr pcOffset = fetchOffset[tid];
+    //DPRINTF(Fetch,"fetchOffset is %d and CPU Mask is %d\n", pcOffset, pcm);
     Addr fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
 
     bool inRom = isRomMicroPC(thisPC.microPC());
 
+    DPRINTF(Fetch, " PC instAddr = %d, fetchAddr is %d, MicroPC active is %s\n", thisPC.instAddr(),fetchAddr,inRom?"true":"false");
     // If returning from the delay of a cache miss, then update the status
     // to running, otherwise do the cache access.  Possibly move this up
     // to tick() function.
     if (fetchStatus[tid] == IcacheAccessComplete) {
         DPRINTF(Fetch, "[tid:%i]: Icache miss is complete.\n", tid);
-
         fetchStatus[tid] = Running;
         status_change = true;
     } else if (fetchStatus[tid] == Running) {
         // Align the fetch PC so its at the start of a cache block.
         Addr block_PC = icacheBlockAlignPC(fetchAddr);
-
+        DPRINTF(Fetch,"Fetch State is running for tid: %d\n",tid);
         // If buffer is no longer valid or fetchAddr has moved to point
         // to the next cache block, AND we have no remaining ucode
         // from a macro-op, then start fetch from icache.
@@ -1178,18 +1384,43 @@
         if (fetchStatus[tid] == Idle) {
             ++fetchIdleCycles;
             DPRINTF(Fetch, "[tid:%i]: Fetch is idle!\n", tid);
+        }else{
+            
         }
-
         // Status is Idle, so fetch should do nothing.
         return;
     }
+    DPRINTF(Fetch,"Starting fetch-decode\n");
+    StaticInstPtr curMacroop = macroop[tid];
+    ++fetchCycles;
+    if(fetchDecode(thisPC, curMacroop, tid,fetchAddr,inRom,pcOffset,status_change)){
+    }else{
 
-    ++fetchCycles;
+    }
 
+    
+
+    // pipeline a fetch if we're crossing a cache boundary and not in
+    // a state that would preclude fetching
+    fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
+    Addr block_PC = icacheBlockAlignPC(fetchAddr);
+    issuePipelinedIfetch[tid] = block_PC != cacheDataPC[tid] &&
+        fetchStatus[tid] != IcacheWaitResponse &&
+        fetchStatus[tid] != ItlbWait &&
+        fetchStatus[tid] != IcacheWaitRetry &&
+        fetchStatus[tid] != QuiescePending &&
+        !curMacroop;
+}
+
+template<class Impl>
+bool
+DefaultFetch<Impl>::fetchDecode(TheISA::PCState thisPC, StaticInstPtr& curMacroop, ThreadID tid, Addr fetchAddr, bool& inRom, Addr& pcOffset, bool status_change )
+{
     TheISA::PCState nextPC = thisPC;
 
     StaticInstPtr staticInst = NULL;
-    StaticInstPtr curMacroop = macroop[tid];
+    
+    static bool ret=false;
 
     // If the read of the first instruction was successful, then grab the
     // instructions from the rest of the cache line and put them into the
@@ -1205,13 +1436,19 @@
     TheISA::MachInst *cacheInsts =
         reinterpret_cast<TheISA::MachInst *>(cacheData[tid]);
 
+    //this is where we test the errors in the code!! cacheInsts.
+    //mapping this to the instruction finally decoded and the fetch path is interesting!!
+
+
     const unsigned numInsts = cacheBlkSize / instSize;
     unsigned blkOffset = (fetchAddr - cacheDataPC[tid]) / instSize;
+    unsigned statBlkOffset = (fetchAddr - cacheDataPC[tid]) / instSize;
 
     // Loop through instruction memory from the cache.
     // Keep issuing while fetchWidth is available and branch is not
     // predicted taken
-    while (numInst < fetchWidth && !predictedBranch) {
+
+    while (numInst < fetchWidth && !predictedBranch ) {
 
         // We need to process more memory if we aren't going to get a
         // StaticInst from the rom, the current macroop, or what's already
@@ -1219,6 +1456,7 @@
         bool needMem = !inRom && !curMacroop &&
             !decoder[tid]->instReady();
         fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
+        DPRINTF(Fetch, " PC = %d, fetchAddr is %d, need for Memory is %s\n", thisPC.instAddr(),fetchAddr,needMem?"true":"false");
         Addr block_PC = icacheBlockAlignPC(fetchAddr);
 
         if (needMem) {
@@ -1244,16 +1482,35 @@
                     break;
             }
 
+//Check for occurance of error here, if so, break the loop and start a repair run.
+            
+            if(checkError(tid,blkOffset,statBlkOffset,0)&&(fetchAddr==thisPC.instAddr())){
+                toDetector->pcState[toDetector->pcSize]= thisPC;
+                toDetector->pcSize++;
+                setFetchState(haltM,tid);
+                addedOffset[tid]=blkOffset-statBlkOffset;
+                DPRINTF(Fetch,"Error due to fetch/decode found here added offset of %d to %d, data is %x \n",addedOffset[tid],blkOffset, cacheInsts[blkOffset]);
+                ret=true;
+                pc[tid] = thisPC;
+                decoder[tid]->reset();
+                break;
+            }
+
             MachInst inst = TheISA::gtoh(cacheInsts[blkOffset]);
             decoder[tid]->moreBytes(thisPC, fetchAddr, inst);
 
+           
             if (decoder[tid]->needMoreBytes()) {
+                DPRINTF(Fetch,"This Instruction needs more bytes\n");
                 blkOffset++;
                 fetchAddr += instSize;
                 pcOffset += instSize;
             }
+            DPRINTF(Fetch, " Tid is %d PC = %d, fetchAddr is %d blkoffset is %d data is %x \n",tid, thisPC.instAddr(),fetchAddr, blkOffset,cacheInsts[blkOffset]);
+            DPRINTF(Fetch,"This PC is thumb? %s\n",thisPC.thumb()?"True":"False");
+
         }
-
+        
         // Extract as many instructions and/or microops as we can from
         // the memory we've processed so far.
         do {
@@ -1265,11 +1522,14 @@
                     ++fetchedInsts;
 
                     if (staticInst->isMacroop()) {
+                        DPRINTF(Fetch,"This PC is Macroop\n");
                         curMacroop = staticInst;
                     } else {
+                        DPRINTF(Fetch,"This PC is not Macroop\n");
                         pcOffset = 0;
                     }
                 } else {
+                        DPRINTF(Fetch,"This instruction is not ready\n");
                     // We need more bytes for this instruction so blkOffset and
                     // pcOffset will be updated
                     break;
@@ -1280,10 +1540,13 @@
             // thinks we are...
             bool newMacro = false;
             if (curMacroop || inRom) {
+                    DPRINTF(Fetch,"This Instruction is Macroop or inRom\n");
                 if (inRom) {
+                    DPRINTF(Fetch,"This Instruction is inRom\n");
                     staticInst = cpu->microcodeRom.fetchMicroop(
                             thisPC.microPC(), curMacroop);
                 } else {
+                    DPRINTF(Fetch,"This Instruction is not in ROM\n");
                     staticInst = curMacroop->fetchMicroop(thisPC.microPC());
                 }
                 newMacro |= staticInst->isLastMicroop();
@@ -1293,6 +1556,18 @@
                 buildInst(tid, staticInst, curMacroop,
                           thisPC, nextPC, true);
 
+
+            if(staticInst->opClass()==IntAluOp){ 
+//                DPRINTF(Fetch, "Gayo :%s::%x:%s \n", staticInst->getName(),staticInst->machInst,staticInst->disassemble(thisPC.instAddr()));
+
+
+            }
+
+            if(ret)
+                DPRINTF(Fetch, "[tid:%i]: Error due Instruction is: %s\n", tid,
+            instruction->staticInst->
+            disassemble(thisPC.instAddr()));
+
             numInst++;
 
 #if TRACING_ON
@@ -1334,6 +1609,7 @@
             }
         } while ((curMacroop || decoder[tid]->instReady()) &&
                  numInst < fetchWidth);
+        ret=false;
     }
 
     if (predictedBranch) {
@@ -1356,16 +1632,9 @@
 
     pc[tid] = thisPC;
 
-    // pipeline a fetch if we're crossing a cache boundary and not in
-    // a state that would preclude fetching
-    fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
-    Addr block_PC = icacheBlockAlignPC(fetchAddr);
-    issuePipelinedIfetch[tid] = block_PC != cacheDataPC[tid] &&
-        fetchStatus[tid] != IcacheWaitResponse &&
-        fetchStatus[tid] != ItlbWait &&
-        fetchStatus[tid] != IcacheWaitRetry &&
-        fetchStatus[tid] != QuiescePending &&
-        !curMacroop;
+    return true;
+
+
 }
 
 template<class Impl>
@@ -1439,7 +1708,18 @@
     }
 }
 
-
+template<class Impl>
+bool
+DefaultFetch<Impl>::isHalted(ThreadID tid) {
+    bool ret=(fetchStatus[tid] == Running ||
+            fetchStatus[tid] == IcacheAccessComplete ||
+            fetchStatus[tid] == Idle);
+    ret=!ret;
+    if(!((fetchStatus[tid] == Idle) || (fetchStatus[tid] == Blocked) || (activeThreads->begin() == activeThreads->end()))){
+        DPRINTF(Fetch,"Fetch not halted due to:%d %s %s %s\n",fetchStatus[tid],(fetchStatus[tid] == Idle)?"idle true":"idle false",(fetchStatus[tid] == Blocked)?"Blocked true":"Blocked false",(activeThreads->begin() == activeThreads->end())?"threads true":"threads false");
+    }
+    return (fetchStatus[tid] == Idle) || (fetchStatus[tid] == Blocked) || (activeThreads->begin() == activeThreads->end())||ret;
+}
 template<class Impl>
 ThreadID
 DefaultFetch<Impl>::roundRobin()
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/free_list.cc
--- a/src/cpu/o3/free_list.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/free_list.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -31,6 +31,7 @@
 #include "base/trace.hh"
 #include "cpu/o3/free_list.hh"
 #include "debug/FreeList.hh"
+#include "convertor.hh"
 
 SimpleFreeList::SimpleFreeList(ThreadID activeThreads,
                                unsigned _numLogicalIntRegs,
@@ -45,6 +46,7 @@
 {
     DPRINTF(FreeList, "Creating new free list object.\n");
 
+
     // Put all of the extra physical registers onto the free list.  This
     // means excluding all of the base logical registers.
     for (PhysRegIndex i = numLogicalIntRegs * activeThreads;
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/free_list.hh
--- a/src/cpu/o3/free_list.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/free_list.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -78,6 +78,8 @@
     /** Total number of physical registers. */
     int numPhysicalRegs;
 
+
+
   public:
     /** Constructs a free list.
      *  @param activeThreads Number of active threads.
@@ -92,6 +94,7 @@
                    unsigned _numLogicalFloatRegs,
                    unsigned _numPhysicalFloatRegs);
 
+
     /** Gives the name of the freelist. */
     std::string name() const;
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/fu_pool.cc
--- a/src/cpu/o3/fu_pool.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/fu_pool.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -96,6 +96,11 @@
     //  Iterate through the list of FUDescData structures
     //
     const vector<FUDesc *> &paramList =  p->FUList;
+    
+//    int listSize=paramList.size();
+
+    
+//    std::cout<<"Size of FU List: "<<listSize<<std::endl;
     for (FUDDiterator i = paramList.begin(); i != paramList.end(); ++i) {
 
         //
@@ -113,6 +118,7 @@
 
             OPDDiterator j = (*i)->opDescList.begin();
             OPDDiterator end = (*i)->opDescList.end();
+//             cout<<(*j)->opClass<<endl;
             for (; j != end; ++j) {
                 // indicate that this pool has this capability
                 capabilityList.set((*j)->opClass);
@@ -131,11 +137,14 @@
                 if ((*j)->issueLat > maxIssueLatencies[(*j)->opClass])
                     maxIssueLatencies[(*j)->opClass] = (*j)->issueLat;
             }
+            
+           
 
             numFU++;
 
             //  Add the appropriate number of copies of this FU to the list
             fu->name = (*i)->name() + "(0)";
+//            cout<<"name: "<<fu->name<<endl;
             funcUnits.push_back(fu);
 
             for (int c = 1; c < (*i)->number; ++c) {
@@ -145,8 +154,10 @@
 
                 s << (*i)->name() << "(" << c << ")";
                 fu2->name = s.str();
+//                cout<<"name:"<<fu2->name<<endl;
                 funcUnits.push_back(fu2);
             }
+//            cout<<numFU<<endl;
         }
     }
 
@@ -254,6 +265,9 @@
         cout << "\n";
     }
 }
+std::bitset<Num_OpClasses> FUPool::getFUCapabilities(int idx){
+    return funcUnits[idx]->capabilities();
+}
 
 bool
 FUPool::isDrained() const
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/fu_pool.hh
--- a/src/cpu/o3/fu_pool.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/fu_pool.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -158,6 +158,8 @@
 
     /** Debugging function used to dump FU information. */
     void dump();
+    
+    std::bitset<Num_OpClasses> getFUCapabilities(int idx);
 
     /** Returns the operation execution latency of the given capability. */
     Cycles getOpLatency(OpClass capability) {
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/iew.hh
--- a/src/cpu/o3/iew.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/iew.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -123,6 +123,7 @@
     StageStatus wbStatus;
 
   public:
+      bool isHalted(ThreadID tid);
     /** Constructs a DefaultIEW with the given parameters. */
     DefaultIEW(O3CPU *_cpu, DerivO3CPUParams *params);
 
@@ -216,7 +217,7 @@
         ++wbOutstanding;
         if (wbOutstanding == wbMax)
             ableToIssue = false;
-        DPRINTF(IEW, "wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
+        DPRINTF(IEW, "incrementing wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
         assert(wbOutstanding <= wbMax);
 #ifdef DEBUG
         wbList.insert(sn);
@@ -228,7 +229,7 @@
         if (wbOutstanding == wbMax)
             ableToIssue = true;
         wbOutstanding--;
-        DPRINTF(IEW, "wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
+        DPRINTF(IEW, "decrementing wbOutstanding: %i [sn:%lli]\n", wbOutstanding, sn);
         assert(wbOutstanding >= 0);
 #ifdef DEBUG
         assert(wbList.find(sn) != wbList.end());
@@ -326,6 +327,7 @@
      */
     void tick();
 
+    void killBuffer();
   private:
     /** Updates execution stats based on the instruction. */
     void updateExeInstStats(DynInstPtr &inst);
@@ -463,6 +465,8 @@
     /** Pointer to list of active threads. */
     std::list<ThreadID> *activeThreads;
 
+    bool faultDet;
+
     /** Maximum size of the skid buffer. */
     unsigned skidBufferMax;
 
@@ -536,6 +540,8 @@
     Stats::Formula wbFanout;
     /** Number of instructions per cycle delayed in writing back . */
     Stats::Formula wbPenalizedRate;
+
+    Stats::Scalar countIEWReSquases;
 };
 
 #endif // __CPU_O3_IEW_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/iew_impl.hh
--- a/src/cpu/o3/iew_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/iew_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -56,6 +56,7 @@
 #include "debug/Decode.hh"
 #include "debug/Drain.hh"
 #include "debug/IEW.hh"
+#include "debug/PH.hh"
 #include "debug/O3PipeView.hh"
 #include "params/DerivO3CPU.hh"
 
@@ -75,7 +76,8 @@
       issueWidth(params->issueWidth),
       wbOutstanding(0),
       wbWidth(params->wbWidth),
-      numThreads(params->numThreads)
+      numThreads(params->numThreads),
+      faultDet(false)
 {
     _status = Active;
     exeStatus = Running;
@@ -129,6 +131,9 @@
     iewBlockCycles
         .name(name() + ".iewBlockCycles")
         .desc("Number of cycles IEW is blocking");
+countIEWReSquases
+        .name(name() + ".rerun_iew")
+        .desc("Number of IEW squashes");
 
     iewUnblockCycles
         .name(name() + ".iewUnblockCycles")
@@ -432,6 +437,8 @@
 {
     DPRINTF(IEW, "[tid:%i]: Squashing all instructions.\n", tid);
 
+//    DPRINTF(PH,"Squash started on all instructions\n");
+
     // Tell the IQ to start squashing.
     instQueue.squash(tid);
 
@@ -869,6 +876,10 @@
 #endif
     for (int i = 0; i < insts_from_rename; ++i) {
         insts[fromRename->insts[i]->threadNumber].push(fromRename->insts[i]);
+        DynInstPtr inst=fromRename->insts[i];
+        if(inst->erronous()&&!inst->isControl()&&!cpu->isRerun()){
+            faultDet=true;
+        }
     }
 }
 
@@ -1218,15 +1229,18 @@
     // Execute/writeback any instructions that are available.
     int insts_to_execute = fromIssue->size;
     int inst_num = 0;
+    DPRINTF(IEW,"Execute sn:\n");
     for (; inst_num < insts_to_execute;
           ++inst_num) {
 
         DPRINTF(IEW, "Execute: Executing instructions from IQ.\n");
 
         DynInstPtr inst = instQueue.getInstToExecute();
-
+        
         DPRINTF(IEW, "Execute: Processing PC %s, [tid:%i] [sn:%i].\n",
                 inst->pcState(), inst->threadNumber,inst->seqNum);
+        Fault fault = NoFault;
+
 
         // Check if the instruction is squashed; if so then skip it
         if (inst->isSquashed()) {
@@ -1248,8 +1262,6 @@
             continue;
         }
 
-        Fault fault = NoFault;
-
         // Execute instruction.
         // Note that if the instruction faults, it will be handled
         // at the commit stage.
@@ -1344,6 +1356,10 @@
             // that have not been executed.
             bool loadNotExecuted = !inst->isExecuted() && inst->isLoad();
 
+            DPRINTF(IEW, "Checking for branching conditions for [sn:%lli].\n", inst->seqNum);
+            if(inst->mispredicted()){
+                DPRINTF(IEW,"Mispredicted\n");
+            }
             if (inst->mispredicted() && !loadNotExecuted) {
                 fetchRedirect[tid] = true;
 
@@ -1498,6 +1514,10 @@
 
     sortInsts();
 
+    if(faultDet){
+//        return;
+    }
+
     // Free function units marked as being freed this cycle.
     fuPool->processFreeUnits();
 
@@ -1609,6 +1629,13 @@
         cpu->activityThisCycle();
     }
 }
+template <class Impl>
+void 
+DefaultIEW<Impl>::killBuffer()
+{
+
+}
+
 
 template <class Impl>
 void
@@ -1655,7 +1682,7 @@
         if (inst->mispredicted()) {
             fetchRedirect[tid] = true;
 
-            DPRINTF(IEW, "Execute: Branch mispredict detected.\n");
+            DPRINTF(IEW, "Execute2: Branch mispredict detected.\n");
             DPRINTF(IEW, "Predicted target was PC:%#x, NPC:%#x.\n",
                     inst->predInstAddr(), inst->predNextInstAddr());
             DPRINTF(IEW, "Execute: Redirecting fetch to PC: %#x,"
@@ -1672,3 +1699,11 @@
         }
     }
 }
+
+template <class Impl>
+bool
+DefaultIEW<Impl>::isHalted(ThreadID tid) {
+    DPRINTF(IEW,"IEW not halted due to: %s %s %s %d\n",(dispatchStatus[tid] == Idle)?"idle true":"idle false",(dispatchStatus[tid] == Blocked)?"Blocked true":"Blocked false",(_status == Inactive)?"threads true":"threads false",wbOutstanding);
+
+    return ( (dispatchStatus[tid] == Idle) || (dispatchStatus[tid] == Blocked) || (_status == Inactive))&&wbOutstanding == 0;
+}
\ No newline at end of file
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/impl.hh
--- a/src/cpu/o3/impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -77,7 +77,8 @@
 
     enum {
       MaxWidth = 8,
-      MaxThreads = 4
+      MaxThreads = 4,
+      MaxMicro=30
     };
 };
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/inst_queue.hh
--- a/src/cpu/o3/inst_queue.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/inst_queue.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -292,6 +292,7 @@
     /** Function unit pool. */
     FUPool *fuPool;
 
+    std::bitset<Num_OpClasses> getFUCapabilities(int idx);
     //////////////////////////////////////
     // Instruction lists, ready queues, and ordering
     //////////////////////////////////////
@@ -460,7 +461,27 @@
     /** Debugging function to dump out all instructions that are in the
      *  IQ.
      */
+
+    typedef struct {
+        bool * fus;
+        int * fFus;
+        uint8_t *fstrt,*ffin;
+        int fuNum,numClasses;
+    } IQFaultMap;
+    
+    IQFaultMap fmap;
+    
     void dumpInsts();
+    
+    void setupPair(int num, bool** in, int** f);
+    
+    void setupFaults(DerivO3CPUParams *params,FUPool* fpool);
+    
+    int convertFUOpclassIndex(int idx, OpClass op_class,std::string mnemonic);
+    
+    bool checkPorts(int idx, DynInstPtr& inst);
+    
+    bool checkFault(int idx, DynInstPtr &inst);
 
     /** Stat for number of instructions added. */
     Stats::Scalar iqInstsAdded;
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/inst_queue_impl.hh
--- a/src/cpu/o3/inst_queue_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/inst_queue_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -49,7 +49,11 @@
 #include "debug/IQ.hh"
 #include "enums/OpClass.hh"
 #include "params/DerivO3CPU.hh"
+#include "params/FUPool.hh"
 #include "sim/core.hh"
+#include<iostream>
+
+#include"cpu/o3/convertor.hh"
 
 // clang complains about std::set being overloaded with Packet::set if
 // we open up the entire namespace std
@@ -92,6 +96,10 @@
       commitToIEWDelay(params->commitToIEWDelay)
 {
     assert(fuPool);
+    
+
+    setupFaults(params,fuPool);
+    
 
     numThreads = params->numThreads;
 
@@ -797,6 +805,10 @@
         // If we have an instruction that doesn't require a FU, or a
         // valid FU, then schedule for execution.
         if (idx == -2 || idx != -1) {
+            
+            if(idx>-1){
+                issuing_inst->updateError(checkFault(idx,issuing_inst));
+            }
             if (op_latency == Cycles(1)) {
                 i2e_info->size++;
                 instsToExecute.push_back(issuing_inst);
@@ -1026,7 +1038,7 @@
         addToOrderList(op_class);
     }
 
-    DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
+    DPRINTF(IQ, "Memory Instruction is ready to issue, putting it onto "
             "the ready list, PC %s opclass:%i [sn:%lli].\n",
             ready_inst->pcState(), op_class, ready_inst->seqNum);
 }
@@ -1190,7 +1202,7 @@
                     nonSpecInsts.find(squashed_inst->seqNum);
 
                 if (ns_inst_it == nonSpecInsts.end()) {
-                    assert(squashed_inst->getFault() != NoFault);
+                    assert(squashed_inst->getFault() != NoFault||squashed_inst->erronous() );
                 } else {
 
                     (*ns_inst_it).second = NULL;
@@ -1327,7 +1339,7 @@
 
         OpClass op_class = inst->opClass();
 
-        DPRINTF(IQ, "Instruction is ready to issue, putting it onto "
+        DPRINTF(IQ, "Non Memory Instruction is ready to issue, putting it onto "
                 "the ready list, PC %s opclass:%i [sn:%lli].\n",
                 inst->pcState(), op_class, inst->seqNum);
 
@@ -1508,3 +1520,96 @@
         ++num;
     }
 }
+
+template <class Impl>
+std::bitset<Num_OpClasses> InstructionQueue<Impl>::getFUCapabilities(int idx){
+    return this->fuPool->getFUCapabilities(idx);
+}
+
+template <class Impl>
+void
+InstructionQueue<Impl>::setupPair(int num, bool** in, int** f) {
+    bool *indic = new bool[num];
+    *in=indic;
+
+    int* faults = new int[num];
+    *f=faults;
+    for (int i = 0; i < num; i++) {
+        indic[i] = false;
+        faults[i] = 0;
+    }
+}
+
+template <class Impl>
+void
+InstructionQueue<Impl>::setupFaults(DerivO3CPUParams *params,FUPool* fpool) {
+   
+    fmap.numClasses=Num_OpClasses+4+2+1; //3 new intalu classes, 2 read port and 1 write port, 1 to check if alu is operational
+    
+    int listSize=fpool->size();
+    fmap.fuNum=listSize;
+    
+//    std::cout<<"Number of FUs from the IQ"<<listSize<<std::endl;
+    setupPair(fmap.fuNum*fmap.numClasses, &fmap.fus, &fmap.fFus);
+    if (params->eFU) {
+//        std::cout<<"Error Functional units"<<std::endl;
+        errorMap(params->eFUValue, fmap.fus, fmap.fFus, fmap.fuNum*fmap.numClasses, 8);
+    }
+}
+
+template <class Impl>
+int
+InstructionQueue<Impl>::convertFUOpclassIndex(int idx, OpClass op_class,std::string mnemonic){
+    int index=0;
+    if(op_class==IntAluOp){
+        index=getAluClass(mnemonic);
+        if(index==otherOp)
+            return 0;
+        index+=fmap.numClasses-8+fmap.numClasses*idx;
+    }else{
+        index=fmap.numClasses*idx+op_class;
+    }
+    return index;
+}
+
+template <class Impl>
+bool
+InstructionQueue<Impl>::checkPorts(int idx, DynInstPtr& inst){
+    bool val=false;
+    int rind=inst->numSrcRegs();
+    int lind=0;
+    int index=idx*fmap.numClasses+fmap.numClasses-5;
+    for(int i=0;i<rind;i++){
+        if(inst->srcRegIdx(i)<15){
+            val|=fmap.fFus[index+lind++];
+        }
+    }
+    index+=4;
+    val|=fmap.fFus[index];
+    return val;
+}
+
+template <class Impl>
+bool
+InstructionQueue<Impl>::checkFault(int idx, DynInstPtr& inst){
+    static bool val=true;
+    if(getFUCapabilities(idx)[inst->opClass()]){
+        //cout<<"checking here:"<<convertFUOpclassIndex(idx,inst->opClass(),inst->staticInst->getName())<<endl;
+        
+        //cout<<fmap.fus[convertFUOpclassIndex(idx,inst->opClass(),inst->staticInst->getName())]<<endl;
+       bool fault= fmap.fus[convertFUOpclassIndex(idx,inst->opClass(),inst->staticInst->getName())]||checkPorts(idx,inst); 
+       if(val&&fault){
+           val=false;
+           return fault;
+       }else{
+           if(fault){
+                val=true;
+                return false;
+           }
+       }
+    }        
+    return false;
+}
+
+
+
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/lsq_unit.hh
--- a/src/cpu/o3/lsq_unit.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/lsq_unit.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -557,7 +557,9 @@
         }
 
     }
-
+    
+    bool * faulty,*lqf,*sqf;
+    int *emap,*lqmap,*sqmap;
     /** Returns whether or not the LSQ unit is stalled. */
     bool isStalled()  { return stalled; }
 };
@@ -572,6 +574,7 @@
     assert(load_inst);
 
     assert(!load_inst->isExecuted());
+    
 
     // Make sure this isn't an uncacheable access
     // A bit of a hackish way to get uncached accesses to work only if they're
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/lsq_unit_impl.hh
--- a/src/cpu/o3/lsq_unit_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/lsq_unit_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -55,6 +55,7 @@
 #include "debug/O3PipeView.hh"
 #include "mem/packet.hh"
 #include "mem/request.hh"
+#include "convertor.hh"
 
 template<class Impl>
 LSQUnit<Impl>::WritebackEvent::WritebackEvent(DynInstPtr &_inst, PacketPtr _pkt,
@@ -167,6 +168,16 @@
     needsTSO = params->needsTSO;
 
     resetState();
+    
+    faulty=new bool[LQEntries+SQEntries];
+    emap=new int[LQEntries+SQEntries];
+    lqf=faulty;
+    sqf=faulty+LQEntries;
+    lqmap=emap;
+    sqmap=emap+LQEntries;
+    for(int i=0;i<LQEntries+SQEntries;i++) {
+        faulty[i]=false;emap[i]=0;
+    }
 }
 
 
@@ -380,6 +391,10 @@
     store_inst->sqIdx = storeTail;
     store_inst->lqIdx = loadTail;
 
+//    if(sqf[storeTail]&&(sqmap[storetail]&)){
+//
+//    }
+
     storeQueue[storeTail] = SQEntry(store_inst);
 
     incrStIdx(storeTail);
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/regfile.hh
--- a/src/cpu/o3/regfile.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/regfile.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -41,6 +41,7 @@
 #include "config/the_isa.hh"
 #include "cpu/o3/comm.hh"
 #include "debug/IEW.hh"
+#include"convertor.hh"
 
 /**
  * Simple physical register file class.
@@ -80,6 +81,8 @@
      */
     ~PhysRegFile();
 
+
+
     //Everything below should be pretty well identical to the normal
     //register file that exists within AlphaISA class.
     //The duplication is unfortunate but it's better than having
@@ -183,6 +186,7 @@
     O3CPU *cpu;
 
   public:
+
     /** Number of physical integer registers. */
     unsigned numPhysicalIntRegs;
     /** Number of physical floating point registers. */
@@ -191,13 +195,14 @@
 
 template <class Impl>
 PhysRegFile<Impl>::PhysRegFile(O3CPU *_cpu, unsigned _numPhysicalIntRegs,
-                               unsigned _numPhysicalFloatRegs)
+        unsigned _numPhysicalFloatRegs)
     : cpu(_cpu), numPhysicalIntRegs(_numPhysicalIntRegs),
       numPhysicalFloatRegs(_numPhysicalFloatRegs)
 {
     intRegFile = new IntReg[numPhysicalIntRegs];
     floatRegFile = new PhysFloatReg[numPhysicalFloatRegs];
 
+
     memset(intRegFile, 0, sizeof(IntReg) * numPhysicalIntRegs);
     memset(floatRegFile, 0, sizeof(PhysFloatReg) * numPhysicalFloatRegs);
 }
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rename.hh
--- a/src/cpu/o3/rename.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rename.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -48,6 +48,7 @@
 #include "base/statistics.hh"
 #include "config/the_isa.hh"
 #include "cpu/timebuf.hh"
+#include"convertor.hh"
 
 struct DerivO3CPUParams;
 
@@ -64,9 +65,8 @@
  * and there are no instructions in flight to the ROB.
  */
 template<class Impl>
-class DefaultRename
-{
-  public:
+class DefaultRename {
+public:
     // Typedefs from the Impl.
     typedef typename Impl::CPUPol CPUPol;
     typedef typename Impl::DynInstPtr DynInstPtr;
@@ -75,6 +75,7 @@
     // Typedefs from the CPUPol
     typedef typename CPUPol::DecodeStruct DecodeStruct;
     typedef typename CPUPol::RenameStruct RenameStruct;
+    typedef typename CPUPol::DetectorStruct DetectorStruct;
     typedef typename CPUPol::TimeStruct TimeStruct;
     typedef typename CPUPol::FreeList FreeList;
     typedef typename CPUPol::RenameMap RenameMap;
@@ -92,10 +93,35 @@
     typedef std::list<DynInstPtr> InstQueue;
     typedef typename std::list<DynInstPtr>::iterator ListIt;
 
-  public:
+    typedef struct {
+        bool * archRegs,  *physRegs, *isQue, *lq, *sq, *rob;
+        int * farchRegs, *fphysRegs, *fisQue, *flq, *fsq, *frob;
+        int aNum,pNum,isQNum,lqNum,sqNum,robNum;
+    } RenameFaultMap;
+    
+    RenameFaultMap fmap;
+    
+    enum FaultStatus{
+        eArch, ePhys, eIsQ, eLQ, eSQ, eROB
+    };
+
+    void setupPair(int num, bool** indic, int** faults);
+    
+    bool checkFaults(FaultStatus fs, int index, int value);
+    
+    bool activeRerun;
+    int callActive;
+    
+    int lqCounter,sqCounter,iqCounter,robCounter;
+
+public:
+
     /** Overall rename status. Used to determine if the CPU can
      * deschedule itself due to a lack of activity.
      */
+
+
+
     enum RenameStatus {
         Active,
         Inactive
@@ -109,17 +135,31 @@
         Squashing,
         Blocked,
         Unblocking,
-        SerializeStall
+        SerializeStall,
+        RepairWait
     };
 
-  private:
+private:
     /** Rename status. */
     RenameStatus _status;
 
     /** Per-thread status. */
     ThreadStatus renameStatus[Impl::MaxThreads];
 
-  public:
+public:
+
+    void setupFaults(DerivO3CPUParams *params);
+
+    stageModes_t currentM[Impl::MaxThreads];
+
+
+    stageModes_t checkRenameState(ThreadID tid);
+    
+    void setRenameState(stageModes_t fm,ThreadID tid);
+
+    bool isHalted(ThreadID tid) {
+        return (renameStatus[tid] == Idle) || (renameStatus[tid] == Blocked) || _status == Inactive;
+    }
     /** DefaultRename constructor. */
     DefaultRename(O3CPU *_cpu, DerivO3CPUParams *params);
 
@@ -138,22 +178,26 @@
     /** Sets pointer to time buffer coming from decode. */
     void setDecodeQueue(TimeBuffer<DecodeStruct> *dq_ptr);
 
+    void setDetectorQueue(TimeBuffer<DetectorStruct> *detq_ptr);
+
     /** Sets pointer to IEW stage. Used only for initialization. */
-    void setIEWStage(IEW *iew_stage)
-    { iew_ptr = iew_stage; }
+    void setIEWStage(IEW *iew_stage) {
+        iew_ptr = iew_stage;
+    }
 
     /** Sets pointer to commit stage. Used only for initialization. */
-    void setCommitStage(Commit *commit_stage)
-    { commit_ptr = commit_stage; }
+    void setCommitStage(Commit *commit_stage) {
+        commit_ptr = commit_stage;
+    }
 
-  private:
+private:
     /** Pointer to IEW stage. Used only for initialization. */
     IEW *iew_ptr;
 
     /** Pointer to commit stage. Used only for initialization. */
     Commit *commit_ptr;
 
-  public:
+public:
     /** Initializes variables for the stage. */
     void startupStage();
 
@@ -178,6 +222,12 @@
     /** Takes over from another CPU's thread. */
     void takeOverFrom();
 
+    bool checkHalt();
+
+    void rewindHistory(const InstSeqNum &squashSeqNum, ThreadID tid);
+
+
+
     /** Squashes all instructions in a thread. */
     void squash(const InstSeqNum &squash_seq_num, ThreadID tid);
 
@@ -186,10 +236,16 @@
      */
     void tick();
 
+    void setBlocked(ThreadID tid);
+
+    void unSetBlocked(ThreadID tid);
+
+    bool checkSquash();
+
     /** Debugging function used to dump history buffer of renamings. */
     void dumpHistory();
 
-  private:
+private:
     /** Reset this pipeline stage */
     void resetStage();
 
@@ -217,6 +273,8 @@
 
     /** Returns if all of the skid buffers are empty. */
     bool skidsEmpty();
+    
+    void checkInstErrors(DynInstPtr &inst);
 
     /** Updates overall rename status based on all of the threads' statuses. */
     void updateStatus();
@@ -283,11 +341,11 @@
      * register for that arch. register, and the new physical register.
      */
     struct RenameHistory {
+
         RenameHistory(InstSeqNum _instSeqNum, RegIndex _archReg,
-                      PhysRegIndex _newPhysReg, PhysRegIndex _prevPhysReg)
-            : instSeqNum(_instSeqNum), archReg(_archReg),
-              newPhysReg(_newPhysReg), prevPhysReg(_prevPhysReg)
-        {
+                PhysRegIndex _newPhysReg, PhysRegIndex _prevPhysReg)
+        : instSeqNum(_instSeqNum), archReg(_archReg),
+        newPhysReg(_newPhysReg), prevPhysReg(_prevPhysReg) {
         }
 
         /** The sequence number of the instruction that renamed. */
@@ -317,12 +375,18 @@
     /** Wire to get commit's output from backwards time buffer. */
     typename TimeBuffer<TimeStruct>::wire fromCommit;
 
+    typename TimeBuffer<TimeStruct>::wire fromDetector;
+
     /** Wire to write infromation heading to previous stages. */
     typename TimeBuffer<TimeStruct>::wire toDecode;
 
+    typename TimeBuffer<DetectorStruct>::wire toDetector;
+
     /** Rename instruction queue. */
     TimeBuffer<RenameStruct> *renameQueue;
 
+    TimeBuffer<DetectorStruct> *detectorQueue;
+
     /** Wire to write any information heading to IEW. */
     typename TimeBuffer<RenameStruct>::wire toIEW;
 
@@ -384,6 +448,7 @@
     struct Stalls {
         bool iew;
         bool commit;
+        bool repair;
     };
 
     /** Tracks which stages are telling decode to stall. */
@@ -438,6 +503,10 @@
 
     PhysRegIndex maxPhysicalRegs;
 
+    PhysRegIndex maxIntRegs;
+
+    PhysRegIndex maxFloatRegs;
+
     /** Enum to record the source of a structure full stall.  Can come from
      * either ROB, IQ, LSQ, and it is priortized in that order.
      */
@@ -482,7 +551,11 @@
     Stats::Scalar renameRenamedOperands;
     /** Stat for total number of source register rename lookups. */
     Stats::Scalar renameRenameLookups;
+    
     Stats::Scalar intRenameLookups;
+    
+    Stats::Scalar renameRepairCalls;
+    
     Stats::Scalar fpRenameLookups;
     /** Stat for total number of committed renaming mappings. */
     Stats::Scalar renameCommittedMaps;
@@ -494,6 +567,12 @@
     Stats::Scalar renamedTempSerializing;
     /** Number of instructions inserted into skid buffers. */
     Stats::Scalar renameSkidInsts;
+    
+    Stats::Distribution registerUsage;
+
+     Stats::Distribution rerunTimes;
+     
+     Stats::Vector2d statIssuedInstType;
 };
 
 #endif // __CPU_O3_RENAME_HH__
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rename_impl.hh
--- a/src/cpu/o3/rename_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rename_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -47,6 +47,7 @@
 #include "arch/registers.hh"
 #include "config/the_isa.hh"
 #include "cpu/o3/rename.hh"
+#include "cpu/o3/convertor.hh"
 #include "debug/Activity.hh"
 #include "debug/Rename.hh"
 #include "debug/O3PipeView.hh"
@@ -56,123 +57,149 @@
 
 template <class Impl>
 DefaultRename<Impl>::DefaultRename(O3CPU *_cpu, DerivO3CPUParams *params)
-    : cpu(_cpu),
-      iewToRenameDelay(params->iewToRenameDelay),
-      decodeToRenameDelay(params->decodeToRenameDelay),
-      commitToRenameDelay(params->commitToRenameDelay),
-      renameWidth(params->renameWidth),
-      commitWidth(params->commitWidth),
-      numThreads(params->numThreads),
-      maxPhysicalRegs(params->numPhysIntRegs + params->numPhysFloatRegs)
-{
+: cpu(_cpu),
+iewToRenameDelay(params->iewToRenameDelay),
+decodeToRenameDelay(params->decodeToRenameDelay),
+commitToRenameDelay(params->commitToRenameDelay),
+renameWidth(params->renameWidth),
+commitWidth(params->commitWidth),
+numThreads(params->numThreads),
+maxPhysicalRegs(params->numPhysIntRegs + params->numPhysFloatRegs),
+maxIntRegs(params->numPhysIntRegs),
+maxFloatRegs(params->numPhysFloatRegs) {
+    activeRerun=false;
     // @todo: Make into a parameter.
-    skidBufferMax = (2 * (decodeToRenameDelay * params->decodeWidth)) + renameWidth;
+    skidBufferMax = (3 * (decodeToRenameDelay * params->decodeWidth)) + renameWidth;
+    setupFaults(params);
+    callActive=0;
 }
 
 template <class Impl>
 std::string
-DefaultRename<Impl>::name() const
-{
+DefaultRename<Impl>::name() const {
     return cpu->name() + ".rename";
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::regStats()
-{
+DefaultRename<Impl>::regStats() {
     renameSquashCycles
-        .name(name() + ".SquashCycles")
-        .desc("Number of cycles rename is squashing")
-        .prereq(renameSquashCycles);
+            .name(name() + ".SquashCycles")
+            .desc("Number of cycles rename is squashing")
+            .prereq(renameSquashCycles);
     renameIdleCycles
-        .name(name() + ".IdleCycles")
-        .desc("Number of cycles rename is idle")
-        .prereq(renameIdleCycles);
+            .name(name() + ".IdleCycles")
+            .desc("Number of cycles rename is idle")
+            .prereq(renameIdleCycles);
     renameBlockCycles
-        .name(name() + ".BlockCycles")
-        .desc("Number of cycles rename is blocking")
-        .prereq(renameBlockCycles);
+            .name(name() + ".BlockCycles")
+            .desc("Number of cycles rename is blocking")
+            .prereq(renameBlockCycles);
     renameSerializeStallCycles
-        .name(name() + ".serializeStallCycles")
-        .desc("count of cycles rename stalled for serializing inst")
-        .flags(Stats::total);
+            .name(name() + ".serializeStallCycles")
+            .desc("count of cycles rename stalled for serializing inst")
+            .flags(Stats::total);
     renameRunCycles
-        .name(name() + ".RunCycles")
-        .desc("Number of cycles rename is running")
-        .prereq(renameIdleCycles);
+            .name(name() + ".RunCycles")
+            .desc("Number of cycles rename is running")
+            .prereq(renameIdleCycles);
     renameUnblockCycles
-        .name(name() + ".UnblockCycles")
-        .desc("Number of cycles rename is unblocking")
-        .prereq(renameUnblockCycles);
+            .name(name() + ".UnblockCycles")
+            .desc("Number of cycles rename is unblocking")
+            .prereq(renameUnblockCycles);
     renameRenamedInsts
-        .name(name() + ".RenamedInsts")
-        .desc("Number of instructions processed by rename")
-        .prereq(renameRenamedInsts);
+            .name(name() + ".RenamedInsts")
+            .desc("Number of instructions processed by rename")
+            .prereq(renameRenamedInsts);
     renameSquashedInsts
-        .name(name() + ".SquashedInsts")
-        .desc("Number of squashed instructions processed by rename")
-        .prereq(renameSquashedInsts);
+            .name(name() + ".SquashedInsts")
+            .desc("Number of squashed instructions processed by rename")
+            .prereq(renameSquashedInsts);
     renameROBFullEvents
-        .name(name() + ".ROBFullEvents")
-        .desc("Number of times rename has blocked due to ROB full")
-        .prereq(renameROBFullEvents);
+            .name(name() + ".ROBFullEvents")
+            .desc("Number of times rename has blocked due to ROB full")
+            .prereq(renameROBFullEvents);
     renameIQFullEvents
-        .name(name() + ".IQFullEvents")
-        .desc("Number of times rename has blocked due to IQ full")
-        .prereq(renameIQFullEvents);
+            .name(name() + ".IQFullEvents")
+            .desc("Number of times rename has blocked due to IQ full")
+            .prereq(renameIQFullEvents);
     renameLSQFullEvents
-        .name(name() + ".LSQFullEvents")
-        .desc("Number of times rename has blocked due to LSQ full")
-        .prereq(renameLSQFullEvents);
+            .name(name() + ".LSQFullEvents")
+            .desc("Number of times rename has blocked due to LSQ full")
+            .prereq(renameLSQFullEvents);
     renameFullRegistersEvents
-        .name(name() + ".FullRegisterEvents")
-        .desc("Number of times there has been no free registers")
-        .prereq(renameFullRegistersEvents);
+            .name(name() + ".FullRegisterEvents")
+            .desc("Number of times there has been no free registers")
+            .prereq(renameFullRegistersEvents);
     renameRenamedOperands
-        .name(name() + ".RenamedOperands")
-        .desc("Number of destination operands rename has renamed")
-        .prereq(renameRenamedOperands);
+            .name(name() + ".RenamedOperands")
+            .desc("Number of destination operands rename has renamed")
+            .prereq(renameRenamedOperands);
     renameRenameLookups
-        .name(name() + ".RenameLookups")
-        .desc("Number of register rename lookups that rename has made")
-        .prereq(renameRenameLookups);
+            .name(name() + ".RenameLookups")
+            .desc("Number of register rename lookups that rename has made")
+            .prereq(renameRenameLookups);
     renameCommittedMaps
-        .name(name() + ".CommittedMaps")
-        .desc("Number of HB maps that are committed")
-        .prereq(renameCommittedMaps);
+            .name(name() + ".CommittedMaps")
+            .desc("Number of HB maps that are committed")
+            .prereq(renameCommittedMaps);
     renameUndoneMaps
-        .name(name() + ".UndoneMaps")
-        .desc("Number of HB maps that are undone due to squashing")
-        .prereq(renameUndoneMaps);
+            .name(name() + ".UndoneMaps")
+            .desc("Number of HB maps that are undone due to squashing")
+            .prereq(renameUndoneMaps);
     renamedSerializing
-        .name(name() + ".serializingInsts")
-        .desc("count of serializing insts renamed")
-        .flags(Stats::total)
+            .name(name() + ".serializingInsts")
+            .desc("count of serializing insts renamed")
+            .flags(Stats::total)
+            ;
+    renamedTempSerializing
+            .name(name() + ".tempSerializingInsts")
+            .desc("count of temporary serializing insts renamed")
+            .flags(Stats::total)
+            ;
+    renameSkidInsts
+            .name(name() + ".skidInsts")
+            .desc("count of insts added to the skid buffer")
+            .flags(Stats::total)
+            ;
+    intRenameLookups
+            .name(name() + ".int_rename_lookups")
+            .desc("Number of integer rename lookups")
+            .prereq(intRenameLookups);
+    renameRepairCalls
+            .name(name() + ".repair_rename_relookups")
+            .desc("Number of repair calls from the rename phase")
+            .prereq(renameRepairCalls);
+    
+    fpRenameLookups
+            .name(name() + ".fp_rename_lookups")
+            .desc("Number of floating rename lookups")
+            .prereq(fpRenameLookups);
+    registerUsage     
+        .init(0,200,1)
+        .name(name() + ".register_spread")
+        .desc("Usage of each register")
+        .flags(Stats::pdf)
         ;
-    renamedTempSerializing
-        .name(name() + ".tempSerializingInsts")
-        .desc("count of temporary serializing insts renamed")
-        .flags(Stats::total)
+
+    rerunTimes     
+        .init(0,50,1)
+        .name(name() + ".repair_rerun_times")
+        .desc("Time for each rerun to complete")
+        .flags(Stats::pdf)
         ;
-    renameSkidInsts
-        .name(name() + ".skidInsts")
-        .desc("count of insts added to the skid buffer")
-        .flags(Stats::total)
+    statIssuedInstType
+        .init(numThreads,Enums::Num_OpClass)
+        .name(name() + ".FU_type")
+        .desc("Type of FU issued")
+        .flags(Stats::total | Stats::pdf | Stats::dist)
         ;
-    intRenameLookups
-        .name(name() + ".int_rename_lookups")
-        .desc("Number of integer rename lookups")
-        .prereq(intRenameLookups);
-    fpRenameLookups
-        .name(name() + ".fp_rename_lookups")
-        .desc("Number of floating rename lookups")
-        .prereq(fpRenameLookups);
+    statIssuedInstType.ysubnames(Enums::OpClassStrings);
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::setTimeBuffer(TimeBuffer<TimeStruct> *tb_ptr)
-{
+DefaultRename<Impl>::setTimeBuffer(TimeBuffer<TimeStruct> *tb_ptr) {
     timeBuffer = tb_ptr;
 
     // Setup wire to read information from time buffer, from IEW stage.
@@ -183,12 +210,12 @@
 
     // Setup wire to write information to previous stages.
     toDecode = timeBuffer->getWire(0);
+    fromDetector = timeBuffer->getWire(0);
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::setRenameQueue(TimeBuffer<RenameStruct> *rq_ptr)
-{
+DefaultRename<Impl>::setRenameQueue(TimeBuffer<RenameStruct> *rq_ptr) {
     renameQueue = rq_ptr;
 
     // Setup wire to write information to future stages.
@@ -197,25 +224,31 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::setDecodeQueue(TimeBuffer<DecodeStruct> *dq_ptr)
-{
+DefaultRename<Impl>::setDecodeQueue(TimeBuffer<DecodeStruct> *dq_ptr) {
     decodeQueue = dq_ptr;
 
     // Setup wire to get information from decode.
     fromDecode = decodeQueue->getWire(-decodeToRenameDelay);
 }
 
+template<class Impl>
+void
+DefaultRename<Impl>::setDetectorQueue(TimeBuffer<DetectorStruct> *dq_ptr) {
+    detectorQueue = dq_ptr;
+
+    // Create wire to write information to proper place in fetch queue.
+    toDetector = detectorQueue->getWire(1);
+}
+
 template <class Impl>
 void
-DefaultRename<Impl>::startupStage()
-{
+DefaultRename<Impl>::startupStage() {
     resetStage();
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::resetStage()
-{
+DefaultRename<Impl>::resetStage() {
     _status = Inactive;
 
     resumeSerialize = false;
@@ -230,6 +263,7 @@
         freeEntries[tid].robEntries = commit_ptr->numROBFreeEntries(tid);
         emptyROB[tid] = true;
 
+        stalls[tid].repair = false;
         stalls[tid].iew = false;
         stalls[tid].commit = false;
         serializeInst[tid] = NULL;
@@ -242,43 +276,37 @@
 
 template<class Impl>
 void
-DefaultRename<Impl>::setActiveThreads(list<ThreadID> *at_ptr)
-{
+DefaultRename<Impl>::setActiveThreads(list<ThreadID> *at_ptr) {
     activeThreads = at_ptr;
 }
 
-
 template <class Impl>
 void
-DefaultRename<Impl>::setRenameMap(RenameMap rm_ptr[])
-{
+DefaultRename<Impl>::setRenameMap(RenameMap rm_ptr[]) {
     for (ThreadID tid = 0; tid < numThreads; tid++)
         renameMap[tid] = &rm_ptr[tid];
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::setFreeList(FreeList *fl_ptr)
-{
+DefaultRename<Impl>::setFreeList(FreeList *fl_ptr) {
     freeList = fl_ptr;
 }
 
 template<class Impl>
 void
-DefaultRename<Impl>::setScoreboard(Scoreboard *_scoreboard)
-{
+DefaultRename<Impl>::setScoreboard(Scoreboard *_scoreboard) {
     scoreboard = _scoreboard;
 }
 
 template <class Impl>
 bool
-DefaultRename<Impl>::isDrained() const
-{
+DefaultRename<Impl>::isDrained() const {
     for (ThreadID tid = 0; tid < numThreads; tid++) {
         if (instsInProgress[tid] != 0 ||
-            !historyBuffer[tid].empty() ||
-            !skidBuffer[tid].empty() ||
-            !insts[tid].empty())
+                !historyBuffer[tid].empty() ||
+                !skidBuffer[tid].empty() ||
+                !insts[tid].empty())
             return false;
     }
     return true;
@@ -286,15 +314,13 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::takeOverFrom()
-{
+DefaultRename<Impl>::takeOverFrom() {
     resetStage();
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::drainSanityCheck() const
-{
+DefaultRename<Impl>::drainSanityCheck() const {
     for (ThreadID tid = 0; tid < numThreads; tid++) {
         assert(historyBuffer[tid].empty());
         assert(insts[tid].empty());
@@ -305,15 +331,45 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::squash(const InstSeqNum &squash_seq_num, ThreadID tid)
-{
-    DPRINTF(Rename, "[tid:%u]: Squashing instructions.\n",tid);
+DefaultRename<Impl>::rewindHistory(const InstSeqNum &squashSeqNum, ThreadID tid) {
+    typename std::list<RenameHistory>::iterator hb_it =
+            historyBuffer[tid].begin();
+
+    while (!historyBuffer[tid].empty() &&
+            (*hb_it).instSeqNum == squashSeqNum) {
+        assert(hb_it != historyBuffer[tid].end());
+
+        DPRINTF(Rename, "[tid:%u]: Removing history entry with sequence "
+                "number %i.\n", tid, (*hb_it).instSeqNum);
+
+        // Tell the rename map to set the architected register to the
+        // previous physical register that it was renamed to.
+        renameMap[tid]->setEntry(hb_it->archReg, hb_it->prevPhysReg);
+
+        // Put the renamed physical register back on the free list.
+        freeList->addReg(hb_it->newPhysReg);
+
+        // Be sure to mark its register as ready if it's a misc register.
+        if (hb_it->newPhysReg >= maxPhysicalRegs) {
+            scoreboard->setReg(hb_it->newPhysReg);
+        }
+
+        historyBuffer[tid].erase(hb_it++);
+
+        ++renameUndoneMaps;
+    }
+}
+
+template <class Impl>
+void
+DefaultRename<Impl>::squash(const InstSeqNum &squash_seq_num, ThreadID tid) {
+    DPRINTF(Rename, "[tid:%u]: Squashing instructions.\n", tid);
 
     // Clear the stall signal if rename was blocked or unblocking before.
     // If it still needs to block, the blocking should happen the next
     // cycle and there should be space to hold everything due to the squash.
     if (renameStatus[tid] == Blocked ||
-        renameStatus[tid] == Unblocking) {
+            renameStatus[tid] == Unblocking) {
         toDecode->renameUnblock[tid] = 1;
 
         resumeSerialize = false;
@@ -337,9 +393,10 @@
     // Squash any instructions from decode.
     unsigned squashCount = 0;
 
-    for (int i=0; i<fromDecode->size; i++) {
+    for (int i = 0; i < fromDecode->size; i++) {
         if (fromDecode->insts[i]->threadNumber == tid &&
-            fromDecode->insts[i]->seqNum > squash_seq_num) {
+                fromDecode->insts[i]->seqNum > squash_seq_num) {
+            DPRINTF(Rename, "[tid:%u]: Squashing instructions.\n", tid);
             fromDecode->insts[i]->setSquashed();
             wroteToTimeBuffer = true;
             squashCount++;
@@ -358,9 +415,195 @@
 }
 
 template <class Impl>
+bool
+DefaultRename<Impl>::checkHalt() {
+    bool retV = false;
+    switch (cpu->getHaltStatus()) {
+        case(fetchHalt):
+            retV = false;
+            break;
+        case(renameHalt):
+            retV = true;
+            break;
+        case(commitHalt):
+            retV = false;
+            break;
+        case (noHalt):
+            retV = false;
+            break;
+        default:break;
+    }
+    return retV;
+}
+
+template <class Impl>
 void
-DefaultRename<Impl>::tick()
-{
+DefaultRename<Impl>::setupPair(int num, bool** in, int** f) {
+    bool *indic = new bool[num];
+    *in=indic;
+
+    int* faults = new int[num];
+    *f=faults;
+    for (int i = 0; i < num; i++) {
+        indic[i] = false;
+        faults[i] = 0;
+    }
+}
+
+template <class Impl>
+void
+DefaultRename<Impl>::setupFaults(DerivO3CPUParams *params) {
+    setupPair(TheISA::TotalNumRegs, &fmap.archRegs, &fmap.farchRegs);
+    fmap.aNum = TheISA::TotalNumRegs;
+    if (params->eRM) {
+        cout<<"Error Rename Map"<<endl;
+        errorMap(params->eRMValue, fmap.archRegs, fmap.farchRegs, TheISA::TotalNumRegs, 8);
+    }
+    setupPair(params->numPhysIntRegs + params->numPhysFloatRegs, &fmap.physRegs, &fmap.fphysRegs);
+    fmap.pNum = params->numPhysIntRegs + params->numPhysFloatRegs;
+    if (params->ePR) {
+                cout<<"Error Physical Register"<<endl;
+        errorMap(params->ePRValue, fmap.physRegs, fmap.fphysRegs, params->numPhysIntRegs + params->numPhysFloatRegs, 8);
+    }
+    if (params->eSB) {
+        cout<<"Error Scoreboard"<<endl;
+        errorMap(params->eSBValue, fmap.physRegs, fmap.fphysRegs, params->numPhysIntRegs + params->numPhysFloatRegs, 8);
+    }
+    setupPair(params->numIQEntries, &fmap.isQue, &fmap.fisQue);
+    fmap.isQNum = params->numIQEntries;
+    if (params->eIQ) {
+                cout<<"Error Instruction Queue"<<endl;
+        errorMap(params->eIQValue, fmap.isQue, fmap.fisQue, params->numIQEntries, 32);
+    }
+    setupPair(params->LQEntries, &fmap.lq, &fmap.flq);
+    fmap.lqNum = params->LQEntries;
+    if (params->eLQ) {
+                cout<<"Error Load Queue"<<endl;
+        errorMap(params->eLQValue, fmap.lq, fmap.flq, params->LQEntries, 32);
+    }
+    setupPair(params->SQEntries, &fmap.sq, &fmap.fsq);
+    fmap.sqNum = params->SQEntries;
+    if (params->eSQ) {
+                cout<<"Error Store Queue"<<endl;
+        errorMap(params->eSQValue, fmap.sq, fmap.fsq, params->SQEntries, 32);
+    }
+    setupPair(params->numROBEntries, &fmap.rob, &fmap.frob);
+    fmap.robNum = params->numROBEntries;
+    if (params->eROB) {
+                cout<<"Error ROB"<<endl;
+                cout<<params->eROBValue<<endl;
+        errorMap(params->eROBValue, fmap.rob, fmap.frob, params->numROBEntries, 32);
+    }
+}
+
+template <class Impl>
+bool
+DefaultRename<Impl>::checkFaults(FaultStatus fs, int index, int value) {
+    bool retval=false;
+    switch (fs) {
+        case eArch:
+            if (index < fmap.aNum) {
+                if (fmap.archRegs[index]){
+                    return fmap.farchRegs[index] & value;
+                }else{
+                    return false;
+                }
+            } else
+                return false;
+            break;
+        case ePhys:
+            if (index < fmap.pNum) {
+                if (fmap.physRegs[index]){
+                    return fmap.fphysRegs[index] & value;
+                }
+                else
+                    return false;
+            } else
+                return false;
+            break;
+        case eIsQ:
+            if (iqCounter < fmap.isQNum && fmap.isQue[iqCounter]) {
+                retval=fmap.fisQue[iqCounter] & value;
+
+//                return fmap.fisQue[iqCounter] & value;
+            } else{
+                retval=false;
+//                return false;
+            }
+            iqCounter++;
+            iqCounter %= fmap.isQNum;
+            return retval;
+            break;
+        case eLQ:
+            if (lqCounter < fmap.lqNum && fmap.lq[lqCounter]) {
+                retval=fmap.flq[lqCounter] & value;
+
+//                return fmap.flq[lqCounter] & value;
+            } else{
+                retval=false;
+//                return false;
+            }
+            lqCounter++;
+            lqCounter %= fmap.lqNum;
+            return retval;
+            break;
+        case eSQ:
+            if (sqCounter < fmap.sqNum && fmap.sq[sqCounter]) {
+                retval= fmap.fsq[sqCounter] & value;
+            } else
+                return false;
+            sqCounter++;
+            sqCounter %= fmap.sqNum;
+            return retval;
+            break;
+        case eROB:
+            if (robCounter < fmap.robNum && fmap.rob[robCounter]) {
+                retval=fmap.frob[robCounter] & value;
+//                return fmap.frob[robCounter] & value;
+            } else{
+                retval=false;
+//                return false;
+            }
+            robCounter++;
+            robCounter %= fmap.robNum;
+            return retval;
+            break;
+        default:
+            return false;
+    }
+    return false;
+}
+
+template <class Impl>
+void
+DefaultRename<Impl>::checkInstErrors(DynInstPtr& inst) {
+    unsigned num_dest_regs = inst->numDestRegs();
+    for (int dest_idx = 0; dest_idx < num_dest_regs; dest_idx++) {
+        inst->updateError(checkFaults(eArch, inst->flattenedDestRegIdx(dest_idx), 2));
+        if (checkFaults(eArch, inst->flattenedDestRegIdx(dest_idx), 2)) {
+           if(rand()%2)
+           {
+           //    inst->resetError();
+           }
+        }
+    }
+    for (int dest_idx = 0; dest_idx < num_dest_regs; dest_idx++) {
+        inst->updateError(checkFaults(ePhys, inst->renamedDestRegIdx(dest_idx), 2));
+    }
+    inst->updateError(checkFaults(eIsQ, 0, 2));
+    if (inst->isLoad()) {
+        inst->updateError(checkFaults(eLQ, 0, 2));
+    }
+    if (inst->isStore()) {
+        inst->updateError(checkFaults(eSQ, 0, 2));
+    }
+    inst->updateError(checkFaults(eROB, 0, 2));
+}
+
+template <class Impl>
+void
+DefaultRename<Impl>::tick() {
+
     wroteToTimeBuffer = false;
 
     blockThisCycle = false;
@@ -368,12 +611,33 @@
     bool status_change = false;
 
     toIEWIndex = 0;
+    list<ThreadID>::iterator threads = activeThreads->begin();
+    list<ThreadID>::iterator end = activeThreads->end();
+    while (threads != end) {
+        
+        ThreadID tid = *threads++;
+        DPRINTF(Rename,"Rename State for thread %d is %s\n",tid,getModeString(currentM[tid]));
+        switch(checkRenameState(tid)){
+            case squashM:
+                setBlocked(tid);
+                break;
+            case haltM:
+                setBlocked(tid);
+                break;
 
+            case regularM:
+                if(stalls[tid].repair)
+                        unSetBlocked(tid);
+                break;
+            default:
+                if(stalls[tid].repair)
+                        unSetBlocked(tid);
+                break;                
+        }
+    }
     sortInsts();
 
-    list<ThreadID>::iterator threads = activeThreads->begin();
-    list<ThreadID>::iterator end = activeThreads->end();
-
+    threads = activeThreads->begin();
     // Check stall and squash signals.
     while (threads != end) {
         ThreadID tid = *threads++;
@@ -401,11 +665,11 @@
 
         // If we committed this cycle then doneSeqNum will be > 0
         if (fromCommit->commitInfo[tid].doneSeqNum != 0 &&
-            !fromCommit->commitInfo[tid].squash &&
-            renameStatus[tid] != Squashing) {
+                !fromCommit->commitInfo[tid].squash &&
+                renameStatus[tid] != Squashing) {
 
             removeFromHistory(fromCommit->commitInfo[tid].doneSeqNum,
-                                  tid);
+                    tid);
         }
     }
 
@@ -413,22 +677,33 @@
     for (ThreadID tid = 0; tid < numThreads; tid++) {
         instsInProgress[tid] -= fromIEW->iewInfo[tid].dispatched;
 
-        assert(instsInProgress[tid] >=0);
+        assert(instsInProgress[tid] >= 0);
     }
 
 }
 
 template<class Impl>
 void
-DefaultRename<Impl>::rename(bool &status_change, ThreadID tid)
-{
+DefaultRename<Impl>::setRenameState(stageModes_t fm, ThreadID tid) {
+    currentM[tid] = fm;
+}
+
+template<class Impl>
+stageModes_t
+DefaultRename<Impl>::checkRenameState(ThreadID tid) {
+    return currentM[tid];
+}
+
+template<class Impl>
+void
+DefaultRename<Impl>::rename(bool &status_change, ThreadID tid) {
     // If status is Running or idle,
     //     call renameInsts()
     // If status is Unblocking,
     //     buffer any instructions coming from decode
     //     continue trying to empty skid buffer
     //     check if stall conditions have passed
-
+//    static bool activeRerun=false;
     if (renameStatus[tid] == Blocked) {
         ++renameBlockCycles;
     } else if (renameStatus[tid] == Squashing) {
@@ -452,7 +727,8 @@
     }
 
     if (renameStatus[tid] == Running ||
-        renameStatus[tid] == Idle) {
+            renameStatus[tid] == Idle) {
+        callActive=0;
         DPRINTF(Rename, "[tid:%u]: Not blocked, so attempting to run "
                 "stage.\n", tid);
 
@@ -469,17 +745,21 @@
         // If we switched over to blocking, then there's a potential for
         // an overall status change.
         status_change = unblock(tid) || status_change || blockThisCycle;
+    }else{
+        if(activeRerun){
+            callActive++;            
+        }        
     }
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::renameInsts(ThreadID tid)
-{
+DefaultRename<Impl>::renameInsts(ThreadID tid) {
+
     // Instructions can be either in the skid buffer or the queue of
     // instructions coming from decode, depending on the status.
     int insts_available = renameStatus[tid] == Unblocking ?
-        skidBuffer[tid].size() : insts[tid].size();
+            skidBuffer[tid].size() : insts[tid].size();
 
     // Check the decode queue to see if instructions are available.
     // If there are no available instructions to rename, then do nothing.
@@ -500,7 +780,7 @@
     // Will have to do a different calculation for the number of free
     // entries.
     int free_rob_entries = calcFreeROBEntries(tid);
-    int free_iq_entries  = calcFreeIQEntries(tid);
+    int free_iq_entries = calcFreeIQEntries(tid);
     int free_lsq_entries = calcFreeLSQEntries(tid);
     int min_free_entries = free_rob_entries;
 
@@ -549,7 +829,7 @@
     }
 
     InstQueue &insts_to_rename = renameStatus[tid] == Unblocking ?
-        skidBuffer[tid] : insts[tid];
+            skidBuffer[tid] : insts[tid];
 
     DPRINTF(Rename, "[tid:%u]: %i available instructions to "
             "send iew.\n", tid, insts_available);
@@ -570,7 +850,7 @@
 
     int renamed_insts = 0;
 
-    while (insts_available > 0 &&  toIEWIndex < renameWidth) {
+    while (insts_available > 0 && toIEWIndex < renameWidth) {
         DPRINTF(Rename, "[tid:%u]: Sending instructions to IEW.\n", tid);
 
         assert(!insts_to_rename.empty());
@@ -580,7 +860,7 @@
         insts_to_rename.pop_front();
 
         if (renameStatus[tid] == Unblocking) {
-            DPRINTF(Rename,"[tid:%u]: Removing [sn:%lli] PC:%s from rename "
+            DPRINTF(Rename, "[tid:%u]: Removing [sn:%lli] PC:%s from rename "
                     "skidBuffer\n", tid, inst->seqNum, inst->pcState());
         }
 
@@ -623,7 +903,7 @@
         // out-of-order operations of either of those classes of
         // instructions.
         if ((inst->isIprAccess() || inst->isSerializeBefore()) &&
-            !inst->isSerializeHandled()) {
+                !inst->isSerializeHandled()) {
             DPRINTF(Rename, "Serialize before instruction encountered.\n");
 
             if (!inst->isTempSerializeBefore()) {
@@ -643,7 +923,7 @@
 
             break;
         } else if ((inst->isStoreConditional() || inst->isSerializeAfter()) &&
-                   !inst->isSerializeHandled()) {
+                !inst->isSerializeHandled()) {
             DPRINTF(Rename, "Serialize after instruction encountered.\n");
 
             renamedSerializing++;
@@ -657,6 +937,37 @@
 
         renameDestRegs(inst, inst->threadNumber);
 
+        checkInstErrors(inst);
+
+        if (inst->erronous()) {
+            //if(rand()%2){
+            //    inst->resetError();    static int callActive=0;
+                 //static bool active=false;
+            //}else
+            {
+                activeRerun=true;
+                renameRepairCalls++;
+                statIssuedInstType[tid][inst->opClass()]++;
+                DPRINTF(Rename,"[tid:%u]: Blocking instruction [sn:%lli] with "
+                        "PC %s.\n", tid, inst->seqNum, inst->pcState());
+                toDetector->insts[ toDetector->instrSize] = inst;
+                toDetector->tids[ toDetector->instrSize] = tid;
+                toDetector->instrSize++;
+                setRenameState(haltM, tid);
+                blockThisCycle = true;
+                insts_to_rename.push_front(inst);
+                rewindHistory(inst->seqNum, inst->threadNumber);
+                inst->resetError();
+                inst->clearCanIssue();
+                inst->resetRenamedRegisterCount();
+                break;
+            }
+        }
+        if(activeRerun){
+            rerunTimes.sample(callActive);
+        }
+        activeRerun=false;
+
         ++renamed_insts;
 
 
@@ -693,8 +1004,7 @@
 
 template<class Impl>
 void
-DefaultRename<Impl>::skidInsert(ThreadID tid)
-{
+DefaultRename<Impl>::skidInsert(ThreadID tid) {
     DynInstPtr inst = NULL;
 
     while (!insts[tid].empty()) {
@@ -712,12 +1022,10 @@
         skidBuffer[tid].push_back(inst);
     }
 
-    if (skidBuffer[tid].size() > skidBufferMax)
-    {
+    if (skidBuffer[tid].size() > skidBufferMax) {
         typename InstQueue::iterator it;
         warn("Skidbuffer contents:\n");
-        for(it = skidBuffer[tid].begin(); it != skidBuffer[tid].end(); it++)
-        {
+        for (it = skidBuffer[tid].begin(); it != skidBuffer[tid].end(); it++) {
             warn("[tid:%u]: %s [sn:%i].\n", tid,
                     (*it)->staticInst->disassemble(inst->instAddr()),
                     (*it)->seqNum);
@@ -728,9 +1036,9 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::sortInsts()
-{
+DefaultRename<Impl>::sortInsts() {
     int insts_from_decode = fromDecode->size;
+    DPRINTF(Rename, "Receiving from Decode %d \n", fromDecode->size);
     for (int i = 0; i < insts_from_decode; ++i) {
         DynInstPtr inst = fromDecode->insts[i];
         insts[inst->threadNumber].push_back(inst);
@@ -744,8 +1052,7 @@
 
 template<class Impl>
 bool
-DefaultRename<Impl>::skidsEmpty()
-{
+DefaultRename<Impl>::skidsEmpty() {
     list<ThreadID>::iterator threads = activeThreads->begin();
     list<ThreadID>::iterator end = activeThreads->end();
 
@@ -761,8 +1068,7 @@
 
 template<class Impl>
 void
-DefaultRename<Impl>::updateStatus()
-{
+DefaultRename<Impl>::updateStatus() {
     bool any_unblocking = false;
 
     list<ThreadID>::iterator threads = activeThreads->begin();
@@ -800,8 +1106,7 @@
 
 template <class Impl>
 bool
-DefaultRename<Impl>::block(ThreadID tid)
-{
+DefaultRename<Impl>::block(ThreadID tid) {
     DPRINTF(Rename, "[tid:%u]: Blocking.\n", tid);
 
     // Add the current inputs onto the skid buffer, so they can be
@@ -811,10 +1116,12 @@
     // Only signal backwards to block if the previous stages do not think
     // rename is already blocked.
     if (renameStatus[tid] != Blocked) {
+        DPRINTF(Rename, "[tid:%u]: Blocking.\n", tid);
         // If resumeUnblocking is set, we unblocked during the squash,
         // but now we're have unblocking status. We need to tell earlier
         // stages to block.
         if (resumeUnblocking || renameStatus[tid] != Unblocking) {
+    DPRINTF(Rename, "[tid:%u]: Blocking.\n", tid);
             toDecode->renameBlock[tid] = true;
             toDecode->renameUnblock[tid] = false;
             wroteToTimeBuffer = true;
@@ -834,8 +1141,7 @@
 
 template <class Impl>
 bool
-DefaultRename<Impl>::unblock(ThreadID tid)
-{
+DefaultRename<Impl>::unblock(ThreadID tid) {
     DPRINTF(Rename, "[tid:%u]: Trying to unblock.\n", tid);
 
     // Rename is done unblocking if the skid buffer is empty.
@@ -855,11 +1161,11 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::doSquash(const InstSeqNum &squashed_seq_num, ThreadID tid)
-{
+DefaultRename<Impl>::doSquash(const InstSeqNum &squashed_seq_num, ThreadID tid) {
     typename std::list<RenameHistory>::iterator hb_it =
-        historyBuffer[tid].begin();
+            historyBuffer[tid].begin();
 
+    stalls[tid].repair = false;
     // After a syscall squashes everything, the history buffer may be empty
     // but the ROB may still be squashing instructions.
     if (historyBuffer[tid].empty()) {
@@ -869,7 +1175,7 @@
     // Go through the most recent instructions, undoing the mappings
     // they did and freeing up the registers.
     while (!historyBuffer[tid].empty() &&
-           (*hb_it).instSeqNum > squashed_seq_num) {
+            (*hb_it).instSeqNum > squashed_seq_num) {
         assert(hb_it != historyBuffer[tid].end());
 
         DPRINTF(Rename, "[tid:%u]: Removing history entry with sequence "
@@ -895,14 +1201,13 @@
 
 template<class Impl>
 void
-DefaultRename<Impl>::removeFromHistory(InstSeqNum inst_seq_num, ThreadID tid)
-{
+DefaultRename<Impl>::removeFromHistory(InstSeqNum inst_seq_num, ThreadID tid) {
     DPRINTF(Rename, "[tid:%u]: Removing a committed instruction from the "
             "history buffer %u (size=%i), until [sn:%lli].\n",
             tid, tid, historyBuffer[tid].size(), inst_seq_num);
 
     typename std::list<RenameHistory>::iterator hb_it =
-        historyBuffer[tid].end();
+            historyBuffer[tid].end();
 
     --hb_it;
 
@@ -920,8 +1225,8 @@
     // rename histories if they did not have destination registers that were
     // renamed.
     while (!historyBuffer[tid].empty() &&
-           hb_it != historyBuffer[tid].end() &&
-           (*hb_it).instSeqNum <= inst_seq_num) {
+            hb_it != historyBuffer[tid].end() &&
+            (*hb_it).instSeqNum <= inst_seq_num) {
 
         DPRINTF(Rename, "[tid:%u]: Freeing up older rename of reg %i, "
                 "[sn:%lli].\n",
@@ -936,8 +1241,7 @@
 
 template <class Impl>
 inline void
-DefaultRename<Impl>::renameSrcRegs(DynInstPtr &inst, ThreadID tid)
-{
+DefaultRename<Impl>::renameSrcRegs(DynInstPtr &inst, ThreadID tid) {
     assert(renameMap[tid] != 0);
 
     unsigned num_src_regs = inst->numSrcRegs();
@@ -950,17 +1254,17 @@
         RegIndex flat_src_reg = src_reg;
         if (src_reg < TheISA::FP_Base_DepTag) {
             flat_src_reg = inst->tcBase()->flattenIntIndex(src_reg);
-            DPRINTF(Rename, "Flattening index %d to %d.\n",
-                    (int)src_reg, (int)flat_src_reg);
+            DPRINTF(Rename, "[tid:%u]: [sn:%i] Flattening index %d to %d.\n",
+                    tid, inst->seqNum, (int) src_reg, (int) flat_src_reg);
         } else if (src_reg < TheISA::Ctrl_Base_DepTag) {
             src_reg = src_reg - TheISA::FP_Base_DepTag;
             flat_src_reg = inst->tcBase()->flattenFloatIndex(src_reg);
-            DPRINTF(Rename, "Flattening index %d to %d.\n",
-                    (int)src_reg, (int)flat_src_reg);
+            DPRINTF(Rename, "[tid:%u]: [sn:%i]  Flattening index %d to %d.\n",
+                    tid, inst->seqNum, (int) src_reg, (int) flat_src_reg);
             flat_src_reg += TheISA::NumIntRegs;
         } else if (src_reg < TheISA::Max_DepTag) {
             flat_src_reg = src_reg - TheISA::Ctrl_Base_DepTag +
-                           TheISA::NumFloatRegs + TheISA::NumIntRegs;
+                    TheISA::NumFloatRegs + TheISA::NumIntRegs;
             DPRINTF(Rename, "Adjusting reg index from %d to %d.\n",
                     src_reg, flat_src_reg);
         } else {
@@ -971,9 +1275,9 @@
         // been renamed to, and set the sources to those registers.
         PhysRegIndex renamed_reg = renameMap[tid]->lookup(flat_src_reg);
 
-        DPRINTF(Rename, "[tid:%u]: Looking up arch reg %i, got "
-                "physical reg %i.\n", tid, (int)flat_src_reg,
-                (int)renamed_reg);
+        DPRINTF(Rename, "[tid:%u]: [sn:%i] Looking up arch reg %i, got "
+                "physical reg %i.\n", tid, inst->seqNum, (int) flat_src_reg,
+                (int) renamed_reg);
 
         inst->renameSrcReg(src_idx, renamed_reg);
 
@@ -995,8 +1299,7 @@
 
 template <class Impl>
 inline void
-DefaultRename<Impl>::renameDestRegs(DynInstPtr &inst, ThreadID tid)
-{
+DefaultRename<Impl>::renameDestRegs(DynInstPtr &inst, ThreadID tid) {
     typename RenameMap::RenameInfo rename_result;
 
     unsigned num_dest_regs = inst->numDestRegs();
@@ -1004,23 +1307,24 @@
     // Rename the destination registers.
     for (int dest_idx = 0; dest_idx < num_dest_regs; dest_idx++) {
         RegIndex dest_reg = inst->destRegIdx(dest_idx);
+        registerUsage.sample(dest_reg);
         RegIndex flat_dest_reg = dest_reg;
         if (dest_reg < TheISA::FP_Base_DepTag) {
             // Integer registers are flattened.
             flat_dest_reg = inst->tcBase()->flattenIntIndex(dest_reg);
             DPRINTF(Rename, "Flattening index %d to %d.\n",
-                    (int)dest_reg, (int)flat_dest_reg);
+                    (int) dest_reg, (int) flat_dest_reg);
         } else if (dest_reg < TheISA::Ctrl_Base_DepTag) {
             dest_reg = dest_reg - TheISA::FP_Base_DepTag;
             flat_dest_reg = inst->tcBase()->flattenFloatIndex(dest_reg);
             DPRINTF(Rename, "Flattening index %d to %d.\n",
-                    (int)dest_reg, (int)flat_dest_reg);
+                    (int) dest_reg, (int) flat_dest_reg);
             flat_dest_reg += TheISA::NumIntRegs;
         } else if (dest_reg < TheISA::Max_DepTag) {
             // Floating point and Miscellaneous registers need their indexes
             // adjusted to account for the expanded number of flattened int regs.
             flat_dest_reg = dest_reg - TheISA::Ctrl_Base_DepTag +
-                            TheISA::NumIntRegs + TheISA::NumFloatRegs;
+                    TheISA::NumIntRegs + TheISA::NumFloatRegs;
             DPRINTF(Rename, "Adjusting reg index from %d to %d.\n",
                     dest_reg, flat_dest_reg);
         } else {
@@ -1033,23 +1337,24 @@
         // renamed to.
         rename_result = renameMap[tid]->rename(flat_dest_reg);
 
+
         //Mark Scoreboard entry as not ready
         if (dest_reg < TheISA::Ctrl_Base_DepTag)
             scoreboard->unsetReg(rename_result.first);
 
-        DPRINTF(Rename, "[tid:%u]: Renaming arch reg %i to physical "
-                "reg %i.\n", tid, (int)flat_dest_reg,
-                (int)rename_result.first);
+        DPRINTF(Rename, "[tid:%u]: [sn:%i] Renaming arch reg %i to physical "
+                "reg %i from %i.\n", tid, inst->seqNum, (int) flat_dest_reg,
+                (int) rename_result.first, (int)rename_result.second);
 
         // Record the rename information so that a history can be kept.
         RenameHistory hb_entry(inst->seqNum, flat_dest_reg,
-                               rename_result.first,
-                               rename_result.second);
+                rename_result.first,
+                rename_result.second);
 
         historyBuffer[tid].push_front(hb_entry);
 
         DPRINTF(Rename, "[tid:%u]: Adding instruction to history buffer "
-                "(size=%i), [sn:%lli].\n",tid,
+                "(size=%i), [sn:%lli].\n", tid,
                 historyBuffer[tid].size(),
                 (*historyBuffer[tid].begin()).instSeqNum);
 
@@ -1059,8 +1364,8 @@
         // register that the same logical register was renamed to
         // (rename_result.second).
         inst->renameDestReg(dest_idx,
-                            rename_result.first,
-                            rename_result.second);
+                rename_result.first,
+                rename_result.second);
 
         ++renameRenamedOperands;
     }
@@ -1068,10 +1373,9 @@
 
 template <class Impl>
 inline int
-DefaultRename<Impl>::calcFreeROBEntries(ThreadID tid)
-{
+DefaultRename<Impl>::calcFreeROBEntries(ThreadID tid) {
     int num_free = freeEntries[tid].robEntries -
-                  (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
+            (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
 
     //DPRINTF(Rename,"[tid:%i]: %i rob free\n",tid,num_free);
 
@@ -1080,10 +1384,9 @@
 
 template <class Impl>
 inline int
-DefaultRename<Impl>::calcFreeIQEntries(ThreadID tid)
-{
+DefaultRename<Impl>::calcFreeIQEntries(ThreadID tid) {
     int num_free = freeEntries[tid].iqEntries -
-                  (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
+            (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatched);
 
     //DPRINTF(Rename,"[tid:%i]: %i iq free\n",tid,num_free);
 
@@ -1092,10 +1395,9 @@
 
 template <class Impl>
 inline int
-DefaultRename<Impl>::calcFreeLSQEntries(ThreadID tid)
-{
+DefaultRename<Impl>::calcFreeLSQEntries(ThreadID tid) {
     int num_free = freeEntries[tid].lsqEntries -
-                  (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatchedToLSQ);
+            (instsInProgress[tid] - fromIEW->iewInfo[tid].dispatchedToLSQ);
 
     //DPRINTF(Rename,"[tid:%i]: %i lsq free\n",tid,num_free);
 
@@ -1104,11 +1406,10 @@
 
 template <class Impl>
 unsigned
-DefaultRename<Impl>::validInsts()
-{
+DefaultRename<Impl>::validInsts() {
     unsigned inst_count = 0;
 
-    for (int i=0; i<fromDecode->size; i++) {
+    for (int i = 0; i < fromDecode->size; i++) {
         if (!fromDecode->insts[i]->isSquashed())
             inst_count++;
     }
@@ -1118,8 +1419,7 @@
 
 template <class Impl>
 void
-DefaultRename<Impl>::readStallSignals(ThreadID tid)
-{
+DefaultRename<Impl>::readStallSignals(ThreadID tid) {
     if (fromIEW->iewBlock[tid]) {
         stalls[tid].iew = true;
     }
@@ -1141,43 +1441,45 @@
 
 template <class Impl>
 bool
-DefaultRename<Impl>::checkStall(ThreadID tid)
-{
+DefaultRename<Impl>::checkStall(ThreadID tid) {
     bool ret_val = false;
 
     if (stalls[tid].iew) {
-        DPRINTF(Rename,"[tid:%i]: Stall from IEW stage detected.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall from IEW stage detected.\n", tid);
         ret_val = true;
     } else if (stalls[tid].commit) {
-        DPRINTF(Rename,"[tid:%i]: Stall from Commit stage detected.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall from Commit stage detected.\n", tid);
         ret_val = true;
     } else if (calcFreeROBEntries(tid) <= 0) {
-        DPRINTF(Rename,"[tid:%i]: Stall: ROB has 0 free entries.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall: ROB has 0 free entries.\n", tid);
         ret_val = true;
     } else if (calcFreeIQEntries(tid) <= 0) {
-        DPRINTF(Rename,"[tid:%i]: Stall: IQ has 0 free entries.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall: IQ has 0 free entries.\n", tid);
         ret_val = true;
     } else if (calcFreeLSQEntries(tid) <= 0) {
-        DPRINTF(Rename,"[tid:%i]: Stall: LSQ has 0 free entries.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall: LSQ has 0 free entries.\n", tid);
         ret_val = true;
     } else if (renameMap[tid]->numFreeEntries() <= 0) {
-        DPRINTF(Rename,"[tid:%i]: Stall: RenameMap has 0 free entries.\n", tid);
+        DPRINTF(Rename, "[tid:%i]: Stall: RenameMap has 0 free entries.\n", tid);
         ret_val = true;
     } else if (renameStatus[tid] == SerializeStall &&
-               (!emptyROB[tid] || instsInProgress[tid])) {
-        DPRINTF(Rename,"[tid:%i]: Stall: Serialize stall and ROB is not "
+            (!emptyROB[tid] || instsInProgress[tid])) {
+        DPRINTF(Rename, "[tid:%i]: Stall: Serialize stall and ROB is not "
                 "empty.\n",
                 tid);
         ret_val = true;
+    } else if (stalls[tid].repair) {
+        DPRINTF(Rename, "[tid:%i]: Stall due to repair detected.\n", tid);
+        ret_val = true;
     }
 
+
     return ret_val;
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::readFreeEntries(ThreadID tid)
-{
+DefaultRename<Impl>::readFreeEntries(ThreadID tid) {
     if (fromIEW->iewInfo[tid].usedIQ)
         freeEntries[tid].iqEntries = fromIEW->iewInfo[tid].freeIQEntries;
 
@@ -1186,7 +1488,7 @@
 
     if (fromCommit->commitInfo[tid].usedROB) {
         freeEntries[tid].robEntries =
-            fromCommit->commitInfo[tid].freeROBEntries;
+                fromCommit->commitInfo[tid].freeROBEntries;
         emptyROB[tid] = fromCommit->commitInfo[tid].emptyROB;
     }
 
@@ -1202,8 +1504,7 @@
 
 template <class Impl>
 bool
-DefaultRename<Impl>::checkSignalsAndUpdate(ThreadID tid)
-{
+DefaultRename<Impl>::checkSignalsAndUpdate(ThreadID tid) {
     // Check if there's a squash signal, squash if there is
     // Check stall signals, block if necessary.
     // If status was blocked
@@ -1233,11 +1534,25 @@
 
         return true;
     }
+    if(!fromDetector->detectorInfo.working){
+        unSetBlocked(tid);
+
+        stalls[tid].repair=false;        
+        DPRINTF(Rename, "[tid:%u]: Detector is done working.\n",
+                tid);
+
+    }
+    else{
+        setBlocked(tid);
+        stalls[tid].repair=true;
+        DPRINTF(Rename, "[tid:%u]: Detector is working.\n", tid);
+    }
 
     if (checkStall(tid)) {
         return block(tid);
     }
 
+    
     if (renameStatus[tid] == Blocked) {
         DPRINTF(Rename, "[tid:%u]: Done blocking, switching to unblocking.\n",
                 tid);
@@ -1308,10 +1623,27 @@
     return false;
 }
 
+template <class Impl>
+void
+DefaultRename<Impl>::setBlocked(ThreadID tid) {
+    DPRINTF(Rename, "Setting Stall due to Repair \n");
+    stalls[tid].repair = true;
+//    renameStatus[tid] = Blocked;
+}
+
+template <class Impl>
+void
+DefaultRename<Impl>::unSetBlocked(ThreadID tid) {
+    if (stalls[tid].repair) {
+        setRenameState(regularM, tid);
+        stalls[tid].repair = false;
+//        fetchStatus[tid] = Running;
+    }
+}
+
 template<class Impl>
 void
-DefaultRename<Impl>::serializeAfter(InstQueue &inst_list, ThreadID tid)
-{
+DefaultRename<Impl>::serializeAfter(InstQueue &inst_list, ThreadID tid) {
     if (inst_list.empty()) {
         // Mark a bit to say that I must serialize on the next instruction.
         serializeOnNextInst[tid] = true;
@@ -1324,28 +1656,26 @@
 
 template <class Impl>
 inline void
-DefaultRename<Impl>::incrFullStat(const FullSource &source)
-{
+DefaultRename<Impl>::incrFullStat(const FullSource &source) {
     switch (source) {
-      case ROB:
-        ++renameROBFullEvents;
-        break;
-      case IQ:
-        ++renameIQFullEvents;
-        break;
-      case LSQ:
-        ++renameLSQFullEvents;
-        break;
-      default:
-        panic("Rename full stall stat should be incremented for a reason!");
-        break;
+        case ROB:
+            ++renameROBFullEvents;
+            break;
+        case IQ:
+            ++renameIQFullEvents;
+            break;
+        case LSQ:
+            ++renameLSQFullEvents;
+            break;
+        default:
+            panic("Rename full stall stat should be incremented for a reason!");
+            break;
     }
 }
 
 template <class Impl>
 void
-DefaultRename<Impl>::dumpHistory()
-{
+DefaultRename<Impl>::dumpHistory() {
     typename std::list<RenameHistory>::iterator buf_it;
 
     for (ThreadID tid = 0; tid < numThreads; tid++) {
@@ -1354,8 +1684,8 @@
 
         while (buf_it != historyBuffer[tid].end()) {
             cprintf("Seq num: %i\nArch reg: %i New phys reg: %i Old phys "
-                    "reg: %i\n", (*buf_it).instSeqNum, (int)(*buf_it).archReg,
-                    (int)(*buf_it).newPhysReg, (int)(*buf_it).prevPhysReg);
+                    "reg: %i\n", (*buf_it).instSeqNum, (int) (*buf_it).archReg,
+                    (int) (*buf_it).newPhysReg, (int) (*buf_it).prevPhysReg);
 
             buf_it++;
         }
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rename_map.cc
--- a/src/cpu/o3/rename_map.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rename_map.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -32,6 +32,7 @@
 
 #include "cpu/o3/rename_map.hh"
 #include "debug/Rename.hh"
+#include "debug/Squasher.hh"
 
 using namespace std;
 
@@ -75,6 +76,8 @@
     intZeroReg = _intZeroReg;
     floatZeroReg = _floatZeroReg;
 
+
+
     DPRINTF(Rename, "Creating rename map %i.  Phys: %i / %i, Float: "
             "%i / %i.\n", id, numLogicalIntRegs, numPhysicalIntRegs,
             numLogicalFloatRegs, numPhysicalFloatRegs);
@@ -82,6 +85,10 @@
     numLogicalRegs = numLogicalIntRegs + numLogicalFloatRegs;
 
     numPhysicalRegs = numPhysicalIntRegs + numPhysicalFloatRegs;
+//    printf("Creating rename map %i.  Phys: %i / %i, Float: "
+//            "%i / %i. %i %i\n", id, numLogicalIntRegs, numPhysicalIntRegs,
+//            numLogicalFloatRegs, numPhysicalFloatRegs,numMiscRegs,numLogicalRegs);
+
 
     //Create the rename maps
     intRenameMap.resize(numLogicalIntRegs);
@@ -139,7 +146,6 @@
 {
     PhysRegIndex renamed_reg;
     PhysRegIndex prev_reg;
-
     if (arch_reg < numLogicalIntRegs) {
 
         // Record the current physical register that is renamed to the
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rename_map.hh
--- a/src/cpu/o3/rename_map.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rename_map.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -43,11 +43,10 @@
 #include "config/the_isa.hh"
 #include "cpu/o3/free_list.hh"
 
-class SimpleRenameMap
-{
-  protected:
+class SimpleRenameMap {
+protected:
     typedef TheISA::RegIndex RegIndex;
-  public:
+public:
     /**
      * Pair of a logical register and a physical register.  Tells the
      * previous mapping of a logical register to a physical register.
@@ -63,29 +62,33 @@
      */
     typedef std::pair<PhysRegIndex, PhysRegIndex> RenameInfo;
 
-  public:
+public:
+
     /** Default constructor.  init() must be called prior to use. */
-    SimpleRenameMap() {};
+    SimpleRenameMap() {
+    };
 
     /** Destructor. */
     ~SimpleRenameMap();
 
     /** Initializes rename map with given parameters. */
     void init(unsigned _numLogicalIntRegs,
-              unsigned _numPhysicalIntRegs,
-              PhysRegIndex &_int_reg_start,
+            unsigned _numPhysicalIntRegs,
+            PhysRegIndex &_int_reg_start,
 
-              unsigned _numLogicalFloatRegs,
-              unsigned _numPhysicalFloatRegs,
-              PhysRegIndex &_float_reg_start,
+            unsigned _numLogicalFloatRegs,
+            unsigned _numPhysicalFloatRegs,
+            PhysRegIndex &_float_reg_start,
 
-              unsigned _numMiscRegs,
+            unsigned _numMiscRegs,
 
-              RegIndex _intZeroReg,
-              RegIndex _floatZeroReg,
+            RegIndex _intZeroReg,
+            RegIndex _floatZeroReg,
 
-              int id,
-              bool bindRegs);
+            int id,
+            bool bindRegs);
+
+
 
     /** Sets the free list used with this rename map. */
     void setFreeList(SimpleFreeList *fl_ptr);
@@ -107,10 +110,14 @@
 
     int numFreeEntries();
 
-  private:
+private:
     /** Rename Map ID  */
     int id;
 
+
+
+private:
+
     /** Number of logical integer registers. */
     int numLogicalIntRegs;
 
@@ -142,25 +149,24 @@
      */
     RegIndex floatZeroReg;
 
-    class RenameEntry
-    {
-      public:
+    class RenameEntry {
+    public:
         PhysRegIndex physical_reg;
         bool valid;
 
         RenameEntry()
-            : physical_reg(0), valid(false)
-        { }
+        : physical_reg(0), valid(false) {
+        }
     };
 
-  private:
+private:
     /** Integer rename map. */
     std::vector<RenameEntry> intRenameMap;
 
     /** Floating point rename map. */
     std::vector<RenameEntry> floatRenameMap;
 
-  private:
+private:
     /** Free list interface. */
     SimpleFreeList *freeList;
 };
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rob.hh
--- a/src/cpu/o3/rob.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rob.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -321,6 +321,10 @@
      */
     InstIt squashIt[Impl::MaxThreads];
 
+
+    
+    int countInstrs;
+
   public:
     /** Number of instructions in the ROB. */
     int numInstsInROB;
@@ -328,6 +332,10 @@
     /** Dummy instruction returned if there are no insts left. */
     DynInstPtr dummyInst;
 
+
+    void updateCounter();
+
+
   private:
     /** The sequence number of the squashed instruction. */
     InstSeqNum squashedSeqNum[Impl::MaxThreads];
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/rob_impl.hh
--- a/src/cpu/o3/rob_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/rob_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -42,9 +42,9 @@
  */
 
 #include <list>
-
 #include "cpu/o3/rob.hh"
 #include "debug/Fetch.hh"
+
 #include "debug/ROB.hh"
 
 using namespace std;
@@ -59,6 +59,7 @@
       numInstsInROB(0),
       numThreads(_numThreads)
 {
+
     std::string policy = _smtROBPolicy;
 
     //Convert string to lowercase
@@ -131,6 +132,15 @@
 
 template <class Impl>
 void
+ROB<Impl>::updateCounter(){
+    countInstrs++;
+    countInstrs=countInstrs%numEntries;
+}
+
+
+
+template <class Impl>
+void
 ROB<Impl>::setActiveThreads(list<ThreadID> *at_ptr)
 {
     DPRINTF(ROB, "Setting active threads list pointer.\n");
@@ -213,6 +223,8 @@
 
     robWrites++;
 
+    this->updateCounter();
+
     DPRINTF(ROB, "Adding inst PC %s to the ROB.\n", inst->pcState());
 
     assert(numInstsInROB != numEntries);
@@ -339,7 +351,6 @@
 
         squashIt[tid] = instList[tid].end();
 
-        doneSquashing[tid] = true;
         return;
     }
 
@@ -351,10 +362,10 @@
          (*squashIt[tid])->seqNum > squashedSeqNum[tid];
          ++numSquashed)
     {
-        DPRINTF(ROB, "[tid:%u]: Squashing instruction PC %s, seq num %i.\n",
+        DPRINTF(ROB, "[tid:%u]: Squashing instruction PC %s, seq num %i, NumSquashed %d %d .\n",
                 (*squashIt[tid])->threadNumber,
                 (*squashIt[tid])->pcState(),
-                (*squashIt[tid])->seqNum);
+                (*squashIt[tid])->seqNum, numSquashed, squashWidth);
 
         // Mark the instruction as squashed, and ready to commit so that
         // it can drain out of the pipeline.
@@ -489,6 +500,7 @@
                 "[sn:%i]\n",
                 squash_num);
 
+    doneSquashing[tid] = true;
         return;
     }
 
@@ -505,7 +517,6 @@
         tail_thread--;
 
         squashIt[tid] = tail_thread;
-
         doSquash(tid);
     }
 }
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/scoreboard.cc
--- a/src/cpu/o3/scoreboard.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/scoreboard.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -97,6 +97,12 @@
     }
 #endif
 
+    if( regScoreBoard[phys_reg]){
+        DPRINTF(Scoreboard, "Getting reg %i as not busy \n", phys_reg);
+    }else{
+        DPRINTF(Scoreboard, "Getting reg %i as busy\n", phys_reg);
+    }
+
     assert(indexInBounds(phys_reg));
     return regScoreBoard[phys_reg];
 }
@@ -113,6 +119,7 @@
 void
 Scoreboard::unsetReg(PhysRegIndex ready_reg)
 {
+    DPRINTF(Scoreboard, "Setting reg %i as not ready\n", ready_reg);
 #if THE_ISA == ALPHA_ISA
     if (ready_reg == zeroRegIdx ||
         ready_reg == (zeroRegIdx + numPhysicalIntRegs)) {
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/o3/scoreboard.hh
--- a/src/cpu/o3/scoreboard.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/o3/scoreboard.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -82,6 +82,8 @@
     /** Sets the register as not ready. */
     void unsetReg(PhysRegIndex ready_reg);
 
+
+
   private:
     /** Scoreboard of physical integer registers, saying whether or not they
      *  are ready.
@@ -113,6 +115,8 @@
     int zeroRegIdx;
 
     int currentSize;
+    
+
 
     void
     resize(int newSize)
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/AtomicSimpleCPU.py
--- a/src/cpu/simple/AtomicSimpleCPU.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/AtomicSimpleCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -57,6 +57,13 @@
     def support_take_over(cls):
         return True
 
+    @classmethod
+    def export_methods(cls, code):
+        code('''
+    void suspendContext(ThreadID tid);
+    void activateContext(ThreadID tid, Cycles delay);
+''')
+
     width = Param.Int(1, "CPU width")
     simulate_data_stalls = Param.Bool(False, "Simulate dcache stall cycles")
     simulate_inst_stalls = Param.Bool(False, "Simulate icache stall cycles")
@@ -64,3 +71,4 @@
     simpoint_profile = Param.Bool(False, "Generate SimPoint BBVs")
     simpoint_interval = Param.UInt64(100000000, "SimPoint Interval Size (insts)")
     simpoint_profile_file = Param.String("simpoint.bb.gz", "SimPoint BBV file")
+#    branchPred = BranchPredictor(numThreads = Parent.numThreads)
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/BaseSimpleCPU.py
--- a/src/cpu/simple/BaseSimpleCPU.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/BaseSimpleCPU.py	Wed Aug 05 11:39:08 2015 +0100
@@ -30,6 +30,8 @@
 from m5.params import *
 from BaseCPU import BaseCPU
 from DummyChecker import DummyChecker
+from BranchPredictor import BranchPredictor
+
 
 class BaseSimpleCPU(BaseCPU):
     type = 'BaseSimpleCPU'
@@ -46,3 +48,4 @@
         else:
             print "ERROR: Checker only supported under ARM ISA!"
             exit(1)
+#    branchPred = Param.BranchPredictor(NULL, "Branch Predictor")
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/atomic.cc
--- a/src/cpu/simple/atomic.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/atomic.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -201,6 +201,17 @@
 
 
 void
+AtomicSimpleCPU::pause(bool pause)
+{
+    if (pause && tickEvent.scheduled()) {
+        deschedule(tickEvent);
+    } else if (!pause && !tickEvent.scheduled()) {
+        schedule(tickEvent, nextCycle());
+    }
+}
+
+
+void
 AtomicSimpleCPU::switchOut()
 {
     BaseSimpleCPU::switchOut();
@@ -527,6 +538,13 @@
             preExecute();
 
             if (curStaticInst) {
+                
+                for(int i=0;i<curStaticInst->numDestRegs();i++){
+                    if(curStaticInst->destRegIdx(i)<15){
+                        
+                    }
+                }
+                
                 fault = curStaticInst->execute(this, traceData);
 
                 // keep an instruction count
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/atomic.hh
--- a/src/cpu/simple/atomic.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/atomic.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -240,6 +240,7 @@
     unsigned int drain(DrainManager *drain_manager);
     void drainResume();
 
+    void pause(bool pause);
     void switchOut();
     void takeOverFrom(BaseCPU *oldCPU);
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/base.cc
--- a/src/cpu/simple/base.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/base.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -64,6 +64,7 @@
 #include "cpu/smt.hh"
 #include "cpu/static_inst.hh"
 #include "cpu/thread_context.hh"
+#include "cpu/pred/bpred_unit.hh"
 #include "debug/Decode.hh"
 #include "debug/Fetch.hh"
 #include "debug/Quiesce.hh"
@@ -84,7 +85,7 @@
 using namespace TheISA;
 
 BaseSimpleCPU::BaseSimpleCPU(BaseSimpleCPUParams *p)
-    : BaseCPU(p), traceData(NULL), thread(NULL)
+    : BaseCPU(p),  traceData(NULL), thread(NULL)
 {
     if (FullSystem)
         thread = new SimpleThread(this, 0, p->system, p->itb, p->dtb,
@@ -97,6 +98,8 @@
 
     tc = thread->getTC();
 
+    branchPred= p->branchPred;
+    
     if (p->checker) {
         BaseCPU *temp_checker = p->checker;
         checker = dynamic_cast<CheckerCPU *>(temp_checker);
@@ -269,6 +272,12 @@
         .desc("DCache total retry cycles")
         .prereq(dcacheRetryCycles)
         ;
+    SumintRegReads
+        .init(16)
+        .name(name() + ".Register_Write_Individual")
+        .desc("Number of times a Register is written to")
+        .flags(total)
+        ;
 
     idleFraction = constant(1.0) - notIdleFraction;
     numIdleCycles = idleFraction * numCycles;
@@ -421,6 +430,14 @@
                 curStaticInst->getName(), curStaticInst->machInst);
 #endif // TRACING_ON
     }
+    if (branchPred && curStaticInst && curStaticInst->isControl()) {
+        // Use a fake sequence number since we only have one
+        // instruction in flight at the same time.
+        const InstSeqNum cur_sn(0);
+        const ThreadID tid(0);
+        TheISA::PCState pred_pc = thread->pcState();
+        branchPred->predict(curStaticInst, cur_sn, pred_pc, tid);
+    }   
 }
 
 void
@@ -498,6 +515,7 @@
 void
 BaseSimpleCPU::advancePC(Fault fault)
 {
+    const bool branching(thread->pcState().branching());
     //Since we're moving to a new pc, zero out the offset
     fetchOffset = 0;
     if (fault != NoFault) {
@@ -513,6 +531,22 @@
             thread->pcState(pcState);
         }
     }
+    if (branchPred && curStaticInst && curStaticInst->isControl()) {
+        // Use a fake sequence number since we only have one
+        // instruction in flight at the same time.
+        const InstSeqNum cur_sn(0);
+        const ThreadID tid(0);
+
+        if (pred_pc == thread->pcState()) {
+            // Correctly predicted branch
+            branchPred->update(cur_sn, tid);
+        } else {
+            // Mis-predicted branch
+            branchPred->squash(cur_sn, pcState(),
+                               branching, tid);
+        }
+    }
+    
 }
 
 void
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple/base.hh
--- a/src/cpu/simple/base.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple/base.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -85,6 +85,8 @@
     typedef TheISA::FloatReg FloatReg;
     typedef TheISA::FloatRegBits FloatRegBits;
 
+    TheISA::PCState pred_pc;
+
   protected:
     Trace::InstRecord *traceData;
 
@@ -98,6 +100,7 @@
     }
 
   public:
+
     void wakeup();
 
     void zero_fill_64(Addr addr) {
@@ -265,6 +268,10 @@
     // number of cycles stalled for D-cache retries
     Stats::Scalar dcacheRetryCycles;
     Counter lastDcacheRetry;
+    
+    
+    Stats::Vector SumintRegReads;
+//    Stats::Vector SumFloatRegReads;
 
     void serializeThread(std::ostream &os, ThreadID tid);
     void unserializeThread(Checkpoint *cp, const std::string &section,
@@ -289,7 +296,7 @@
 
     uint64_t readIntRegOperand(const StaticInst *si, int idx)
     {
-        numIntRegReads++;
+          numIntRegReads++;
         return thread->readIntReg(si->srcRegIdx(idx));
     }
 
@@ -309,6 +316,9 @@
 
     void setIntRegOperand(const StaticInst *si, int idx, uint64_t val)
     {
+        if(si->srcRegIdx(idx)<16)
+                SumintRegReads[si->srcRegIdx(idx)]++;
+
         numIntRegWrites++;
         thread->setIntReg(si->destRegIdx(idx), val);
     }
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/simple_thread.hh
--- a/src/cpu/simple_thread.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/simple_thread.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -56,6 +56,7 @@
 #include "cpu/thread_state.hh"
 #include "debug/FloatRegs.hh"
 #include "debug/IntRegs.hh"
+#include<debug/PH.hh>
 #include "mem/page_table.hh"
 #include "mem/request.hh"
 #include "sim/byteswap.hh"
@@ -192,8 +193,12 @@
     BaseCPU *getCpuPtr() { return baseCpu; }
 
     TheISA::TLB *getITBPtr() { return itb; }
+    
+    void setITBPtr(TheISA::TLB * nitb) {  itb =nitb; }
 
     TheISA::TLB *getDTBPtr() { return dtb; }
+    
+    void setDTBPtr(TheISA::TLB * ndtb) { dtb=ndtb; }
 
     CheckerCPU *getCheckerCpuPtr() { return NULL; }
 
@@ -264,6 +269,9 @@
     {
         int flatIndex = isa->flattenIntIndex(reg_idx);
         assert(flatIndex < TheISA::NumIntRegs);
+//        DPRINTF(PH,"Setting int reg %d (%d) to %#x.\n",
+//                reg_idx, flatIndex, val);
+
         DPRINTF(IntRegs, "Setting int reg %d (%d) to %#x.\n",
                 reg_idx, flatIndex, val);
         setIntRegFlat(flatIndex, val);
@@ -276,6 +284,9 @@
         setFloatRegFlat(flatIndex, val);
         DPRINTF(FloatRegs, "Setting float reg %d (%d) to %f, %#x.\n",
                 reg_idx, flatIndex, val, floatRegs.i[flatIndex]);
+//        DPRINTF(PH, "Setting float reg %d (%d) to %f, %#x.\n",
+//                reg_idx, flatIndex, val, floatRegs.i[flatIndex]);
+
     }
 
     void setFloatRegBits(int reg_idx, FloatRegBits val)
@@ -356,7 +367,10 @@
 
     void
     setMiscReg(int misc_reg, const MiscReg &val, ThreadID tid = 0)
-    {
+    { 
+//        DPRINTF(PH, "Setting misc reg %d (%d) \n",
+//                misc_reg, val);
+
         return isa->setMiscReg(misc_reg, val, tc);
     }
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/static_inst.hh
--- a/src/cpu/static_inst.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/static_inst.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -62,6 +62,8 @@
 class FastCPU;
 class AtomicSimpleCPU;
 class TimingSimpleCPU;
+class TimingDeadCPU;
+class TimingHelperCPU;
 class InorderCPU;
 class SymbolTable;
 
diff -r 2492d7ccda7e -r 33141d198579 src/cpu/thread_state.hh
--- a/src/cpu/thread_state.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/cpu/thread_state.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -105,6 +105,8 @@
 
     Process *getProcessPtr() { return process; }
 
+    void  setProcessPtr(Process *prs){process=prs;}
+
     SETranslatingPortProxy &getMemProxy();
 
     /** Reads the number of instructions functionally executed and
diff -r 2492d7ccda7e -r 33141d198579 src/mem/cache/cache_impl.hh
--- a/src/mem/cache/cache_impl.hh	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/mem/cache/cache_impl.hh	Wed Aug 05 11:39:08 2015 +0100
@@ -1455,8 +1455,8 @@
         DPRINTF(Cache, "Deferring snoop on in-service MSHR to blk %x."
                 "mshrs: %s\n", blk_addr, mshr->print());
 
-        if (mshr->getNumTargets() > numTarget)
-            warn("allocating bonus target for snoop"); //handle later
+//        if (mshr->getNumTargets() > numTarget)
+//            warn("allocating bonus target for snoop"); //handle later
         return;
     }
 
diff -r 2492d7ccda7e -r 33141d198579 src/python/m5/__init__.py
--- a/src/python/m5/__init__.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/python/m5/__init__.py	Wed Aug 05 11:39:08 2015 +0100
@@ -32,7 +32,7 @@
 
 try:
     # Try to import something that's generated by swig
-    import internal
+    import internal.core
 
     # Try to grab something from it in case demandimport is being used
     internal.core.curTick
diff -r 2492d7ccda7e -r 33141d198579 src/python/m5/internal/__init__.py
--- a/src/python/m5/internal/__init__.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/python/m5/internal/__init__.py	Wed Aug 05 11:39:08 2015 +0100
@@ -26,9 +26,9 @@
 #
 # Authors: Nathan Binkert
 
-import core
-import debug
-import event
-import stats
-import trace
-from drain import DrainManager, Drainable
+#import core
+#import debug
+#import event
+#import stats
+#import trace
+#from drain import DrainManager, Drainable
diff -r 2492d7ccda7e -r 33141d198579 src/python/m5/main.py
--- a/src/python/m5/main.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/python/m5/main.py	Wed Aug 05 11:39:08 2015 +0100
@@ -100,7 +100,7 @@
         help="Print help on trace flags")
     option("--debug-flags", metavar="FLAG[,FLAG]", action='append', split=',',
         help="Sets the flags for tracing (-FLAG disables a flag)")
-    option("--remote-gdb-port", type='int', default=7000,
+    option("--remote-gdb-port", type='int', default=0,
         help="Remote gdb base port (set to 0 to disable listening)")
 
     # Tracing options
diff -r 2492d7ccda7e -r 33141d198579 src/python/m5/simulate.py
--- a/src/python/m5/simulate.py	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/python/m5/simulate.py	Wed Aug 05 11:39:08 2015 +0100
@@ -118,6 +118,7 @@
     # Do a third pass to initialize statistics
     for obj in root.descendants(): obj.regStats()
 
+
     # We're done registering statistics.  Enable the stats package now.
     stats.enable()
 
@@ -238,7 +239,6 @@
     Keyword Arguments:
       do_drain -- Perform a drain/resume of the system when switching.
     """
-    print "switching cpus"
     if not isinstance(cpuList, list):
         raise RuntimeError, "Must pass a list to this function"
     for item in cpuList:
diff -r 2492d7ccda7e -r 33141d198579 src/sim/process.cc
--- a/src/sim/process.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/sim/process.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -438,7 +438,8 @@
                }
             } else {
                 //Open file
-                int fd = open(fdo->filename.c_str(), fdo->flags, fdo->mode);
+                int flags = fdo->flags & ~O_EXCL;
+                int fd = open(fdo->filename.c_str(), flags, fdo->mode);
 
                 if (fd == -1)
                     panic("Unable to open file: %s", fdo->filename);
diff -r 2492d7ccda7e -r 33141d198579 src/sim/simulate.cc
--- a/src/sim/simulate.cc	Fri Jul 19 11:52:07 2013 +0200
+++ b/src/sim/simulate.cc	Wed Aug 05 11:39:08 2015 +0100
@@ -82,6 +82,11 @@
                 hack_once("be nice to actually delete the event here");
             }
 
+
+            if (se_event == limit_event) {
+                hack_once("Limit Event incidented");
+            }
+
             return se_event;
         }
 
